[
    {
        "code": "private void handleAdjustPublishRate(Context ctx) throws Exception {\n    Double publishRate = mapper.readValue(ctx.body(), Double.class);",
        "pred_variables": [
            "mapper",
            "body",
            "publishRate"
        ],
        "label_variables": [
            "publishRate"
        ]
    },
    {
        "code": "private int getFileCount(File dir) {\n    if (dir.isDirectory()) {\n        String[] children = dir.list();",
        "pred_variables": [
            "children"
        ],
        "label_variables": [
            "children"
        ]
    },
    {
        "code": "@Override\npublic MessageProcessResult process(Message message, Peer peer) {\n    if (log.isDebugEnabled()) {",
        "pred_variables": [
            "message",
            "peer"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "protected static <T extends Id> T readOrGenerate(SimpleStorage<T> storage, InternalLog log, Class<T> type, Function<UUID, ? extends T> creator, Supplier<UUID> uuid) {\n    T myself;\n    try {\n        if (storage.exists()) {\n            myself = storage.readState();\n            if (myself == null) {\n                throw new IllegalStateException(String.format(\"%s storage was found on disk, but it could not be read correctly\", type.getSimpleName()));\n            } else {",
        "pred_variables": [
            "creator",
            "Supplier",
            "getSimpleName",
            "type"
        ],
        "label_variables": [
            "myself"
        ]
    },
    {
        "code": "    } catch (IOException e) {\n        throw new SenderException(\"Could not read output of command [\" + getCommandLine(command) + \"]\", e);\n    }\n    // Read the errors of the process\n    try {\n        errors = readStream(process.getErrorStream());\n    } catch (IOException e) {\n        throw new SenderException(\"Could not read errors of command [\" + getCommandLine(command) + \"]\", e);\n    }\n    // Throw an exception if the command returns an error exit value\n    int exitValue = process.exitValue();\n    if (exitValue != 0) {\n        throw new SenderException(\"Nonzero exit value [\" + exitValue + \"] for command  [\" + getCommandLine(command) + \"], process output was [\" + output + \"], error output was [\" + errors + \"]\");\n    }\n    if (StringUtils.isNotEmpty(errors)) {",
        "pred_variables": [],
        "label_variables": [
            "command"
        ]
    },
    {
        "code": "@Override\npublic void write(int i) throws IOException {\n    StringBuilder sb = local.get();\n    if (sb == null) {\n        sb = new StringBuilder();\n    }\n    //look for LF\n    if (i == 10) {",
        "pred_variables": [
            "i",
            "sb"
        ],
        "label_variables": [
            "i"
        ]
    },
    {
        "code": "    GroupTopicPartition key = (GroupTopicPartition) baseKey.key();\n    if (data.value() == null || data.value().length == 0) {\n        log.warn(\"Value is null or Empty for: {}\", key.toString());\n        return;\n    }\n    OffsetAndMetadata offsetAndMetadata = GroupMetadataManager.readOffsetMessageValue(ByteBuffer.wrap(data.value()));\n    String group = key.group();\n    int partitionNo = key.topicPartition().partition();\n    String topic = key.topicPartition().topic();\n    long offset = offsetAndMetadata.offset();\n    if (!(shouldCollectEvent(topic) && shouldCollectConsumer(group))) {\n        return;\n    }\n    Partition oldPartition = (Partition) topicsMap.executeOnKey(topic, new ConsumerOffsetChangeEntryProcessor(group, partitionNo, offset));\n    if (oldPartition != null) {",
        "pred_variables": [
            "topic"
        ],
        "label_variables": [
            "offset",
            "topic",
            "group"
        ]
    },
    {
        "code": "@Override\npublic void resultReceived(IPendingServiceCall call) {",
        "pred_variables": [
            "call"
        ],
        "label_variables": [
            "call"
        ]
    },
    {
        "code": "@Override\npublic void destroy() {\n    // terminate any active websocket sessions\n    SessionManager sm = XMPPServer.getInstance().getSessionManager();\n    for (ClientSession session : sm.getSessions()) {\n        if (session instanceof LocalSession) {\n            Object ws = ((LocalSession) session).getSessionData(\"ws\");\n            if (ws != null && (Boolean) ws) {",
        "pred_variables": [
            "Boolean",
            "ws",
            "session"
        ],
        "label_variables": [
            "session"
        ]
    },
    {
        "code": "@CheckForNull\nprivate BindingConfigChangedEvent bind(String configurationScopeId, BindingConfigurationDto bindingConfiguration) {\n    var previousBindingConfig = repository.getBindingConfiguration(configurationScopeId);\n    if (previousBindingConfig == null) {",
        "pred_variables": [
            "configurationScopeId",
            "BindingConfigurationDto"
        ],
        "label_variables": [
            "configurationScopeId"
        ]
    },
    {
        "code": "private void getCustomerOrders() throws AxisFault, XPathExpressionException {\n    OMElement payload = fac.createOMElement(\"customerOrders\", omNs);\n    OMElement result = new AxisServiceClient().sendReceive(payload, getServiceUrlHttp(serviceName), \"customerOrders\");\n    Assert.assertNotNull(result, \"Response message null \");",
        "pred_variables": [
            "result"
        ],
        "label_variables": [
            "result"
        ]
    },
    {
        "code": "public static String runAndWaitNoLog(File folder, String... command) {\n    String output = \"\";\n    try {\n        Process process = new ProcessBuilder(command).directory(folder).redirectErrorStream(false).start();\n        process.waitFor();\n        output = IOUtils.toString(process.getInputStream(), UTF_8);\n    } catch (Exception e) {\n        if (log.isDebugEnabled()) {",
        "pred_variables": [
            "output",
            "command"
        ],
        "label_variables": [
            "command"
        ]
    },
    {
        "code": "/**\n * Clientside test\n */\n@Test\npublic void testOutboundHandshake() {\n    log.info(\"\\ntestOutboundHandshake\");\n    OutboundHandshake out = new OutboundHandshake();\n    // set the handshake type\n    out.setHandshakeType(RTMPConnection.RTMP_NON_ENCRYPTED);\n    // called initially with null input which triggers creation of C1\n    //IoBuffer C1 = hs.doHandshake(null);",
        "pred_variables": [
            "hs",
            "doHandshake"
        ],
        "label_variables": [
            "C1"
        ]
    },
    {
        "code": "/**\n * Creates a cached response. <br />\n * If no cached data is found, the responseObject is\n * returned. <br />\n * If cached data is found, <code>null</code> is returned instead.\n *\n * @param req - original request\n * @param etagFromResources - new etags\n * @param responseObject - the response object\n * @return\n */\nprivate JsonObject makeCachedResponse(HttpServerRequest req, String etagFromResources, JsonObject responseObject) {\n    JsonObject result = responseObject;\n    if (log.isTraceEnabled()) {\n        log.trace(\"Header from request:  {}\", req.headers().get(IF_NONE_MATCH_HEADER));",
        "pred_variables": [
            "responseObject",
            "JsonObject",
            "etagFromResources",
            "req"
        ],
        "label_variables": [
            "etagFromResources"
        ]
    },
    {
        "code": "@Override\npublic void handleError(Throwable t) {\n    if (t instanceof UndeclaredThrowableException) {\n        Throwable source = ((UndeclaredThrowableException) t).getUndeclaredThrowable();\n        if (source instanceof OutOfMemoryError) {",
        "pred_variables": [
            "source",
            "t"
        ],
        "label_variables": [
            "source"
        ]
    },
    {
        "code": "private void registerNatsEnvironment(GenericContainer<?> natsContainer, ConfigurableEnvironment environment, NatsProperties properties) {\n    Integer clientMappedPort = natsContainer.getMappedPort(properties.getClientPort());\n    Integer httpMonitorMappedPort = natsContainer.getMappedPort(properties.getHttpMonitorPort());\n    Integer routeConnectionsMappedPort = natsContainer.getMappedPort(properties.getRouteConnectionsPort());\n    String host = natsContainer.getHost();\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.nats.host\", host);\n    map.put(\"embedded.nats.port\", clientMappedPort);\n    map.put(\"embedded.nats.httpMonitorPort\", httpMonitorMappedPort);\n    map.put(\"embedded.nats.routeConnectionsPort\", routeConnectionsMappedPort);",
        "pred_variables": [
            "nats"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "// Implementation methods\n// -------------------------------------------------------------------------\nprotected void registerMBean(ObjectName name) {\n    if (name != null) {\n        try {\n            AnnotatedMBean.registerMBean(managementContext, mbean, name);\n        } catch (Throwable e) {",
        "pred_variables": [
            "name"
        ],
        "label_variables": [
            "name"
        ]
    },
    {
        "code": "@Override\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n    String message = formattedMessages ? DocumentedUtils.extractFormattedMessage(method, args) : DocumentedUtils.extractMessage(method);\n    if (method.getAnnotation(Warning.class) == null) {\n        errors.incrementAndGet();",
        "pred_variables": [
            "method",
            "message"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "private void stopDatabase(StandaloneDatabaseContext context) {\n    var namedDatabaseId = context.database().getNamedDatabaseId();\n    try {",
        "pred_variables": [
            "namedDatabaseId",
            "context"
        ],
        "label_variables": [
            "namedDatabaseId"
        ]
    },
    {
        "code": "private boolean accept(InputFile indexedFile) {\n    // InputFileFilter extensions. Might trigger generation of metadata\n    for (InputFileFilter filter : filters) {\n        if (!filter.accept(indexedFile)) {",
        "pred_variables": [
            "extensions",
            "trigger"
        ],
        "label_variables": [
            "indexedFile"
        ]
    },
    {
        "code": "@Test\npublic void testValidate() {\n    log.info(\"\\ntestValidate\");\n    // client side handshake handler\n    OutboundHandshake out = new OutboundHandshake();\n    // set the handshake type\n    out.setHandshakeType(RTMPConnection.RTMP_NON_ENCRYPTED);\n    // try SO12\n    IoBuffer S0S1S2 = IoBuffer.allocate(3073);\n    S0S1S2.put(serverS0S1S2part1);\n    S0S1S2.put(serverS0S1S2part2);\n    S0S1S2.flip();\n    // strip the 03 type byte\n    S0S1S2.get();",
        "pred_variables": [
            "out",
            "S0S1S2"
        ],
        "label_variables": [
            "S0S1S2"
        ]
    },
    {
        "code": "public Pair<String, String> generateNewDN(String baseDn) {\n    final String inum = generateInum();\n    final StringBuilder dnSb = new StringBuilder(\"inum=\");\n    dnSb.append(inum).append(\",\").append(baseDn);\n    final String dn = dnSb.toString();",
        "pred_variables": [
            "inum",
            "dnSb"
        ],
        "label_variables": [
            "dn"
        ]
    },
    {
        "code": "public static Server create(Path socketPath) throws IOException {\n    Files.createDirectories(socketPath.getParent());\n    var address = UnixDomainSocketAddress.of(socketPath);\n    ServerSocketChannel ch = null;\n    try {\n        ch = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n        ch.bind(address);",
        "pred_variables": [
            "getParent",
            "bind",
            "socketPath"
        ],
        "label_variables": [
            "socketPath"
        ]
    },
    {
        "code": "@Override\npublic void failToRecoverTransactionsAfterCommit(Throwable t, LogEntryCommit commitEntry, LogPosition recoveryToPosition) {",
        "pred_variables": [
            "commitEntry",
            "t"
        ],
        "label_variables": [
            "recoveryToPosition",
            "t"
        ]
    },
    {
        "code": "public void store(ServerInfo serverInfo) {\n    var serverInfoFilePath = getServerInfoFilePath();\n    FileUtils.mkdirs(serverInfoFilePath.getParent());\n    var serverInfoToStore = adapt(serverInfo);",
        "pred_variables": [
            "serverInfo"
        ],
        "label_variables": [
            "serverInfoFilePath"
        ]
    },
    {
        "code": "@Override\npublic void onWSMessage(WSMessage message) {\n    // assume we have text\n    String msg = new String(message.getPayload().array());",
        "pred_variables": [
            "msg"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "public byte[] encrypt(byte[] cleartext, String algorithm, String javaSecurityAPIProvider) throws CryptoException {\n    try {\n        Cipher cipher;\n        if (StringUtils.isBlank(javaSecurityAPIProvider)) {\n            cipher = Cipher.getInstance(algorithm);\n        } else {\n            cipher = Cipher.getInstance(algorithm, javaSecurityAPIProvider);\n        }\n        Certificate certificate = getCertificateFromStore();\n        if (log.isDebugEnabled()) {\n            log.debug(\"Certificate used for encrypting : \" + certificate);\n        }\n        cipher.init(Cipher.ENCRYPT_MODE, certificate.getPublicKey());\n        byte[] ciphertext = cipher.doFinal(cleartext);\n        if (log.isDebugEnabled()) {",
        "pred_variables": [
            "ciphertext",
            "cleartext",
            "ENCRYPT_MODE"
        ],
        "label_variables": [
            "javaSecurityAPIProvider",
            "algorithm"
        ]
    },
    {
        "code": "private void registrationFailed(Throwable cause) {",
        "pred_variables": [
            "cause"
        ],
        "label_variables": [
            "cause"
        ]
    },
    {
        "code": "@Override\npublic void warn(Throwable cause) {",
        "pred_variables": [
            "cause"
        ],
        "label_variables": [
            "cause"
        ]
    },
    {
        "code": "@Override\npublic void resourceRemoved(String resourceUri) {\n    if (configResourceUri() != null && configResourceUri().equals(resourceUri)) {",
        "pred_variables": [
            "resourceUri",
            "configResourceUri"
        ],
        "label_variables": [
            "resourceUri"
        ]
    },
    {
        "code": "/**\n * Creates a large byte buffer and fills it with char 'X' except for the\n * last byte, it gets value 0x0 assigned.\n *\n * @param size - the size of the array to be created.\n * @return\n */\nprotected byte[] createLargeByteBuffer(int size) {\n    byte[] buffer = new byte[size];\n    for (int i = 0; i < size; i++) {\n        buffer[i] = (char) 'X';\n    }\n    //insert trailing 0x0\n    buffer[size - 1] = 0;",
        "pred_variables": [
            "size"
        ],
        "label_variables": [
            "size"
        ]
    },
    {
        "code": "@Bean(name = BEAN_NAME_EMBEDDED_CASSANDRA, destroyMethod = \"stop\")\npublic CassandraContainer cassandra(ConfigurableEnvironment environment, CassandraProperties properties, Optional<Network> network) throws Exception {\n    CassandraContainer cassandra = new CassandraContainer<>(ContainerUtils.getDockerImageName(properties)).withExposedPorts(properties.getPort());\n    network.ifPresent(cassandra::withNetwork);\n    cassandra = (CassandraContainer) configureCommonsAndStart(cassandra, properties, log);\n    initKeyspace(properties, cassandra);\n    Map<String, Object> cassandraEnv = registerCassandraEnvironment(environment, cassandra, properties);",
        "pred_variables": [
            "network",
            "properties",
            "registerCassandraEnvironment"
        ],
        "label_variables": [
            "cassandraEnv"
        ]
    },
    {
        "code": "@Override\npublic BlockStore getGengsisBlock() {\n    //if(1==1)return null;\n    BlockStore gengsisBlock = new BlockStore(this, Hex.decode(\"0000000000000000000000000000000000000000000000000000000000000000000000008c5bab5ff30e63e4133864e1f1c5fcffea009d762a29a081e665a0ed08d52c9eac709e59000000000000ac709e59822103c88c3fd9ad654a3cb89bdc62b1811e0570d36ef229a8e2f3df6e25a03a02e09376a91429af9e39008fa61b5dbaeb7151f05bae0e99fbd9884630440220640e2390967a750e6e6590e698ed9b3aec806e0e0a9086bcea348a8ee858c83202206db0ce5969c56f93c7c947bcca99abca9e8b1ed83b339137a8fd8ef2d3d3578cac180101000000010012117468697320612067656e6773697320747800000000010080faca73f91f00000000001976a91458beed5007c23824d6949b2351ac5bf378873dd388acac709e59000000000002010000000101ad1d70ac0c0fd10b059fe15361c2dd33c2adc2949a8933faca4de499592062a4000000006a47304402206a32d626a0bd4211d817b5bdc8f6ed82e1c43754df73c225e916a1c86f02c01c02204564aadec326d65f7310ba8e181170fcd8f7c8d1a08178dc01c68d64d70d7142012103b2d7fe3b88a996f89d08e0fd74eff21f381f25d45fd27b80c065e0acb509a79fffffffff020080c6a47e8d0300005f615d1976a91462bb8758c20c681c289f446f3600867d6de368df88ac00003426f56b1c00000000001976a91458beed5007c23824d6949b2351ac5bf378873dd388acac709e5900000000000601000000ac709e59832103c88c3fd9ad654a3cb89bdc62b1811e0570d36ef229a8e2f3df6e25a03a02e09376a91429af9e39008fa61b5dbaeb7151f05bae0e99fbd988473045022100c5d3fe87a02dff29bcd64dfa2a834c05007b8523c82eec8d8449f84d565c4a9a02205e5d60122ec35c8e75b477af537411ea1aa737a3995c45974126a176107ae381ac29af9e39008fa61b5dbaeb7151f05bae0e99fbd901000000000000000000000000000000000000000000000000000000000000000000000000000000000002010000000101e9933d68953360d141c621205d30fce7838ff9d9dff03c012d1f92bbef0ea515010000006b483045022100ca2ca3d336b4b5e850ac1c8960df16885617c48f2ea5259c79775d4379bd451c022035a1550425cbceebe90f10f27305d347405164cfd6ae15c6a61633980b130c2d012103b2d7fe3b88a996f89d08e0fd74eff21f381f25d45fd27b80c065e0acb509a79fffffffff020010a5d4e8000000000000001976a91429af9e39008fa61b5dbaeb7151f05bae0e99fbd988ac00f08e510c6b1c00000000001976a91458beed5007c23824d6949b2351ac5bf378873dd388acac709e59000000000003010000000000ac709e590000000000822103c88c3fd9ad654a3cb89bdc62b1811e0570d36ef229a8e2f3df6e25a03a02e09376a91429af9e39008fa61b5dbaeb7151f05bae0e99fbd98846304402201991428ca171ae2b0de7e337024c67b1014b0745a6f729b4ded592e5da66b9ac022079c2e196965807877d8f5fc6772611f940909462cd6fc1d8e2e42221db3978d6ac6a24e81229af9e39008fa61b5dbaeb7151f05bae0e99fbd90601000000ac709e598321026be5bb5402d73e1d12fe750063ac8b1568774d3aa1f2465f386e5b63706773ca76a914467f3335249aeb74f3d219b4fb9d5da27287707f88473045022100cfc20dc5462492d1812a5805e11415d95f65c11115544290d231a28bffecbfd502201e1c34a39fb4f1c90df9b9b1900cca4e2a5b75577a997c4c58e85248185c2bdfac467f3335249aeb74f3d219b4fb9d5da27287707f010000000000000000000000000000000000000000000000000000000000000000000000000000000000020100000001015fd5d34cbf2817588f164cc6a04f92ad066ecd4d9eea82b6a29382dc8b0bb5a2010000006a473044022061f47b262c784435a83af153b0cf361bdf8771d486c324ebb3dacc7fee217a860220663d1292ed3384fb22facd84a62d86d63eb52f000e6ff2f44d785607334a15ec012103b2d7fe3b88a996f89d08e0fd74eff21f381f25d45fd27b80c065e0acb509a79fffffffff020010a5d4e8000000000000001976a914467f3335249aeb74f3d219b4fb9d5da27287707f88ac00e0e97c236a1c00000000001976a91458beed5007c23824d6949b2351ac5bf378873dd388acac709e59000000000003010000000000ac709e5900000000008221026be5bb5402d73e1d12fe750063ac8b1568774d3aa1f2465f386e5b63706773ca76a914467f3335249aeb74f3d219b4fb9d5da27287707f88463044022026bb421fcd5086bea0ab86ad25655935dfd3c5c7a043be7d1027da0b98ff5b37022006f08f4f2f0b3c3669a72b46a935728a1d81d7f81ed2fc30c32b8e2f1248b1daac6a24e812467f3335249aeb74f3d219b4fb9d5da27287707f0601000000ac709e5983210279a619a08b08bd823eabb0fe28e543550019e502932ca4fb41ae7da0cbd7cbcb76a91490c8a3ec255015e1e1a5ef33cf289e8d4d47d77388473045022100ec397ecae3828b7e4e9e0a8bc81bc8e771af7c85cc144aeb3df0e7adea2316510220701c101f6b090555c4a23c77f7fcc9d14642d3844f59151c3543306ba66d959dac90c8a3ec255015e1e1a5ef33cf289e8d4d47d773010000000000000000000000000000000000000000000000000000000000000000000000000000000000020100000001017108e03d3562b18de0e9fe7b65f98db7d680a1dfdae008217146995002a61e23010000006b483045022100b7a0fbb7fbed5a703fb73b3291e735f88eda5147a7223a653b3652573353588e02204d8c2f1192b72fd0fe00b62ac5353e187e179e5fadee9a29aba8cd92cf61b4e9012103b2d7fe3b88a996f89d08e0fd74eff21f381f25d45fd27b80c065e0acb509a79fffffffff020010a5d4e8000000000000001976a91490c8a3ec255015e1e1a5ef33cf289e8d4d47d77388ac00d044a83a691c00000000001976a91458beed5007c23824d6949b2351ac5bf378873dd388acac709e59000000000003010000000000ac709e59000000000083210279a619a08b08bd823eabb0fe28e543550019e502932ca4fb41ae7da0cbd7cbcb76a91490c8a3ec255015e1e1a5ef33cf289e8d4d47d77388473045022100859061e7fdf0f082c5683c3ac2d2dc04505de6c6f12f93d82268302fd03ea81702205c7445214fddad88c4ccd1ae09921d98fe8263ce4f14f3fcf08293d7a90ee263ac7a24e81290c8a3ec255015e1e1a5ef33cf289e8d4d47d7730601000000ac709e59822102fc25beaaf30e9f4384474009d4351e75eda3f693b9e59ba5c5de4f16da1233c676a914a7459c79f4dceb5e5105da1134775e2a026e7c2a8846304402204126cc6c5ee37c2c5564ea393c32e89b947778255e9148577a609ea298ecd8ff02200a734c0efd4e65187aad9aa0153ca9adc22cc42afc9b4a925b171cdfadbff620aca7459c79f4dceb5e5105da1134775e2a026e7c2a01000000000000000000000000000000000000000000000000000000000000000000000000000000000002010000000101480fbb2a7c5984f15ad84f384245050469b0c64eb174cd6a4363d05e877ae456010000006a47304402203fdc6ac2b89068b2465e0a4fcfc43212e0317481522177ee256c0ccb673b8cb80220425b70fea6ad6ccbe4e688cc9c0c5d26a5a704c8803ae86beceb624b2558bf91012103b2d7fe3b88a996f89d08e0fd74eff21f381f25d45fd27b80c065e0acb509a79fffffffff020010a5d4e8000000000000001976a914a7459c79f4dceb5e5105da1134775e2a026e7c2a88ac00c09fd351681c00000000001976a91458beed5007c23824d6949b2351ac5bf378873dd388acac709e59000000000003010000000000ac709e590000000000822102fc25beaaf30e9f4384474009d4351e75eda3f693b9e59ba5c5de4f16da1233c676a914a7459c79f4dceb5e5105da1134775e2a026e7c2a884630440220728c3b9207d9d2d2445d3ccc6920df4187a6bf5362d2bf875198aebeefd3fcc1022003e03bf4078e48f4963b28aecbe40806b763bd98c62319dd37326b8d1289600aac7a24e812a7459c79f4dceb5e5105da1134775e2a026e7c2a0601000000ac709e59832103d28e6d213b629ea2a5f46da477c09bdc6f1dccf6fe541f820e907b24493438d276a914a4f7baf52a750f56572e092822959efa83e4763b88473045022100bd7beeff7488e88b9bad4eebb804f7e49d5f8fd882d07bc1fa25ed5df6e9c80102207c66a794d4fe8f116c1caf2c86f5a190a670d186ff1eca1b27fedf25cd3bb4a8aca4f7baf52a750f56572e092822959efa83e4763b01000000000000000000000000000000000000000000000000000000000000000000000000000000000002010000000101121cfa6242bbb28b199485f86016485375dda416616b73451c48e74d8c0615be010000006946304302207daff06fd324679347c62c29d6f5a3185378e04ac32a32972c77ee1b772b5788021f7e90f5ba472849c3f75f265e6b7cd0fa7d927d91cee8b3b0e3550dd30d485c012103b2d7fe3b88a996f89d08e0fd74eff21f381f25d45fd27b80c065e0acb509a79fffffffff020010a5d4e8000000000000001976a914a4f7baf52a750f56572e092822959efa83e4763b88ac00b0fafe68671c00000000001976a91458beed5007c23824d6949b2351ac5bf378873dd388acac709e59000000000003010000000000ac709e590000000000822103d28e6d213b629ea2a5f46da477c09bdc6f1dccf6fe541f820e907b24493438d276a914a4f7baf52a750f56572e092822959efa83e4763b8846304402203ce3dd012314a012815789042154a6ba3b0de49b6ff6f0e5d8de330f1fa8917002205a98c7410377b879356ad16f357162801ea4e5dd74a9d344600589b259574ea5ac7a24e812a4f7baf52a750f56572e092822959efa83e4763b0601000000ac709e598221033e48a377c7830442daceb6fc686b458e2c8b14384989ab657d800e9dd078d42276a91438c6f139891719b79274a759419a3bb5fdd31bef8846304402206e3719a705ec274aaea768b03840dbc6079da28bd46316f3412ce4bb2b0276200220697a5cc90693d706596992202bc93d842712b970b69f957d912f557c60c5db21ac38c6f139891719b79274a759419a3bb5fdd31bef01000000000000000000000000000000000000000000000000000000000000000000000000000000000002010000000101789cdb9889fdbde6ad5e68c1830b95fe23d2658049556f3dfd9f49eca1977fa5010000006a473044022041b214f6638a9ccb5ed241e3cb2ec219b3feba57c1e72eceeb06d73f30b966d302205e7875cabb02459e3adbbe0c3be3e3d27b15f06487613bb74ae5d02c9852ff2e012103b2d7fe3b88a996f89d08e0fd74eff21f381f25d45fd27b80c065e0acb509a79fffffffff020010a5d4e8000000000000001976a91438c6f139891719b79274a759419a3bb5fdd31bef88ac00a0552a80661c00000000001976a91458beed5007c23824d6949b2351ac5bf378873dd388acac709e59000000000003010000000000ac709e5900000000008321033e48a377c7830442daceb6fc686b458e2c8b14384989ab657d800e9dd078d42276a91438c6f139891719b79274a759419a3bb5fdd31bef88473045022100dc8a0cf781f39b01ff68ec0b274b0d42e0152bb5e80321554cf9619ec81e112102201eebbcc1189619fb6740eb83ffdc52107c0cc8d66500582ebd095240796af216ac8924e81238c6f139891719b79274a759419a3bb5fdd31bef0601000000ac709e59822102b4d5ad9bdbf6e75a2d840db09f7158eda4cbd9335a91400fb43ab2b6d67bfdf676a9147696561ec5a4224093cb05aed428a4d182ef169f88463044022076d1575a5d13c04a421030e75760477fb173f52ffd14dc8d5f6825734e880dc3022032b43835a693389a42d45a3a622c5dbcb3a3fe1ea07456b03f914e5dbaf0e314ac7696561ec5a4224093cb05aed428a4d182ef169f010000000000000000000000000000000000000000000000000000000000000000000000000000000000020100000001019d3c36856a496981271d2cf7b32432d48de92ac70d7faccda220d3bca6a9b9cb0100000069463043021f1f029d9f81d487ea3a19286564209550e05b73a4002fe85b08420e1459301902206967c8c0e6360273be94235f7520e94f3a64b3a6b97ef534c68275a6ca5247e8012103b2d7fe3b88a996f89d08e0fd74eff21f381f25d45fd27b80c065e0acb509a79fffffffff020010a5d4e8000000000000001976a9147696561ec5a4224093cb05aed428a4d182ef169f88ac0090b05597651c00000000001976a91458beed5007c23824d6949b2351ac5bf378873dd388acac709e59000000000003010000000000ac709e590000000000822102b4d5ad9bdbf6e75a2d840db09f7158eda4cbd9335a91400fb43ab2b6d67bfdf676a9147696561ec5a4224093cb05aed428a4d182ef169f884630440220381239628611764d25e45c656f78fd2968d1173dd6ec07ac6b2da5b6576eb4e80220609ef8c5eb3e76c3a026f74ab90f9b793d43e653ed1d284978276d1533507573ac8924e8127696561ec5a4224093cb05aed428a4d182ef169f0b010000003c709e5982c22067a1a5f748ba0e4364c2c654942512d03117372738e3687c3682c3afb82919bcc3148ad898b3870a508f6dd15eaf0ab817472d27556788473045022100e2b32b081b7a84dc763463b0ab8839e810b9f81393dcfdabbcbf971830c5d5cc022079e2d8b9cbfcfdd656c8c8bff281f984a68d7d2c2c372fd303bb21e67302cab1ac8ad898b3870a508f6dd15eaf0ab817472d2755678ad898b3870a508f6dd15eaf0ab817472d27556701fd33022e046e616d6506e5908de7a7b021496e636861696e20466f756e646174696f6ee58db0e993bee59fbae98791e4bc9a44046c6f676f06e59bbee7898737687474703a2f2f66696c652e696e636861696e2e6f72672f696d616765732f696e636861696e5f6c6f676f5f313030783130302e706e6727077765627369746506e5ae98e7bd911768747470733a2f2f7777772e696e636861696e2e6f72671f076164647265737309e6b3a8e5868ce59cb00ce4b8ade59bbde9a699e6b8af1e04646174650ce68890e7ab8be697a5e69c9f0b32303137e5b9b437e69c88fd550108646573637269707406e4bb8be7bb8dfd4201496e636861696e20466f756e646174696f6ee58db0e993bee59fbae98791e4bc9a28e4bba5e4b88be7ae80e7a7b0e2809ce59fbae98791e4bc9ae2809d29e698afe4ba8e32303137e5b9b437e69c88e59ca8e4b8ade59bbde9a699e6b8afe68890e7ab8be79a84e99d9ee79b88e588a9e680a7e68b85e4bf9de585ace58fb8efbc8ce59fbae98791e4bc9ae79a84e4b8bbe8a681e79baee6a087e698afe4bf9de8af81496e636861696ee58b9fe99b86e8b584e98791e79a84e9808fe6988ee5ae89e585a8e7aea1e79086e58f8ae59088e79086e4bdbfe794a8efbc8ce887b4e58a9be4ba8ee68ea8e58aa8496e636861696ee585ace69c89e993bee9a1b9e79baee79a84e58fafe68c81e7bbade58f91e5b195efbc8ce4bf83e8bf9b496e636861696ee7a4bee58cbae7949fe68081e79a84e5928ce8b090e7a8b3e5ae9ae380820221035aafeae84325434897723eb462d15f83f62dea079c98f43c96965594da2d71942103acb26a3c346ef0480040cd1099b49143bbf702fe01eb29d7afd85886fde6fdcc0121033b3db51e9c3291df8ddebeb3229e53442867d355eff02ed1372f764072c6fd1900\"));\n    Sha256Hash merkleHash = gengsisBlock.getBlock().buildMerkleHash();\n    if (log.isDebugEnabled()) {",
        "pred_variables": [
            "gengsisBlock",
            "merkleHash"
        ],
        "label_variables": [
            "merkleHash"
        ]
    },
    {
        "code": "private P384KeyPair createAndStoreNewKeyPair(char[] passphrase, Path p12File) throws IOException {\n    var keyPair = P384KeyPair.generate();\n    var tmpFile = p12File.resolveSibling(p12File.getFileName().toString() + \".tmp\");\n    if (Files.exists(tmpFile)) {",
        "pred_variables": [
            "passphrase",
            "toString",
            "tmpFile",
            "Files",
            "tmp",
            "p12File"
        ],
        "label_variables": [
            "tmpFile"
        ]
    },
    {
        "code": "    // Get CSV from Yahoo\n    log.info(\"Sending request: \" + url);\n    URL request = new URL(url);\n    RedirectableRequest redirectableRequest = new RedirectableRequest(request, 5);\n    redirectableRequest.setConnectTimeout(YahooFinance.CONNECTION_TIMEOUT);\n    redirectableRequest.setReadTimeout(YahooFinance.CONNECTION_TIMEOUT);\n    Map<String, String> requestProperties = new HashMap<String, String>();\n    requestProperties.put(\"Cookie\", CrumbManager.getCookie());\n    URLConnection connection = redirectableRequest.openConnection(requestProperties);\n    InputStreamReader is = new InputStreamReader(connection.getInputStream());\n    BufferedReader br = new BufferedReader(is);\n    // skip the first line\n    br.readLine();\n    // Parse CSV\n    for (String line = br.readLine(); line != null; line = br.readLine()) {",
        "pred_variables": [
            "line"
        ],
        "label_variables": [
            "line"
        ]
    },
    {
        "code": "/**\n * \u9488\u5bf9 redis \u6570\u636e\u5931\u6548\u4e8b\u4ef6\uff0c\u8fdb\u884c\u6570\u636e\u5904\u7406\n *\n * @param message key\n * @param pattern pattern\n */\n@Override\npublic void onMessage(Message message, byte[] pattern) {\n    // \u83b7\u53d6\u5230\u5931\u6548\u7684 key\n    String expiredKey = message.toString();\n    if (expiredKey.contains(JwtConstants.LAST_ONLINE)) {\n        String account = expiredKey.replace(JwtConstants.LAST_ONLINE, \"\");",
        "pred_variables": [
            "account",
            "message"
        ],
        "label_variables": [
            "expiredKey"
        ]
    },
    {
        "code": "/**\n * Run a simple command that should return a single line on stdout\n * @param command\n * @return\n */\n@CheckForNull\nprivate String runSimpleCommand(Command command) {\n    List<String> stdOut = new ArrayList<>();\n    List<String> stdErr = new ArrayList<>();",
        "pred_variables": [
            "command"
        ],
        "label_variables": [
            "command"
        ]
    },
    {
        "code": "// doc comment inherited from LogWriter\npublic void logRequest(Logger log, Object command) {",
        "pred_variables": [
            "command"
        ],
        "label_variables": [
            "command"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"google.storage\")\nToxiproxyContainer.ContainerProxy googleStorageContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(BEAN_NAME_EMBEDDED_GOOGLE_STORAGE_SERVER) GenericContainer<?> storageServer, ConfigurableEnvironment environment) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(storageServer, StorageProperties.PORT);\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.google.storage.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.google.storage.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.google.storage.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedGoogleStorageToxiproxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [
            "propertySource"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "private void checkStaleTerminatedTransaction(MonitoredTransaction transaction, long nowNanos, long terminationTimeoutNanos) {\n    transaction.terminationMark().ifPresent(mark -> {\n        if (mark.isMarkedAsStale()) {\n            return;\n        }\n        final var nanosSinceTermination = nowNanos - mark.getTimestampNanos();\n        if (nanosSinceTermination >= terminationTimeoutNanos) {\n            log.warn(\"Transaction %s has been marked for termination for %d seconds; it may have been leaked. %s\", transaction.getIdentifyingDescription(), TimeUnit.NANOSECONDS.toSeconds(nanosSinceTermination), buildTraceOrHelpMessage(transaction.transactionInitialisationTrace()));\n            mark.markAsStale();\n        }\n    });",
        "pred_variables": [
            "mark",
            "nowNanos",
            "transaction",
            "markAsStale"
        ],
        "label_variables": [
            "nanosSinceTermination"
        ]
    },
    {
        "code": "public CarbonServerConfigurationService getServerConfigurationService() {\n    if (this.serverConfigurationService == null) {\n        String msg = \"Before activating Carbon Core bundle, an instance of \" + \"ServerConfigurationService should be in existance\";",
        "pred_variables": [
            "msg",
            "bundle"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "public void reportTotalDataSize() {\n    double totalDataSizeGB = (double) this.totalDataSize / 1024.0 / 1024.0 / 1024.0;",
        "pred_variables": [
            "double",
            "totalDataSizeGB"
        ],
        "label_variables": [
            "totalDataSizeGB"
        ]
    },
    {
        "code": "@Override\npublic void recoveryCleanupStarted(Path indexFile, IndexDescriptor index) {",
        "pred_variables": [
            "indexFile",
            "index"
        ],
        "label_variables": [
            "indexFile",
            "index"
        ]
    },
    {
        "code": "    if (clazz == null) {\n        if (ClusterManager.isClusteringEnabled()) {\n            Log.debug(\"Clustering is enabled. Falling back to non-cached provider\");\n            clazz = DefaultPubSubPersistenceProvider.class;\n        } else {\n            clazz = CachingPubsubPersistenceProvider.class;\n        }\n    }\n    // Check if we need to reset the provider class\n    if (provider == null || !clazz.equals(provider.getClass())) {\n        if (provider != null) {\n            provider.shutdown();\n            provider = null;\n        }\n        try {",
        "pred_variables": [
            "provider"
        ],
        "label_variables": [
            "clazz"
        ]
    },
    {
        "code": "@Test(timeout = 60000)\npublic void tesIndividualAcksWithClosedConsumerAndAuditSync() throws Exception {\n    produceSomeMessages(MSG_COUNT);\n    QueueViewMBean queueView = getProxyToQueue(getDestinationName());\n    assertEquals(MSG_COUNT, queueView.getQueueSize());\n    connection = createConnection();\n    Session session = connection.createSession(false, ActiveMQSession.INDIVIDUAL_ACKNOWLEDGE);\n    Queue queue = session.createQueue(getDestinationName());\n    MessageConsumer consumer = session.createConsumer(queue);\n    connection.start();\n    // Consume all messages with no ACK\n    for (int i = 0; i < MSG_COUNT; ++i) {\n        Message message = consumer.receive(1000);\n        assertNotNull(message);",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "public void update(String projectKey, UnaryOperator<AnalyzerConfiguration> updater) {\n    var projectFilePath = getAnalyzerConfigFilePath(projectKey);\n    FileUtils.mkdirs(projectFilePath.getParent());\n    rwLock.write(() -> {\n        Sonarlint.AnalyzerConfiguration config;\n        try {\n            config = readConfiguration(projectFilePath);\n        } catch (StorageException e) {\n            LOG.warn(\"Unable to read storage. Creating a new one.\", e);\n            config = Sonarlint.AnalyzerConfiguration.newBuilder().build();\n        }\n        writeToFile(adapt(updater.apply(adapt(config))), projectFilePath);",
        "pred_variables": [
            "FileUtils",
            "getAnalyzerConfigFilePath",
            "projectFilePath"
        ],
        "label_variables": [
            "projectFilePath"
        ]
    },
    {
        "code": "@Override\npublic void doParse(InputStream in, String baseUri, RDFNotation notation, boolean keepBNode, RDFCallback callback) throws ParserException {\n    try {\n        // create a temp\n        Path tempFile = Files.createTempFile(\"hdtjava-reader\", \".hdt\");",
        "pred_variables": [
            "hdtjava"
        ],
        "label_variables": [
            "tempFile"
        ]
    },
    {
        "code": "private void getOffices() throws AxisFault, XPathExpressionException {\n    OMElement payload = fac.createOMElement(\"listOffices\", omNs);\n    OMElement result = new AxisServiceClient().sendReceive(payload, getServiceUrlHttp(serviceName), \"listOffices\");\n    Assert.assertNotNull(result, \"Response message null \");",
        "pred_variables": [
            "result"
        ],
        "label_variables": [
            "result"
        ]
    },
    {
        "code": "    if (StringUtils.isEmpty(alias)) {\n        aliasId.requestFocus();\n        DailogUtil.showTipDailogCenter(\"\u522b\u540d\u4e0d\u80fd\u4e3a\u7a7a\", getThisStage());\n        return;\n    }\n    //\u4fee\u6539\u5bc6\u7801\u5e76\u5224\u65ad\u7ed3\u679c\n    AccountKit accountKit = InchainInstance.getInstance().getAccountKit();\n    Result result = accountKit.updateAlias(alias);\n    if (result.isSuccess()) {\n        DailogUtil.showTipDailogCenter(result.getMessage(), getThisStage());\n        resetAndclose();\n        if (callback != null) {\n            callback.ok(null);\n        }\n    } else {",
        "pred_variables": [
            "aliasId",
            "alias",
            "\u522b\u540d\u4e0d\u80fd\u4e3a\u7a7a",
            "getThisStage",
            "accountKit",
            "result",
            "Result"
        ],
        "label_variables": [
            "result"
        ]
    },
    {
        "code": "@Override\npublic Response toResponse(Exception e) {\n    if (e instanceof WebApplicationException) {\n        return ((WebApplicationException) e).getResponse();\n    }",
        "pred_variables": [
            "e"
        ],
        "label_variables": [
            "e"
        ]
    },
    {
        "code": "public void detect(@Nullable Path configuredNodejsPath) {\n    detectedNodePath = locateNode(configuredNodejsPath);\n    if (detectedNodePath != null) {\n        LOG.debug(\"Checking node version...\");\n        var command = Command.create(detectedNodePath.toString()).addArgument(\"-v\");\n        var nodeVersionStr = runSimpleCommand(command);\n        if (nodeVersionStr != null) {\n            var matcher = NODEJS_VERSION_PATTERN.matcher(nodeVersionStr);\n            if (matcher.matches()) {\n                var version = matcher.group(1);\n                nodeJsVersion = Version.create(version);\n                LOG.debug(\"Detected node version: {}\", nodeJsVersion);\n            } else {",
        "pred_variables": [
            "group",
            "command",
            "var",
            "version"
        ],
        "label_variables": [
            "nodeVersionStr"
        ]
    },
    {
        "code": "protected boolean isReady() {\n    String commandName = getContainerType();\n    String containerId = waitStrategyTarget.getContainerId();\n    String[] checkCommand = getCheckCommand();",
        "pred_variables": [
            "getCheckCommand",
            "String",
            "commandName",
            "waitStrategyTarget"
        ],
        "label_variables": [
            "commandName",
            "checkCommand",
            "containerId"
        ]
    },
    {
        "code": "private Object doEvaluate(final String expression) throws Exception {\n    assert expression != null;",
        "pred_variables": [
            "expression"
        ],
        "label_variables": [
            "expression"
        ]
    },
    {
        "code": "@Override\npublic User mapUser(OAuth2UserRequest userRequest, OAuth2User oAuth2User) {\n    if (log.isDebugEnabled()) {",
        "pred_variables": [
            "oAuth2User"
        ],
        "label_variables": [
            "oAuth2User"
        ]
    },
    {
        "code": "@Nullable\npublic static SecurityPlan forPlan(@Nonnull final String apiId, @Nonnull Plan plan, @Nonnull PolicyManager policyManager, @Nonnull ExecutionPhase executionPhase) {\n    final SecurityPolicy policy = SecurityPolicyFactory.forPlan(apiId, plan, policyManager, executionPhase);\n    if (policy != null) {\n        return new SecurityPlan(plan.getId(), policy, plan.getSelectionRule());\n    }",
        "pred_variables": [
            "plan",
            "executionPhase",
            "Nonnull"
        ],
        "label_variables": [
            "apiId"
        ]
    },
    {
        "code": "private void registerNeo4jEnvironment(Neo4jContainer neo4j, ConfigurableEnvironment environment, Neo4jProperties properties) {\n    Integer httpsPort = neo4j.getMappedPort(properties.httpsPort);\n    Integer httpPort = neo4j.getMappedPort(properties.httpPort);\n    Integer boltPort = neo4j.getMappedPort(properties.boltPort);\n    String host = neo4j.getHost();\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.neo4j.httpsPort\", httpsPort);\n    map.put(\"embedded.neo4j.httpPort\", httpPort);\n    map.put(\"embedded.neo4j.boltPort\", boltPort);\n    map.put(\"embedded.neo4j.host\", host);\n    map.put(\"embedded.neo4j.password\", properties.getPassword());\n    map.put(\"embedded.neo4j.user\", properties.getUser());",
        "pred_variables": [
            "neo4j",
            "properties",
            "httpsPort"
        ],
        "label_variables": [
            "httpPort",
            "map"
        ]
    },
    {
        "code": "public static SecurityPolicy forPlan(final String apiId, final Plan plan, final PolicyManager policyManager, final ExecutionPhase executionPhase) {\n    PlanSecurity planSecurity = plan.getSecurity();\n    final String security = planSecurity.getType();\n    if (security == null) {\n        return null;\n    }\n    String policyName = security.toLowerCase().replaceAll(\"_\", \"-\");\n    final Policy policy = policyManager.create(executionPhase, new PolicyMetadata(policyName, planSecurity.getConfiguration()));\n    if (policy instanceof SecurityPolicy) {\n        return (SecurityPolicy) policy;\n    }",
        "pred_variables": [
            "plan",
            "executionPhase",
            "planSecurity"
        ],
        "label_variables": [
            "policyName",
            "apiId"
        ]
    },
    {
        "code": "private void addEmployeeBatchRequest() throws AxisFault, XPathExpressionException {\n    OMElement payload = fac.createOMElement(\"addEmployee_batch_req\", omNs);\n    for (int i = 10; i < 36; i++) {\n        OMElement batchRequest = fac.createOMElement(\"addEmployee\", omNs);\n        OMElement empNo = fac.createOMElement(\"employeeNumber\", omNs);\n        empNo.setText(i + \"\");\n        batchRequest.addChild(empNo);\n        OMElement email = fac.createOMElement(\"email\", omNs);\n        email.setText(\"testemail@wso2.com\");\n        batchRequest.addChild(email);\n        payload.addChild(batchRequest);\n    }\n    if (log.isDebugEnabled()) {",
        "pred_variables": [
            "i",
            "empNo",
            "fac",
            "omNs"
        ],
        "label_variables": [
            "payload"
        ]
    },
    {
        "code": "private InterruptedIOException dealWithInterrupt(InterruptedException e) {\n    if (LOG.isDebugEnabled()) {",
        "pred_variables": [
            "e"
        ],
        "label_variables": [
            "e"
        ]
    },
    {
        "code": "public static String getSessionId() {\n    //random int from 1 - 100000\n    int part1 = rnd.nextInt(99999) + 1;\n    //thread-safe \"long\" part\n    long part2 = ThreadLocalRandom.current().nextLong();\n    //current time in millis\n    long part3 = System.currentTimeMillis();\n    //generate uuid-type id\n    String sessionId = createHash(part1 + \"-\" + part2 + \"-\" + part3);",
        "pred_variables": [
            "part3",
            "part1",
            "from",
            "type"
        ],
        "label_variables": [
            "sessionId"
        ]
    },
    {
        "code": "private Stream<Settings> tryLoad(Path path) {",
        "pred_variables": [
            "path"
        ],
        "label_variables": [
            "path"
        ]
    },
    {
        "code": "        case \"COUNTRY\":\n            mapKey = MAP_TYPES.get(\"country\") + \":\" + key;\n            break;\n        case \"PUBLISHING_COUNTRY\":\n            mapKey = MAP_TYPES.get(\"publishingCountry\") + \":\" + key;\n            break;\n        default:\n            mapKey = ALL_MAP_KEY;\n    }\n    Capabilities.CapabilitiesBuilder builder = Capabilities.CapabilitiesBuilder.newBuilder();\n    DatedVectorTile west = tileResource.getTile(0, 0, 0, mapKey, null, \"EPSG:4326\", null, null, true, null, 0, 0);\n    DatedVectorTile east = tileResource.getTile(0, 1, 0, mapKey, null, \"EPSG:4326\", null, null, true, null, 0, 0);\n    builder.collect(west.tile, ZOOM_0_WEST_NW, ZOOM_0_WEST_SE, west.date);\n    builder.collect(east.tile, ZOOM_0_EAST_NW, ZOOM_0_EAST_SE, east.date);\n    Capabilities capabilities = builder.build();",
        "pred_variables": [
            "capabilities",
            "builder"
        ],
        "label_variables": [
            "capabilities"
        ]
    },
    {
        "code": "void exercise(WebDriver driver, String sutUrl, String expectedTitleContains) throws Exception {\n    driver.get(sutUrl);\n    Wait<WebDriver> wait = new WebDriverWait(driver, Duration.ofSeconds(30));\n    wait.until(d -> d.getTitle().contains(expectedTitleContains));\n    URL dockerSessionUrl = wdm.getDockerNoVncUrl(driver);",
        "pred_variables": [
            "wdm",
            "expectedTitleContains"
        ],
        "label_variables": [
            "dockerSessionUrl"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"minio\")\nToxiproxyContainer.ContainerProxy minioContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(MINIO_BEAN_NAME) GenericContainer<?> minio, ConfigurableEnvironment environment, MinioProperties properties) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(minio, properties.getPort());\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.minio.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.minio.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.minio.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedMinioToxiproxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "@Override\npublic void onWebSocketClose(int arg0, String arg1) {\n    try {\n        if (protocolLock.tryLock() || protocolLock.tryLock(ORDERLY_CLOSE_TIMEOUT, TimeUnit.SECONDS)) {",
        "pred_variables": [
            "arg0",
            "arg1"
        ],
        "label_variables": [
            "arg1",
            "arg0"
        ]
    },
    {
        "code": "private void registerEnvironment(ToxiproxyContainer container, ConfigurableEnvironment environment) {\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.toxiproxy.host\", container.getHost());\n    map.put(\"embedded.toxiproxy.controlPort\", container.getControlPort());",
        "pred_variables": [],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "@Override\npublic void visitUnsignedInteger(String name, long id, long value) {",
        "pred_variables": [
            "id",
            "name"
        ],
        "label_variables": [
            "name",
            "value"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"redis\")\nToxiproxyContainer.ContainerProxy redisContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(BEAN_NAME_EMBEDDED_REDIS) GenericContainer<?> redis, RedisProperties properties, ConfigurableEnvironment environment) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(redis, properties.getPort());\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.redis.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.redis.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.redis.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedRedisToxiProxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "            Filter sectorIdentifierFilter = Filter.createEqualityFilter(\"oxSectorIdentifier\", sectorIdentifier);\n            Filter userInumFilter = Filter.createEqualityFilter(\"oxAuthUserId\", userInum);\n            filter = Filter.createANDFilter(sectorIdentifierFilter, userInumFilter);\n        } else {\n            Filter sectorIdentifierFilter = Filter.createEqualityFilter(\"oxSectorIdentifier\", sectorIdentifier);\n            Filter clientIdFilter = Filter.createEqualityFilter(\"oxAuthClientId\", clientId);\n            Filter userInumFilter = Filter.createEqualityFilter(\"oxAuthUserId\", userInum);\n            filter = Filter.createANDFilter(sectorIdentifierFilter, clientIdFilter, userInumFilter);\n        }\n        List<PairwiseIdentifier> entries = ldapEntryManager.findEntries(baseDnForPairwiseIdentifiers, PairwiseIdentifier.class, filter);\n        if (entries != null && !entries.isEmpty()) {\n            // if more then one entry then it's problem, non-deterministic behavior, id must be unique\n            if (entries.size() > 1) {\n                log.error(\"Found more then one pairwise identifier by sector identifier: {}\" + sectorIdentifier);\n                for (PairwiseIdentifier pairwiseIdentifier : entries) {",
        "pred_variables": [
            "createEqualityFilter"
        ],
        "label_variables": [
            "pairwiseIdentifier"
        ]
    },
    {
        "code": "protected void doExecute() throws Exception {\n    ServerProxy server = new ServerProxy(hostname, port, username, password);\n    //\n    // TODO: Maybe we just need isStarted() not need to be fully started?\n    //\n    if (!server.isFullyStarted()) {\n        String msg = \"Server does not appear to be started\";\n        if (failIfNotStarted) {\n            throw new MojoExecutionException(msg);\n        } else {",
        "pred_variables": [
            "username",
            "server"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "private static void executeSensor(SensorContext context, Sensor sensor, DefaultSensorDescriptor descriptor) {\n    var sensorName = descriptor.name() != null ? descriptor.name() : describe(sensor);",
        "pred_variables": [
            "sensor",
            "name"
        ],
        "label_variables": [
            "sensorName"
        ]
    },
    {
        "code": " * @throws ServletException\n */\n@SuppressWarnings(\"deprecation\")\n@Override\npublic void start() throws ServletException {\n    log.info(\"Loading RTMPT context\");\n    rtmptEngine = new StandardEngine();\n    rtmptEngine.setName(\"red5RTMPTEngine\");\n    rtmptEngine.setDefaultHost(host.getName());\n    rtmptEngine.setRealm(embedded.getEngine().getRealm());\n    Service service = new StandardService();\n    service.setName(\"red5RTMPTEngine\");\n    service.setContainer(rtmptEngine);\n    // add the valves to the host\n    for (Valve valve : valves) {",
        "pred_variables": [
            "service"
        ],
        "label_variables": [
            "valve"
        ]
    },
    {
        "code": "private void handleException(String msg, Exception ex) {",
        "pred_variables": [
            "msg",
            "ex"
        ],
        "label_variables": [
            "msg",
            "ex"
        ]
    },
    {
        "code": "@Override\npublic void doParse(String rarFile, String baseUri, RDFNotation notation, boolean keepBNode, RDFCallback callback) throws ParserException {\n    try {\n        String[] cmdList1 = Arrays.copyOf(cmdList, cmdList.length);\n        cmdList1[2] = rarFile;\n        ProcessBuilder listProcessBuilder = new ProcessBuilder(cmdList1);\n        //\t\t\tlistProcess.redirectInput(tempFile);\n        Process processList = listProcessBuilder.start();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(processList.getInputStream(), UTF_8));\n        String[] cmdExtract = Arrays.copyOf(cmdExtractFile, cmdExtractFile.length);\n        cmdExtract[3] = rarFile;\n        String fileName;\n        // Read file name from list\n        while ((fileName = reader.readLine()) != null) {\n            // FIXME: Create several processes in background?",
        "pred_variables": [
            "baseUri",
            "rarFile",
            "fileName",
            "background"
        ],
        "label_variables": [
            "fileName"
        ]
    },
    {
        "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic ITagReader getReader() throws IOException {\n    MP4Reader reader = null;\n    IoBuffer fileData = null;\n    String fileName = file.getName();\n    if (file.exists()) {",
        "pred_variables": [
            "file"
        ],
        "label_variables": [
            "fileName"
        ]
    },
    {
        "code": "private static List<PatternHolder> extractAllowedTypes(JsonObject constraintObj) {\n    List<PatternHolder> allowedTypes = new ArrayList<>();\n    JsonArray allowedTypesArray = constraintObj.getJsonArray(ALLOWED_TYPES);\n    if (allowedTypesArray == null) {\n        log.warn(\"No '{}' array found in configuration\", ALLOWED_TYPES);\n        return allowedTypes;\n    }\n    for (Object allowedType : allowedTypesArray) {\n        String allowedTypeStr = (String) allowedType;\n        if (StringUtils.isNotEmptyTrimmed(allowedTypeStr)) {\n            try {\n                allowedTypes.add(new PatternHolder(Pattern.compile(allowedTypeStr).pattern()));\n            } catch (PatternSyntaxException patternException) {",
        "pred_variables": [
            "allowedType",
            "JsonObject",
            "allowedTypeStr"
        ],
        "label_variables": [
            "allowedTypeStr"
        ]
    },
    {
        "code": "protected String encodeResponse(Element response) throws IOException {\n    String responseMessage = DOM2Writer.nodeToString(response);",
        "pred_variables": [
            "DOM2Writer"
        ],
        "label_variables": [
            "responseMessage"
        ]
    },
    {
        "code": "@Override\npublic MessageProcessResult process(Message message, Peer peer) {\n    if (log.isDebugEnabled()) {",
        "pred_variables": [
            "message",
            "peer"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "private void logClusterInfo() {\n    try (Jedis jedis = createJedis()) {\n        String clusterInfo = jedis.clusterInfo();\n        String info = jedis.info();\n        List<String> config = jedis.configGet(\"*\");\n        String clusterNodes = jedis.clusterNodes();",
        "pred_variables": [
            "clusterInfo",
            "String",
            "jedis"
        ],
        "label_variables": [
            "clusterNodes",
            "clusterInfo",
            "config",
            "info"
        ]
    },
    {
        "code": "        }\n    }\n    Wait.waitFor(new Wait.Condition() {\n\n        @Override\n        public boolean isSatisified() throws Exception {\n            return received.get() == numIterations;\n        }\n    });\n    consumer.close();\n    connection.close();\n    RegionBroker regionBroker = (RegionBroker) broker.getRegionBroker();\n    Queue queue = (Queue) regionBroker.getQueueRegion().getDestinationMap().get(destination);\n    StoreQueueCursor storeQueueCursor = (StoreQueueCursor) queue.getMessages();\n    PendingMessageCursor queueStorePrefetch = storeQueueCursor.getPersistent();",
        "pred_variables": [
            "queueStorePrefetch"
        ],
        "label_variables": [
            "queueStorePrefetch"
        ]
    },
    {
        "code": "protected void echo(String text) {",
        "pred_variables": [
            "text"
        ],
        "label_variables": [
            "text"
        ]
    },
    {
        "code": "public void handleEvent(Event event) {\n    try {\n        boolean minified = htmlLibraryManager.isMinifyEnabled();\n        String path = (String) event.getProperty(SlingConstants.PROPERTY_PATH);",
        "pred_variables": [],
        "label_variables": [
            "path"
        ]
    },
    {
        "code": "@Override\npublic void onSharedObjectUpdate(ISharedObjectBase so, Map<String, Object> values) {",
        "pred_variables": [
            "String",
            "so"
        ],
        "label_variables": [
            "values"
        ]
    },
    {
        "code": "private boolean validateSignoutEndpointAddress(Application serviceConfig, String endpointAddress) {\n    if (serviceConfig.getLogoutEndpoint() == null && serviceConfig.getCompiledLogoutEndpointConstraint() == null) {\n        LOG.error(\"Either the 'logoutEndpoint' or the 'logoutEndpointConstraint' \" + \"configuration values must be specified for the application\");\n    } else if (serviceConfig.getLogoutEndpoint() != null && serviceConfig.getLogoutEndpoint().equals(endpointAddress)) {",
        "pred_variables": [
            "endpointAddress",
            "serviceConfig"
        ],
        "label_variables": [
            "endpointAddress"
        ]
    },
    {
        "code": "private void prepareContainerConfiguration(GenericContainer<?> container) throws IOException {\n    String containerEndpoint = buildContainerEndpoint(container);",
        "pred_variables": [
            "containerEndpoint"
        ],
        "label_variables": [
            "containerEndpoint"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"vertica\")\nToxiproxyContainer.ContainerProxy verticaContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(BEAN_NAME_EMBEDDED_VERTICA) GenericContainer<?> embeddedVertica, ConfigurableEnvironment environment, VerticaProperties verticaProperties) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(embeddedVertica, verticaProperties.getPort());\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.vertica.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.vertica.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.vertica.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedVerticaToxiproxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [
            "propertySource",
            "ToxiproxyContainer"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "@Test(groups = \"wso2.esb\", description = \"Test return of the current time in milliseconds\")\npublic void testSystemTime() throws Exception {\n    OMElement response = axis2Client.sendSimpleStockQuoteRequest(getProxyServiceURLHttp(\"SYSTEM_TIME_TestProxy\"), null, \"Wso2\");\n    assertNotNull(response, \"Time returned is Null\");\n    DateFormat dateFormat = new SimpleDateFormat(\"HH:mm\");\n    Date date = new Date();",
        "pred_variables": [
            "HH"
        ],
        "label_variables": [
            "date"
        ]
    },
    {
        "code": "@Test\npublic void testFLVReaderFileGenerateMetaData() {\n    log.info(\"\\n testFLVReaderFileGenerateMetaData\");\n    String[] paths = new String[] { \"target/test-classes/fixtures/stray.flv\" };\n    try {\n        for (String path : paths) {\n            File file = Paths.get(path).toFile();\n            if (file.exists() && file.canRead()) {\n                log.info(\"Reading: {}\", file.getName());\n                FLVReader reader = new FLVReader(file, true);\n                ITag tag = null;\n                while (reader.hasMoreTags()) {\n                    tag = reader.readTag();\n                    if (tag != null && tag.getDataType() > 9) {",
        "pred_variables": [
            "tag"
        ],
        "label_variables": [
            "tag"
        ]
    },
    {
        "code": "public static void logResolved() {\n    int deferred = deferredCounter.get();\n    int resolved = resolvedCounter.get();",
        "pred_variables": [
            "resolvedCounter",
            "deferred"
        ],
        "label_variables": [
            "deferred",
            "resolved"
        ]
    },
    {
        "code": "@Override\npublic void resultReceived(IPendingServiceCall call) {\n    log.info(\"connectCallback\");\n    ObjectMap<?, ?> map = (ObjectMap<?, ?>) call.getResult();\n    String code = (String) map.get(\"code\");",
        "pred_variables": [
            "call",
            "code"
        ],
        "label_variables": [
            "code"
        ]
    },
    {
        "code": "@Override\npublic void handle(final RoutingContext ctx) {\n    final LoggingHandler loggingHandler = new LoggingHandler(loggingResourceManager, ctx.request(), this.eventBus);\n    final String targetUri = urlPattern.matcher(ctx.request().uri()).replaceAll(rule.getPath()).replaceAll(\"\\\\/\\\\/\", \"/\");\n    final Logger log = RequestLoggerFactory.getLogger(StorageForwarder.class, ctx.request());\n    if (handleHeadersFilter(ctx.request())) {\n        return;\n    }\n    monitoringHandler.updateRequestsMeter(\"localhost\", ctx.request().uri());\n    monitoringHandler.updateRequestPerRuleMonitoring(ctx.request(), rule.getMetricName());\n    final long startTime = monitoringHandler.startRequestMetricTracking(rule.getMetricName(), ctx.request().uri());",
        "pred_variables": [
            "rule"
        ],
        "label_variables": [
            "targetUri"
        ]
    },
    {
        "code": "@Override\npublic void storeXDeltaResponseHeader(String xDeltaResponseNumber) {\n    if (log.isTraceEnabled()) {",
        "pred_variables": [
            "xDeltaResponseNumber"
        ],
        "label_variables": [
            "xDeltaResponseNumber"
        ]
    },
    {
        "code": "public void processSchemaQueue() {\n    PendingChanged.logResolved();\n    while (!processingQueue.isEmpty()) {\n        CacheKey key = processingQueue.poll();\n        if (key != null) {",
        "pred_variables": [
            "key"
        ],
        "label_variables": [
            "key"
        ]
    },
    {
        "code": "/**\n * Get the time zone for a specific exchange suffix\n *\n * @param suffix suffix for the exchange in YahooFinance\n * @return time zone of the exchange\n */\npublic static TimeZone get(String suffix) {\n    if (SUFFIX_TIMEZONES.containsKey(suffix)) {\n        return SUFFIX_TIMEZONES.get(suffix);\n    }",
        "pred_variables": [
            "suffix"
        ],
        "label_variables": [
            "suffix"
        ]
    },
    {
        "code": "public void warning(SAXParseException exception) {",
        "pred_variables": [
            "exception"
        ],
        "label_variables": [
            "exception"
        ]
    },
    {
        "code": "        passwordId.requestFocus();\n        DailogUtil.showTipDailogCenter(\"\u8f93\u5165\u7684\u5bc6\u7801\u97006\u4f4d\u6216\u4ee5\u4e0a\uff0c\u4e14\u5305\u542b\u5b57\u6bcd\u548c\u6570\u5b57\", getThisStage());\n        return;\n    }\n    RadioButton radioButton = (RadioButton) type.getSelectedToggle();\n    String type = radioButton.getId();\n    //\u4fee\u6539\u5bc6\u7801\u5e76\u5224\u65ad\u7ed3\u679c\n    AccountKit accountKit = InchainInstance.getInstance().getAccountKit();\n    Result result = accountKit.changeWalletPassword(oldPassword, password, null, \"mgpwd\".equals(type) ? 1 : 2);\n    if (result.isSuccess()) {\n        oldPasswordId.setText(\"\");\n        passwordId.setText(\"\");\n        repeatId.setText(\"\");\n        DailogUtil.showTipDailogCenter(result.getMessage(), getThisStage());\n    } else {",
        "pred_variables": [
            "\u4fee\u6539\u5bc6\u7801\u5e76\u5224\u65ad\u7ed3\u679c",
            "AccountKit",
            "type"
        ],
        "label_variables": [
            "result"
        ]
    },
    {
        "code": "@ParameterizedTest\n@MethodSource(\"cacheProvider\")\nvoid testCache(DriverManagerType driverManagerType, String driverName, String driverVersion, Architecture arch, OperatingSystem os) throws Exception {\n    WebDriverManager wdm = WebDriverManager.getInstance(driverManagerType).avoidResolutionCache().forceDownload().operatingSystem(os).driverVersion(driverVersion);\n    wdm.setup();\n    CacheHandler cacheHandler = new CacheHandler(new Config());\n    Optional<String> driverFromCache = cacheHandler.getDriverFromCache(driverVersion, driverName, driverManagerType, arch, os.name());",
        "pred_variables": [],
        "label_variables": [
            "driverFromCache"
        ]
    },
    {
        "code": "private Void failure(Throwable t) {\n    stats.recordProducerFailure();",
        "pred_variables": [
            "t"
        ],
        "label_variables": [
            "t"
        ]
    },
    {
        "code": "private void registerMemSqlEnvironment(GenericContainer<?> memsql, ConfigurableEnvironment environment, MemSqlProperties properties) {\n    Integer mappedPort = memsql.getMappedPort(properties.port);\n    String host = memsql.getHost();\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.memsql.port\", mappedPort);\n    map.put(\"embedded.memsql.host\", host);\n    map.put(\"embedded.memsql.schema\", properties.getDatabase());\n    map.put(\"embedded.memsql.user\", properties.getUser());\n    map.put(\"embedded.memsql.password\", properties.getPassword());",
        "pred_variables": [
            "host",
            "memsql",
            "properties",
            "mappedPort",
            "getHost",
            "port"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "@Override\npublic void contextDestroyed(ServletContextEvent sce) {",
        "pred_variables": [
            "sce"
        ],
        "label_variables": [
            "sce"
        ]
    },
    {
        "code": "@Override\npublic BroadcastResult broadcast(final T message) {\n    //\u5e7f\u64ad\u7ed3\u679c\n    final BroadcastResult result = new BroadcastResult();\n    int minConnections = peerKit.getBroadcasterMinConnectionCount();\n    if (log.isDebugEnabled()) {",
        "pred_variables": [
            "peerKit",
            "message",
            "minConnections"
        ],
        "label_variables": [
            "minConnections"
        ]
    },
    {
        "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic boolean addData(IoBuffer data) {\n    if (data.hasRemaining()) {\n        // mark\n        int start = data.position();\n        // ensure we are at the beginning\n        data.rewind();\n        byte frameType = data.get();",
        "pred_variables": [
            "data",
            "frameType",
            "mark"
        ],
        "label_variables": [
            "frameType"
        ]
    },
    {
        "code": "@Override\npublic void exec(int executionCounter) {\n    List<String> args = RedisUtils.toPayload(luaScriptState.getSha(), keys.size(), keys, arguments);\n    redisAPI.evalsha(args, event -> {\n        if (event.succeeded()) {\n            String value = event.result().toString();\n            if (log.isTraceEnabled()) {\n                log.trace(\"UpdateStatsRedisCommand lua script got result: \" + value);\n            }\n            promise.complete(UpdateStatisticsResult.fromString(value, UpdateStatisticsResult.ERROR));\n        } else {\n            String message = event.cause().getMessage();\n            if (message != null && message.startsWith(\"NOSCRIPT\")) {\n                log.warn(\"UpdateStatsRedisCommand script couldn't be found, reload it\");",
        "pred_variables": [],
        "label_variables": [
            "executionCounter"
        ]
    },
    {
        "code": "public static String runAndWaitArray(boolean logCommand, File folder, String[] command) {\n    String commandStr = Arrays.toString(command);\n    if (logCommand) {",
        "pred_variables": [
            "command",
            "logCommand"
        ],
        "label_variables": [
            "commandStr"
        ]
    },
    {
        "code": "/**\n * Encode notification event and fill given byte buffer.\n *\n * @param out\n *            Byte buffer to fill\n * @param command\n *            Notification event\n */\n@Override\nprotected void encodeCommand(IoBuffer out, ICommand command) {",
        "pred_variables": [
            "event",
            "command",
            "out",
            "buffer"
        ],
        "label_variables": [
            "command"
        ]
    },
    {
        "code": "private void checkArm(WebDriverManager wdm) {\n    wdm.driverVersion(\"0.29.1\").mac().arch64().setup();\n    String driverPath = wdm.getDownloadedDriverPath();",
        "pred_variables": [
            "setup",
            "wdm"
        ],
        "label_variables": [
            "driverPath"
        ]
    },
    {
        "code": "public ClientAuthorization find(String userInum, String clientId) {\n    prepareBranch();\n    final String id = createId(userInum, clientId);\n    try {\n        if (appConfiguration.getClientAuthorizationBackwardCompatibility()) {\n            return findToRemoveIn50(userInum, clientId);\n        }\n        return ldapEntryManager.find(ClientAuthorization.class, createDn(createId(userInum, clientId)));\n    } catch (EntryPersistenceException e) {",
        "pred_variables": [
            "clientId"
        ],
        "label_variables": [
            "id"
        ]
    },
    {
        "code": "@Override\npublic List<Flow> findByReference(final FlowReferenceType flowReferenceType, final String referenceId) {\n    try {",
        "pred_variables": [
            "flowReferenceType",
            "referenceId"
        ],
        "label_variables": [
            "flowReferenceType"
        ]
    },
    {
        "code": "static void prepareParentNoMountPoint(Path mountPoint) throws MountPointPreparationException {\n    Path hideaway = getHideaway(mountPoint);\n    var mpExists = Files.exists(mountPoint, LinkOption.NOFOLLOW_LINKS);\n    var hideExists = Files.exists(hideaway, LinkOption.NOFOLLOW_LINKS);\n    //TODO: possible improvement by just deleting an _empty_ hideaway\n    if (mpExists && hideExists) {\n        //both resources exist (whatever type)\n        throw new MountPointPreparationException(new FileAlreadyExistsException(hideaway.toString()));\n    } else if (!mpExists && !hideExists) {\n        //neither mountpoint nor hideaway exist\n        throw new MountPointPreparationException(new NoSuchFileException(mountPoint.toString()));\n    } else if (!mpExists) {\n        //only hideaway exists\n        checkIsDirectory(hideaway);",
        "pred_variables": [
            "mountPoint",
            "Files",
            "var"
        ],
        "label_variables": [
            "mountPoint"
        ]
    },
    {
        "code": "@Override\npublic void onException(JMSException exception) {",
        "pred_variables": [
            "exception"
        ],
        "label_variables": [
            "exception"
        ]
    },
    {
        "code": "public static Container.ExecResult executeAndCheckExitCode(ContainerState container, String... command) {\n    try {\n        Container.ExecResult execResult = container.execInContainer(command);",
        "pred_variables": [
            "execResult"
        ],
        "label_variables": [
            "execResult"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"localstack\")\nToxiproxyContainer.ContainerProxy localstackContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(BEAN_NAME_EMBEDDED_LOCALSTACK) LocalStackContainer localStack, LocalStackProperties properties, ConfigurableEnvironment environment) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(localStack, properties.getEdgePort());\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.localstack.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.localstack.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.localstack.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedLocalstackToxiproxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "        return;\n    } else if (!validPassword(password)) {\n        passwordId.requestFocus();\n        DailogUtil.showTipDailogCenter(\"\u8f93\u5165\u7684\u5bc6\u7801\u97006\u4f4d\u6216\u4ee5\u4e0a\uff0c\u4e14\u5305\u542b\u5b57\u6bcd\u548c\u6570\u5b57\", getThisStage());\n        return;\n    }\n    //\u4fee\u6539\u5bc6\u7801\u5e76\u5224\u65ad\u7ed3\u679c\n    AccountKit accountKit = InchainInstance.getInstance().getAccountKit();\n    Result result = accountKit.changeWalletPassword(oldPassword, password);\n    if (result.isSuccess()) {\n        oldPasswordId.setText(\"\");\n        passwordId.setText(\"\");\n        repeatId.setText(\"\");\n        DailogUtil.showTipDailogCenter(result.getMessage(), getThisStage());\n    } else {",
        "pred_variables": [],
        "label_variables": [
            "result"
        ]
    },
    {
        "code": "@Produces({ \"application/json\" })\npublic Response getConfiguration() {\n    try {\n        if (appConfiguration.getDisableU2fEndpoint()) {\n            return Response.status(Status.FORBIDDEN).build();\n        }\n        final String baseEndpointUri = appConfiguration.getBaseEndpoint();\n        final U2fConfiguration conf = new U2fConfiguration();\n        conf.setVersion(\"2.1\");\n        conf.setIssuer(appConfiguration.getIssuer());\n        conf.setRegistrationEndpoint(baseEndpointUri + \"/fido/u2f/registration\");\n        conf.setAuthenticationEndpoint(baseEndpointUri + \"/fido/u2f/authentication\");\n        // convert manually to avoid possible conflicts between resteasy\n        // providers, e.g. jettison, jackson\n        final String entity = ServerUtil.asPrettyJson(conf);",
        "pred_variables": [
            "entity"
        ],
        "label_variables": [
            "entity"
        ]
    },
    {
        "code": "Optional<URL> buildUrl(String driverVersion, Config config) {\n    Optional<URL> optionalUrl = empty();\n    if (!config.isUseMirror()) {\n        String downloadUrlPattern = config.getChromeDownloadUrlPattern();\n        OperatingSystem os = config.getOperatingSystem();\n        Architecture arch = config.getArchitecture();\n        String archLabel = os.isWin() ? \"32\" : \"64\";\n        String builtUrl = os.isMac() && ARM64.equals(arch) ? String.format(downloadUrlPattern, driverVersion, os.getName(), String.format(\"_arm%s\", archLabel)) : String.format(downloadUrlPattern, driverVersion, os.getName(), archLabel);",
        "pred_variables": [
            "arch"
        ],
        "label_variables": [
            "builtUrl"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"azurite\")\nToxiproxyContainer.ContainerProxy azuriteTableContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(AZURITE_BEAN_NAME) GenericContainer<?> azurite, AzuriteProperties properties, ConfigurableEnvironment environment) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(azurite, properties.getTableStoragePort());\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.azurite.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.azurite.toxiproxy.tableStoragePort\", proxy.getProxyPort());\n    map.put(\"embedded.azurite.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedAzuriteTableToxiproxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [
            "module"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "public Topic createTopic(String topicName) {\n    ProjectTopicName topic = ProjectTopicName.of(projectId, topicName);\n    try {",
        "pred_variables": [
            "topic",
            "topicName"
        ],
        "label_variables": [
            "topic"
        ]
    },
    {
        "code": "@Override\npublic Future<Void> removeQueueRequest(String queue) {\n    Promise<Void> promise = Promise.promise();\n    if (StringUtils.isEmpty(queue)) {\n        promise.fail(\"Queue is not allowed to be empty\");\n        return promise.future();\n    }\n    redisAPI.hdel(Arrays.asList(QUEUE_REQUESTS, queue), reply -> {\n        if (reply.failed()) {\n            String message = \"Failed to remove request for queue '\" + queue + \"'. Cause: \" + logCause(reply);",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "public boolean isValidEnrollmentCode(String userName, String enrollmentCode) {\n    if (enrollmentCode == null) {\n        log.error(\"In two step authentication workflow enrollment_code is mandatory\");\n        return false;\n    }\n    User user = userService.getUser(userName, U2fConstants.U2F_ENROLLMENT_CODE_ATTRIBUTE);\n    if (user == null) {",
        "pred_variables": [
            "U2F_ENROLLMENT_CODE_ATTRIBUTE",
            "step"
        ],
        "label_variables": [
            "userName"
        ]
    },
    {
        "code": "private final void replayScheduler(LegacyJobSchedulerImpl legacy, JobSchedulerStoreImpl target) throws Exception {\n    List<LegacyJobImpl> jobs = legacy.getAllJobs();\n    String schedulerName = legacy.getName();\n    for (LegacyJobImpl job : jobs) {",
        "pred_variables": [
            "job"
        ],
        "label_variables": [
            "job"
        ]
    },
    {
        "code": "@Test(timeout = 60000)\npublic void testSendMessage() throws Exception {\n    Destination destination = session.createQueue(getQueueName());\n    MessageConsumer consumer = session.createConsumer(destination);\n    String frame = \"CONNECT\\n\" + \"login:system\\n\" + \"passcode:manager\\n\\n\" + Stomp.NULL;\n    stompConnection.sendFrame(frame);\n    frame = stompConnection.receiveFrame();\n    assertTrue(frame.startsWith(\"CONNECTED\"));\n    long timestamp = System.currentTimeMillis() - TimeUnit.DAYS.toMillis(1);\n    long expires = timestamp + TimeUnit.SECONDS.toMillis(5);",
        "pred_variables": [
            "expires",
            "timestamp"
        ],
        "label_variables": [
            "expires",
            "timestamp"
        ]
    },
    {
        "code": "@Override\npublic void visitTemplateOpen(String name, long id) {",
        "pred_variables": [
            "id",
            "name"
        ],
        "label_variables": [
            "name"
        ]
    },
    {
        "code": "@Override\npublic void visitASCII(String name, long id, CharSequence value) {",
        "pred_variables": [
            "id",
            "name"
        ],
        "label_variables": [
            "name"
        ]
    },
    {
        "code": "public static void main(String[] args) {\n    var printVersion = //\n    Optional.ofNullable(args).//Streams either one element (the args-array) or zero elements\n    stream().flatMap(//\n    Arrays::stream).anyMatch(arg -> \"-v\".equals(arg) || \"--version\".equals(arg));\n    if (printVersion) {\n        var appVer = System.getProperty(\"cryptomator.appVersion\", \"SNAPSHOT\");\n        var buildNumber = System.getProperty(\"cryptomator.buildNumber\", \"SNAPSHOT\");\n        //Reduce noise for parsers by using System.out directly\n        System.out.printf(\"Cryptomator version %s (build %s)%n\", appVer, buildNumber);\n        return;\n    }\n    int exitCode = CRYPTOMATOR_COMPONENT.application().run(args);",
        "pred_variables": [
            "appVersion",
            "SNAPSHOT",
            "cryptomator",
            "args"
        ],
        "label_variables": [
            "exitCode"
        ]
    },
    {
        "code": "@Override\npublic boolean beforeExecute(ForestRequest request) {\n    log.info(\"invoke Base beforeExecute\");\n    Object[] args = request.getArguments();",
        "pred_variables": [
            "args"
        ],
        "label_variables": [
            "args"
        ]
    },
    {
        "code": "@Override\npublic void validatePlanTagsAgainstApiTags(Set<String> planTags, Set<String> apiTags) {\n    if (!isEmpty(planTags) && (isEmpty(apiTags) || !apiTags.stream().anyMatch(apiTag -> planTags.contains(apiTag)))) {",
        "pred_variables": [
            "isEmpty",
            "apiTags"
        ],
        "label_variables": [
            "planTags",
            "apiTags"
        ]
    },
    {
        "code": "@Override\npublic void resultReceived(IPendingServiceCall call) {\n    log.info(\"connectCallback\");\n    ObjectMap<?, ?> map = (ObjectMap<?, ?>) call.getResult();\n    String code = (String) map.get(\"code\");",
        "pred_variables": [
            "call",
            "code"
        ],
        "label_variables": [
            "code"
        ]
    },
    {
        "code": "private void doLockMoney(AccountKit accountKit, Coin lockAmount, long unlockTime) {\n    try {\n        Result result = accountKit.lockMoney(lockAmount, unlockTime, null, null, \"\u7528\u6237\u9501\u4ed3\");\n        if (result.isSuccess()) {\n            DailogUtil.showTipDailogCenter(result.getMessage(), getThisStage());\n            resetAndclose();\n        } else {",
        "pred_variables": [
            "result",
            "unlockTime",
            "lockAmount",
            "accountKit"
        ],
        "label_variables": [
            "result"
        ]
    },
    {
        "code": "/**\n * \u5355\u5143\u6d4b\u8bd5\u7684\u521b\u4e16\u5757\n */\n@Override\npublic BlockStore getGengsisBlock() {\n    BlockStore gengsisBlock = new BlockStore(this, Hex.decode(\"00000000000000000000000000000000000000000000000000000000000000000000000000cc3019924136d3f7ccdd2bc73066941f916c2ea728bf91a4b781c6ab8677e6fdda7e59000000000000fdda7e59832102883a9625a871e79c070e316edafc97eac2f6c97b218d0e55726f25be2a963e9276a9144237cccf6ff9a7674a8fc47c60278fdd23e9f30988473045022100822be165776411571bee4f885a2785dacef21506408788024490b8d63883b14202207c2071d5cbaa367a7c7e22160c540347b8aa51dee1b4c42c3670b9a49f3d3566ac140101000000010012117468697320612067656e6773697320747800000000010080faca73f91f00000000001976a914bb7e4d6ffb3266a0b533b21847bef4dacce95f4688acfdda7e59000000000002010000000101c58e0dfe559f48f3eae222e0d679dd648e70e7c0f4af06bcd5c2b510fcb7e837000000006a473044022055c76d8395f95118958e71ad2a10db0bf62bdc54dd129686cd334fb2a84dc2390220787796e6a843140091ce6aa807118f2ec5727cb468d20c2aea65738684be9a4501210276c52ff14acd4c4d3e08f9596e0127a15e98207b3d0024426364825cd724c86dffffffff020080c6a47e8d03000078c2481976a9144237cccf6ff9a7674a8fc47c60278fdd23e9f30988ac00003426f56b1c00000000001976a914bb7e4d6ffb3266a0b533b21847bef4dacce95f4688acfeda7e5900000000000601000000feda7e59822102883a9625a871e79c070e316edafc97eac2f6c97b218d0e55726f25be2a963e9276a9144237cccf6ff9a7674a8fc47c60278fdd23e9f30988463044022100c8276028ab51982a34fa3d3aa5b5749669ae44448fd2bbf1c2e98bee64e96353021f459cd25897462a186ecea74984b29d5167be43954d9e23185f81d5b2931e24ac4237cccf6ff9a7674a8fc47c60278fdd23e9f30901000000000000000000000000000000000000000000000000000000000000000000000000000000000002010000000101d071ee50c095aa0c51c0b4d1eae4783fd60c17eeeaf055ed35d15697f5a8aa1a010000006a473044022074cf760a00d5bc6fb01baa24a94fa2b7cea3ee770138dc4fe9bd167ea8b7224c02202c3a421fa6c7b0e1df152d31ffd3406bd8ba2c2b26f4ad04234db6d587afdcbb01210276c52ff14acd4c4d3e08f9596e0127a15e98207b3d0024426364825cd724c86dffffffff020010a5d4e8000000000000001976a9144237cccf6ff9a7674a8fc47c60278fdd23e9f30988ac00c0b91502111c00000000001976a914bb7e4d6ffb3266a0b533b21847bef4dacce95f4688acfeda7e59000000000003010000000000feda7e590000000000822102883a9625a871e79c070e316edafc97eac2f6c97b218d0e55726f25be2a963e9276a9144237cccf6ff9a7674a8fc47c60278fdd23e9f3098846304402204b2eb744c120e5484a8c8f78bc56242a4dd29501a47776a6600d9d5a36a05d7f02205c4816cf6230ba3c9d6f77d517242256ba33dfa85ab7d74dc9ede6d8339823f7ac82db86974237cccf6ff9a7674a8fc47c60278fdd23e9f3090601000000feda7e59832103a7db4a854e3f2ae3a30aa759bfd39045f6a80c967b3fd81036acebc54b557ece76a9142c1179b1e05fb8652644f6c61a033d28431009128847304502210091bc31854e35679cf0d590de1744dd1d58414ea8c602baa6c002c6d16270a76c02204a208ca7f5e4b07e7c525ff7f13885ff9e64598321b6c826c0d89f2f11b74ec7ac2c1179b1e05fb8652644f6c61a033d2843100912010000000000000000000000000000000000000000000000000000000000000000000000000000000000020100000001016f18243ef25c20e27b444018c6d3973afe5dc5e17a76900a35602934abfcbc6d010000006a473044022047e4be626483eb49874d84cace06f6270e7069ef03b17607e6c154d3314792a802201761c8d752fb4f3ced897e8681b5348dbb6620b5e87f4b3044726279215c870f01210276c52ff14acd4c4d3e08f9596e0127a15e98207b3d0024426364825cd724c86dffffffff020010a5d4e8000000000000001976a9142c1179b1e05fb8652644f6c61a033d284310091288ac00803f050fb61b00000000001976a914bb7e4d6ffb3266a0b533b21847bef4dacce95f4688acfeda7e59000000000003010000000000feda7e590000000000822103a7db4a854e3f2ae3a30aa759bfd39045f6a80c967b3fd81036acebc54b557ece76a9142c1179b1e05fb8652644f6c61a033d284310091288463044022063ed166fb3e3302156799053c1965be1a4b14c4be4388495803285fb336c4a5f02207995aaae813270e78a4e81538404ee806d9e479b2449d4200fe46d3991bcb563ac95db86972c1179b1e05fb8652644f6c61a033d28431009120601000000feda7e598321033e371b2f3d42dd525833bcce12cb0d404fb73898bdea3e6794bd8ec552c9ba9c76a914b3fcd687a5c2b2617de0d504cfa7d12db93bb00c88473045022100a7037bbf30c8a7b1d5d4889611b6a7847e1890a183772144fe0d7b31cc8239de02203dbcc972e939993be5a630c762aa7e71aa13e8c32db89694789df883e8b5bdf6acb3fcd687a5c2b2617de0d504cfa7d12db93bb00c01000000000000000000000000000000000000000000000000000000000000000000000000000000000002010000000101fc68d536143f463dc9faf5f7fd91c164a7452430190428909231bc5b35dc4f49010000006a473044022022e49a752f7b0cc62eaafd5e674c05fc1f8912b3f4ab06f6f08a620e0ab99d02022026f5d1ca0afc368a0fcae5ba9d3d5e4e302d44f45511bcef3549243b2d8d6d4701210276c52ff14acd4c4d3e08f9596e0127a15e98207b3d0024426364825cd724c86dffffffff020010a5d4e8000000000000001976a914b3fcd687a5c2b2617de0d504cfa7d12db93bb00c88ac0040c5f41b5b1b00000000001976a914bb7e4d6ffb3266a0b533b21847bef4dacce95f4688acfeda7e59000000000003010000000000feda7e5900000000008321033e371b2f3d42dd525833bcce12cb0d404fb73898bdea3e6794bd8ec552c9ba9c76a914b3fcd687a5c2b2617de0d504cfa7d12db93bb00c88473045022100a1582b1152f841141f58e7039dafda5188ebd86337e79f382e87c1d3c485b7f002203fdd9d53d015fd700c3177f16dffbbcff928a439fdd03eb50aae3617ff4c520aac9adb8697b3fcd687a5c2b2617de0d504cfa7d12db93bb00c0601000000feda7e59832103bf7759e9b81f8ff1b99732b3ee36aea0abff68c818b8839c318ad350e9642cb076a914c3bfdb8a67f35b6e4ea1ee3ae7b91eff58ec81a8884730450221008ed069cd3d6a80b581988134f5064a0da1318f4c76d69bb7499a4d2000a1561c02204cd2c2662e9b8c0ec042d5a815ec7be626c6c5cf9be9ce6885e0e373d23f32a2acc3bfdb8a67f35b6e4ea1ee3ae7b91eff58ec81a8010000000000000000000000000000000000000000000000000000000000000000000000000000000000020100000001017bf6dec121b65c8c8ce4f9d22fbf644733fea228e351180585033bde0e1b85a2010000006a473044022028dc85f0e5c6c2a868825943c175013abe82f1085a03ad90f8e9857992f440ed0220744b338f005d43731e717f31a873cfec5803ef42ccc1ff4087b01aef5e8fd31401210276c52ff14acd4c4d3e08f9596e0127a15e98207b3d0024426364825cd724c86dffffffff020010a5d4e8000000000000001976a914c3bfdb8a67f35b6e4ea1ee3ae7b91eff58ec81a888ac00004be428001b00000000001976a914bb7e4d6ffb3266a0b533b21847bef4dacce95f4688acfeda7e5900000000000601000000feda7e5983210200d482122f8537ad2fa1af1914e088d6b308824a8ef4dc8b68fa0e0a88c484e376a9145f1a078b610d92a3110b2c1a7f880b0d2442e53088473045022100c36001db4676050eef55bc0f9100c761e3c72517defc1fa3b43e15736f5283eb0220494f9b47180e83ea508046ac51789b451b4475688b12773539bc8bdb891f4615ac5f1a078b610d92a3110b2c1a7f880b0d2442e53001000000000000000000000000000000000000000000000000000000000000000000000000000000000002010000000101f7e2e4ba55fab9e14f17e80cb3dc40e26b1efb3689ed1d2fd1de6fb96b2e7412010000006a47304402200dba9df5c1445d73af50a0f6f13469f6e4c50abeb1958073b3b0aa5fdca1b2410220472c198c3fc288f651a0f552932f51f3989ed8b457e76e138b1527e5be0d008101210276c52ff14acd4c4d3e08f9596e0127a15e98207b3d0024426364825cd724c86dffffffff020010a5d4e8000000000000001976a9145f1a078b610d92a3110b2c1a7f880b0d2442e53088ac00c0d0d335a51a00000000001976a914bb7e4d6ffb3266a0b533b21847bef4dacce95f4688acfeda7e5900000000000601000000feda7e59832103e8769d1901a4ef006054405c16716d6648fffe628385db5586c7fa18c3df5da876a914df639c6066a817a6be28b532839f8e1e85594cd488473045022100ac7e5e7b619007a14c997edb67ea8027c53aee3803bc11f855aeb7b709abb6d002206c8970a35f68620130f80b3350a2a929e1258e8169eeb128141770411d2259bbacdf639c6066a817a6be28b532839f8e1e85594cd401000000000000000000000000000000000000000000000000000000000000000000000000000000000002010000000101d952e5a18d84d31851f2945406586d909323709c054d6c2a4f6993b1cc37207e010000006a473044022076f0a9cdd46046a3fdf018a21e8d1be98e46510b6c8dfff26206836b34d1c641022067ff8112c3f430dfab5e15eb9288f29786a8f7781520e3d387373150453d66cc01210276c52ff14acd4c4d3e08f9596e0127a15e98207b3d0024426364825cd724c86dffffffff020010a5d4e8000000000000001976a914df639c6066a817a6be28b532839f8e1e85594cd488ac008056c3424a1a00000000001976a914bb7e4d6ffb3266a0b533b21847bef4dacce95f4688acfeda7e5900000000000601000000feda7e59832103368f8061e02694e37da199c07c3e2f2506cdd748efee493f0d1c52ae7494428f76a914e3453a80144f6ac24baf01f20455c6167b985485884730450221009a406555174e5ace2a970281cd9ee5480ff3a380f5e83a3640f65bf1b6ecb815022003f3691301ff45fe4cf91a013bb9dd0c4450f5bae9912cc9ec4868a88ec6d96bace3453a80144f6ac24baf01f20455c6167b9854850100000000000000000000000000000000000000000000000000000000000000000000000000000000000201000000010137ad0d22028c39abc39d21066ee7ae9d7b495ad048a17f9b4a14a48af998e68d010000006a47304402206b8d399e52b28bb5cfa5153f4c8909fb2549b9b8097864e47e29a387d84a0f71022079535b406d28416a3b9268be689113a0f100c46bbcb74d7fdaac6f3302a34db301210276c52ff14acd4c4d3e08f9596e0127a15e98207b3d0024426364825cd724c86dffffffff020010a5d4e8000000000000001976a914e3453a80144f6ac24baf01f20455c6167b98548588ac0040dcb24fef1900000000001976a914bb7e4d6ffb3266a0b533b21847bef4dacce95f4688acfeda7e5900000000000b0100000043da7e5982c220256303b7fa1e89761bf37c1a8415524dbcb9ec1b4033ce71d4224699e8459235c314dd1c14ee4f4642eb9c3e14cc97a3c3d3629708ea88473045022100c50a56f6bb25ea2ade3b83def48d7b55401916f711a634a8b2163b555343cef502203cda9a0c6735c72cf4599def1eaec90f32206e69ded301be46168aa2ad0286aaacdd1c14ee4f4642eb9c3e14cc97a3c3d3629708eadd1c14ee4f4642eb9c3e14cc97a3c3d3629708ea01fd23022b046e616d6506e5908de7a7b01ee9878de5ba86e58db0e993bee7a791e68a80e69c89e99990e585ace58fb822076164647265737306e59cb0e59d8012e9878de5ba86e5b882e58d97e5b2b8e58cba44046c6f676f06e59bbee7898737687474703a2f2f66696c652e696e636861696e2e6f72672f696d616765732f696e636861696e5f6c6f676f5f313030783130302e706e672b0a637265646974436f64650ce4bfa1e794a8e4bba3e7a0811239313530303130384d41355542333248334e1a0570686f6e6506e794b5e8af9d0c3032332d383633333130363927077765627369746506e5ae98e7bd911768747470733a2f2f7777772e696e636861696e2e6f7267fd1d0108646573637269707406e68f8fe8bfb0fd0a01e9878de5ba86e58db0e993bee7a791e68a80e69c89e99990e585ace58fb8e698afe4b880e5aeb6e4bba5e58cbae59d97e993bee68a80e69cafe9a9b1e58aa8e79a84e5889be696b0e59e8be4bc81e4b89aefbc8ce585b6e4b8bbe5afbce79a84e58cbae59d97e993bee7a4bee58cbae9a1b9e79bae496e636861696e2de58db0e993bee698afe4b880e4b8aae4bba5e998b2e4bcaae4b8bae59fbae7a180e4b89ae58aa1e79a84e585ace5bc80e5b9b3e58fb0efbc8ce4b8bae7a4bee4bc9ae59084e4bc81e4b89ae38081e69cbae69e84e38081e889bae69cafe5aeb6e7ad89e68f90e4be9be59381e7898ce38081e79fa5e8af86e4baa7e69d83e4bf9de68aa4e69c8de58aa1e380820221023cbfda1ae93a41187634206177a0482ee2c890540bd907a7f6fbdde9e5a31c3b2103489e3933f41327c2463b664776a4355860cf5b093c106d21f0253f83dda76465012103df243c24dfe4ea420c776e8d46fbc2a86c6e439648119f64b583a38a0c7d84fd00\"));\n    Sha256Hash merkleHash = gengsisBlock.getBlock().buildMerkleHash();\n    if (log.isDebugEnabled()) {",
        "pred_variables": [
            "Sha256Hash",
            "merkleHash"
        ],
        "label_variables": [
            "merkleHash"
        ]
    },
    {
        "code": "@Parameterized.Parameters(name = \"{1}\")\npublic static Collection<String[]> getTestParameters() throws IOException {\n    List<String[]> configUrls = new ArrayList<String[]>();\n    configUrls.add(new String[] { \"xbean:src/release/conf/activemq.xml\", \"activemq.xml\" });\n    String osName = System.getProperty(\"os.name\");",
        "pred_variables": [
            "osName"
        ],
        "label_variables": [
            "osName"
        ]
    },
    {
        "code": "@Override\npublic Future<Set<String>> cacheEntries() {\n    Promise<Set<String>> promise = Promise.promise();\n    redisAPI.smembers(CACHED_REQUESTS, reply -> {\n        if (reply.failed()) {\n            String message = \"Failed to get cached requests. Cause: \" + logCause(reply);",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "@Override\npublic void uncaughtException(Thread t, Throwable e) {",
        "pred_variables": [
            "e"
        ],
        "label_variables": [
            "t",
            "e"
        ]
    },
    {
        "code": "@Override\nprotected void startUp() {\n    // RAM directory storage by default\n    if (luceneStorageConfig == null || luceneStorageConfig.equals(Constants.LUCENE_DIRECTORY_STORAGE_RAM)) {\n        directory = new RAMDirectory();\n        log.info(\"Using RAM Lucene storage\");\n    } else if (luceneStorageConfig.equals(Constants.LUCENE_DIRECTORY_STORAGE_FILE)) {\n        File luceneDirectory = DirectoryUtil.getLuceneDirectory();",
        "pred_variables": [
            "default",
            "luceneStorageConfig",
            "directory"
        ],
        "label_variables": [
            "luceneDirectory"
        ]
    },
    {
        "code": "private void registerAerospikeEnvironment(GenericContainer<?> aerospike, ConfigurableEnvironment environment, AerospikeProperties properties) {\n    Integer mappedPort = aerospike.getMappedPort(properties.port);\n    String host = aerospike.getHost();\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.aerospike.host\", host);\n    map.put(\"embedded.aerospike.port\", mappedPort);\n    map.put(\"embedded.aerospike.namespace\", properties.namespace);",
        "pred_variables": [
            "namespace",
            "properties"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "private UiTheme parseUiTheme(String uiThemeName) {\n    try {\n        return UiTheme.valueOf(uiThemeName.toUpperCase());\n    } catch (IllegalArgumentException e) {",
        "pred_variables": [
            "valueOf",
            "uiThemeName"
        ],
        "label_variables": [
            "uiThemeName"
        ]
    },
    {
        "code": "/**\n * Looks for an error message.\n *\n * @param p_list error list\n * @param type   The type of the error.\n * @return Error message or <code>null</code> if not found.\n */\nprivate ErrorMessage getError(List<ErrorMessage> p_list, IErrorType type) {",
        "pred_variables": [
            "error",
            "ErrorMessage",
            "message",
            "type"
        ],
        "label_variables": [
            "type"
        ]
    },
    {
        "code": "public void reportDataSizeByTopic(int maxToReport) {\n    LOG.info(\"Data Size By Topic:\");\n    List<Map.Entry<String, Long>> dataSizeByTopicSorted = sortByValueDesc(this.dataSizeByTopic);\n    for (int i = 0; i < dataSizeByTopicSorted.size() && i < maxToReport; i++) {\n        Map.Entry<String, Long> entry = dataSizeByTopicSorted.get(i);\n        double dataSizeMB = (double) entry.getValue() / 1024.0 / 1024.0;",
        "pred_variables": [
            "entry"
        ],
        "label_variables": [
            "dataSizeMB"
        ]
    },
    {
        "code": "private P384KeyPair loadExistingKeyPair(char[] passphrase, Path p12File) throws IOException {",
        "pred_variables": [
            "p12File",
            "passphrase"
        ],
        "label_variables": [
            "p12File"
        ]
    },
    {
        "code": "protected void handleException(String msg, Exception e) {",
        "pred_variables": [
            "msg",
            "e"
        ],
        "label_variables": [
            "msg",
            "e"
        ]
    },
    {
        "code": "public SessionId getConnectSession(HttpServletRequest httpRequest) {\n    String cookieId = cookieService.getSessionIdFromCookie(httpRequest);",
        "pred_variables": [
            "httpRequest",
            "cookieId"
        ],
        "label_variables": [
            "cookieId"
        ]
    },
    {
        "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic void exceptionCaught(IoSession session, Throwable cause) throws Exception {\n    if (log.isDebugEnabled()) {",
        "pred_variables": [
            "cause"
        ],
        "label_variables": [
            "cause"
        ]
    },
    {
        "code": "private void reportErrors(@Nullable Stage stage, @Nullable Throwable error) {\n    if (error != null) {",
        "pred_variables": [
            "error"
        ],
        "label_variables": [
            "error"
        ]
    },
    {
        "code": "private NodeOrientation parseUiOrientation(String uiOrientationName) {\n    try {\n        return NodeOrientation.valueOf(uiOrientationName.toUpperCase());\n    } catch (IllegalArgumentException e) {",
        "pred_variables": [
            "valueOf",
            "uiOrientationName"
        ],
        "label_variables": [
            "uiOrientationName"
        ]
    },
    {
        "code": "@Override\npublic void error(String message) {",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "@Test\npublic void testGetExecutionCount() throws Exception {\n    final JobSchedulerViewMBean view = getJobSchedulerMBean();\n    assertNotNull(view);\n    assertTrue(view.getAllJobs().isEmpty());\n    scheduleMessage(10000, 1000, 10);\n    assertFalse(view.getAllJobs().isEmpty());\n    TabularData jobs = view.getAllJobs();\n    assertEquals(1, jobs.size());\n    String jobId = null;\n    for (Object key : jobs.keySet()) {\n        jobId = ((List<?>) key).get(0).toString();\n    }\n    final String fixedJobId = jobId;",
        "pred_variables": [
            "jobId"
        ],
        "label_variables": [
            "jobId"
        ]
    },
    {
        "code": "public boolean isValid(RequestContext context, String endpointAddress) throws Exception {\n    if (endpointAddress == null) {\n        return true;\n    }\n    // The endpointAddress address must be a valid URL + start with http(s)\n    // Validate it first using commons-validator\n    UrlValidator urlValidator = new UrlValidator(new String[] { \"http\", \"https\" }, UrlValidator.ALLOW_LOCAL_URLS);\n    if (!urlValidator.isValid(endpointAddress)) {",
        "pred_variables": [
            "endpointAddress",
            "ALLOW_LOCAL_URLS",
            "urlValidator"
        ],
        "label_variables": [
            "endpointAddress"
        ]
    },
    {
        "code": "@Override\npublic void onMessage(Message message) {\n    try {\n        Thread.sleep(2000L);\n        if (message instanceof TextMessage) {",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "/**\n * Pushes a message out to all the PushableConsumers.\n *\n * @param message\n *            the message to be pushed to consumers\n * @throws IOException\n *            In case IOException of some sort is occurred\n */\npublic void pushMessage(IMessage message) throws IOException {\n    if (log.isDebugEnabled()) {",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "        }\n        Set<String> myIps = IpUtil.getIps();\n        for (String seedDomain : SEED_DOMAINS) {\n            try {\n                InetAddress[] response = InetAddress.getAllByName(seedDomain);\n                for (InetAddress inetAddress : response) {\n                    //\u6392\u9664\u81ea\u5df1\n                    if (myIps.contains(inetAddress.getHostAddress())) {\n                        continue;\n                    }\n                    //\u82e5\u8fde\u63a5\u5931\u8d25\uff0c\u5219\u91cd\u8bd5\uff0c\u6682\u5b9a1\u5206\u949f\n                    Seed seed = new Seed(new InetSocketAddress(inetAddress, Configure.PORT), true, 1 * 60000);\n                    add(seed);\n                }\n            } catch (Exception e) {",
        "pred_variables": [
            "inetAddress",
            "\u82e5\u8fde\u63a5\u5931\u8d25",
            "seedDomain"
        ],
        "label_variables": [
            "seedDomain"
        ]
    },
    {
        "code": "@FXML\npublic void proceed() {\n    LOG.trace(\"proceed()\");\n    FileChooser fileChooser = new FileChooser();\n    fileChooser.setTitle(resourceBundle.getString(\"unlock.chooseMasterkey.filePickerTitle\"));\n    fileChooser.getExtensionFilters().add(new FileChooser.ExtensionFilter(resourceBundle.getString(\"unlock.chooseMasterkey.filePickerMimeDesc\"), CRYPTOMATOR_FILENAME_GLOB));\n    File masterkeyFile = fileChooser.showOpenDialog(window);\n    if (masterkeyFile != null) {",
        "pred_variables": [
            "filePickerMimeDesc",
            "window"
        ],
        "label_variables": [
            "masterkeyFile"
        ]
    },
    {
        "code": "@Test\nvoid test() throws Exception {\n    String sutUrl = \"https://bonigarcia.dev/selenium-webdriver-java/\";\n    driver.get(sutUrl);\n    String title = driver.getTitle();",
        "pred_variables": [
            "https"
        ],
        "label_variables": [
            "sutUrl",
            "title"
        ]
    },
    {
        "code": "protected static void handleException(String msg, Exception e) {",
        "pred_variables": [
            "msg",
            "e"
        ],
        "label_variables": [
            "msg",
            "e"
        ]
    },
    {
        "code": "        dnFind_work = getDnFind();\n    }\n    boolean found = false;\n    if (StringUtils.isNotEmpty(dnSearchIn_work) && StringUtils.isNotEmpty(dnFind_work)) {\n        try {\n            found = findMember(getHost(), getPort(), dnSearchIn_work, isUseSsl(), dnFind_work, isRecursiveSearch());\n        } catch (NamingException e) {\n            throw new PipeRunException(this, \"exception on ldap lookup\", e);\n        }\n    }\n    if (!found) {\n        String msg = \"dn [\" + dnFind_work + \"] not found as member in url [\" + retrieveUrl(getHost(), getPort(), dnSearchIn_work, isUseSsl()) + \"]\";\n        if (notFoundForward == null) {\n            throw new PipeRunException(this, msg);\n        }",
        "pred_variables": [
            "dn",
            "found"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "private boolean executeExternalModifyResponse(CustomScriptConfiguration scriptConf, JSONObject responseAsJsonObject, ExternalIntrospectionContext context) {\n    try {",
        "pred_variables": [
            "JSONObject",
            "responseAsJsonObject"
        ],
        "label_variables": [
            "context",
            "responseAsJsonObject"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"memsql\")\nToxiproxyContainer.ContainerProxy memsqlContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(BEAN_NAME_EMBEDDED_MEMSQL) GenericContainer<?> memsql, MemSqlProperties properties, ConfigurableEnvironment environment) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(memsql, properties.getPort());\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.memsql.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.memsql.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.memsql.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedMemsqlToxiproxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "@Override\npublic Optional<RuleSetChangedEvent> parse(String jsonData) {\n    var payload = gson.fromJson(jsonData, RuleSetChangedEventPayload.class);\n    if (payload.isInvalid()) {",
        "pred_variables": [
            "jsonData",
            "payload"
        ],
        "label_variables": [
            "jsonData"
        ]
    },
    {
        "code": "public String[] getRoles() {\n    RuntimeException e = new RuntimeException(\"Not implemented\");",
        "pred_variables": [
            "e"
        ],
        "label_variables": [
            "e"
        ]
    },
    {
        "code": "private void removeConnection(String removedConnectionId) {\n    var removed = repository.remove(removedConnectionId);\n    if (removed == null) {",
        "pred_variables": [
            "removedConnectionId",
            "removed"
        ],
        "label_variables": [
            "removedConnectionId"
        ]
    },
    {
        "code": "@Override\npublic boolean beforeExecute(ForestRequest request) {\n    log.info(\"invoke False beforeExecute\");\n    Object[] args = request.getArguments();\n    args[0] = \"b\";",
        "pred_variables": [
            "request",
            "args"
        ],
        "label_variables": [
            "args"
        ]
    },
    {
        "code": "@Override\npublic Histogram deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JacksonException {\n    ByteBuffer buffer = threadBuffer.get();\n    buffer.clear();\n    try (OutputStream os = new ByteBufferBackedOutputStream(buffer)) {\n        jsonParser.readBinaryValue(os);\n        buffer.flip();\n        // Long.MIN_VALUE used so that Histogram will defer to the value encoded in the histogram\n        // value. This assumes that it is acceptable for the deserialized value we create to\n        // share the same parameters of the source histogram that was serialized.\n        return Histogram.decodeFromCompressedByteBuffer(buffer, Long.MIN_VALUE);\n    } catch (Exception e) {",
        "pred_variables": [
            "deserializationContext",
            "jsonParser",
            "buffer"
        ],
        "label_variables": [
            "buffer"
        ]
    },
    {
        "code": "private void visibleWindowsChanged(ListChangeListener.Change<? extends Window> change) {\n    int visibleWindows = change.getList().size();",
        "pred_variables": [
            "getList",
            "visibleWindows",
            "Change"
        ],
        "label_variables": [
            "visibleWindows"
        ]
    },
    {
        "code": "@PostConstruct\npublic void init() {\n    AdminClient adminClient = adminClient();\n    try {\n        StopWatch stopWatch = new StopWatch(\"CheckAndCreateTopics\");\n        stopWatch.start(\"CheckAndCreateTopics\");\n        ClassPathScanningCandidateComponentProvider provider = new ClassPathScanningCandidateComponentProvider(false);\n        provider.addIncludeFilter(new AssignableTypeFilter(PublishedEvent.class));\n        Set<BeanDefinition> candidateComponents = provider.findCandidateComponents(eventApisConfiguration.getBaseEventsPackage());\n        int numPartitions = getDefaultNumberOfPartitions(adminClient);\n        for (BeanDefinition candidateComponent : candidateComponents) {\n            Class<PublishedEvent> beanClass;\n            try {\n                beanClass = (Class<PublishedEvent>) Class.forName(candidateComponent.getBeanClassName());\n                String topicName = beanClass.getSimpleName();",
        "pred_variables": [],
        "label_variables": [
            "topicName"
        ]
    },
    {
        "code": "public ReportConfigurationBean[] getSavedReports() throws Exception {\n    try {\n        return reportingAdminServiceStub.getSavedReports();\n    } catch (Exception e) {\n        String msg = \"Unable to get saved report\";",
        "pred_variables": [
            "msg"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "@Override\npublic void resultReceived(IPendingServiceCall call) {\n    log.info(\"connectCallback\");\n    ObjectMap<?, ?> map = (ObjectMap<?, ?>) call.getResult();\n    String code = (String) map.get(\"code\");",
        "pred_variables": [
            "call",
            "code"
        ],
        "label_variables": [
            "code"
        ]
    },
    {
        "code": "void log(int level, String message, Throwable th) {\n    synchronized (logServices) {\n        for (LogService log : logServices) {",
        "pred_variables": [
            "th",
            "message"
        ],
        "label_variables": [
            "th",
            "level",
            "message"
        ]
    },
    {
        "code": "@Test\npublic void testCtor() throws Exception {\n    log.debug(\"\\n testCtor\");\n    File file = new File(\"target/test-classes/fixtures/p-ok.mp3\");\n    @SuppressWarnings(\"unused\")\n    File file2 = new File(\"target/test-classes/fixtures/p-err.mp3\");\n    //File file = new File(\"target/test-classes/fixtures/01 Cherub Rock.mp3\");\n    //File file = new File(\"target/test-classes/fixtures/CodeMonkey.mp3\");\n    MP3Reader reader = new MP3Reader(file);\n    ITag tag = reader.readTag();",
        "pred_variables": [
            "tag"
        ],
        "label_variables": [
            "tag"
        ]
    },
    {
        "code": "@Override\npublic Optional<TaintVulnerabilityClosedEvent> parse(String jsonData) {\n    var payload = gson.fromJson(jsonData, TaintVulnerabilityClosedEventPayload.class);\n    if (payload.isInvalid()) {",
        "pred_variables": [
            "jsonData",
            "payload"
        ],
        "label_variables": [
            "jsonData"
        ]
    },
    {
        "code": "/**\n * Method responsible to process expired CIBA requests, set them as expired in cache\n * and send callbacks to the client\n * @param cibaRequest Object containing data related to the CIBA request.\n * @param authReqId Authentication request id.\n */\nprivate void processExpiredRequest(CibaRequestCacheControl cibaRequest, String authReqId) {\n    if (cibaRequest.getStatus() != CibaRequestStatus.PENDING && cibaRequest.getStatus() != CibaRequestStatus.EXPIRED) {\n        return;\n    }",
        "pred_variables": [
            "CibaRequestStatus",
            "authReqId",
            "cibaRequest"
        ],
        "label_variables": [
            "authReqId"
        ]
    },
    {
        "code": "@Override\nprotected List<File> postDownload(File archive) {\n    Collection<File> listFiles = listFiles(new File(archive.getParent()), null, true);\n    Iterator<File> iterator = listFiles.iterator();\n    File file = null;\n    List<File> files = new ArrayList<>();\n    while (iterator.hasNext()) {\n        file = iterator.next();\n        String fileName = file.getName();\n        if (fileName.contains(getDriverName())) {",
        "pred_variables": [
            "file"
        ],
        "label_variables": [
            "fileName"
        ]
    },
    {
        "code": "        Writer writer = null;\n        InputStream instream = null;\n        try {\n            Process process = Runtime.getRuntime().exec(\"sh rabbitmqctl status\", null, rabbitMQHome);\n            instream = process.getInputStream();\n            writer = new StringWriter();\n            char[] buffer = new char[1024];\n            reader = new BufferedReader(new InputStreamReader(instream));\n            int n;\n            while ((n = reader.read(buffer)) != -1) {\n                writer.write(buffer, 0, n);\n            }\n            reader.close();\n            instream.close();\n            String message = writer.toString();",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "@EventListener\n@Async(\"taskExecutor\")\npublic void processArticlePostEvent(ArticleEvent articleEvent) throws InterruptedException {\n    Thread.sleep(1000);",
        "pred_variables": [
            "articleEvent"
        ],
        "label_variables": [
            "articleEvent"
        ]
    },
    {
        "code": "@Override\npublic void visitUnsignedLong(String name, long id, long value) {",
        "pred_variables": [
            "id",
            "name"
        ],
        "label_variables": [
            "name",
            "value"
        ]
    },
    {
        "code": "public void testLoadTempAdvisoryQueues() throws Exception {\n    for (int i = 0; i < MESSAGE_COUNT; i++) {\n        TemporaryQueue tempQueue = session.createTemporaryQueue();\n        MessageConsumer consumer = session.createConsumer(tempQueue);\n        MessageProducer producer = session.createProducer(tempQueue);\n        consumer.close();\n        producer.close();\n        tempQueue.delete();\n    }\n    AdvisoryBroker ab = (AdvisoryBroker) broker.getBroker().getAdaptor(AdvisoryBroker.class);\n    assertTrue(ab.getAdvisoryDestinations().size() == 0);\n    assertTrue(ab.getAdvisoryConsumers().size() == 0);\n    assertTrue(ab.getAdvisoryProducers().size() == 0);\n    RegionBroker rb = (RegionBroker) broker.getBroker().getAdaptor(RegionBroker.class);\n    for (Destination dest : rb.getDestinationMap().values()) {",
        "pred_variables": [
            "dest"
        ],
        "label_variables": [
            "dest"
        ]
    },
    {
        "code": "private void registerInfluxEnvironment(ConcreteInfluxDbContainer influx, ConfigurableEnvironment environment, InfluxDBProperties properties) {\n    Integer mappedPort = influx.getMappedPort(properties.getPort());\n    String host = influx.getHost();\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.influxdb.port\", mappedPort);\n    map.put(\"embedded.influxdb.host\", host);\n    map.put(\"embedded.influxdb.database\", properties.getDatabase());\n    map.put(\"embedded.influxdb.user\", properties.getUser());\n    map.put(\"embedded.influxdb.password\", properties.getPassword());\n    String influxDBURL = \"http://{}:{}\";",
        "pred_variables": [
            "String",
            "properties",
            "influxdb"
        ],
        "label_variables": [
            "mappedPort",
            "host",
            "map"
        ]
    },
    {
        "code": "@Override\nprotected Void processItem(List<DataPointWithEventDetectors> subgroup, int itemId) {\n    long startTs = 0L;\n    if (log.isInfoEnabled()) {\n        startTs = Common.timer.currentTimeMillis();",
        "pred_variables": [
            "currentTimeMillis",
            "startTs",
            "itemId"
        ],
        "label_variables": [
            "itemId"
        ]
    },
    {
        "code": "/**\n * Unregisters a plug-in.\n *\n * @param plugin\n *            plugin\n */\npublic static void unregister(IRed5Plugin plugin) {",
        "pred_variables": [
            "plugin"
        ],
        "label_variables": [
            "plugin"
        ]
    },
    {
        "code": "@Test\npublic void patternUpdate() {\n    final String msg = \"pattern\";\n    StdoutRecorder stdoutRecorder = new StdoutRecorder();\n    String log = stdoutRecorder.record(new Runnable() {\n\n        @Override\n        public void run() {\n            Logger logger = LogManager.getLogger(\"patternUpdateLog4j2Jvm7\");",
        "pred_variables": [
            "msg",
            "record"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "/**\n * {@inheritDoc}\n */\npublic int seek(int ts) {",
        "pred_variables": [
            "ts"
        ],
        "label_variables": [
            "ts"
        ]
    },
    {
        "code": "@Override\npublic /**\n * Converts String IP address to InetAddress object.\n *\n * @param textValue ex. \"255.255.222.255\"\n */\nvoid setAsText(String textValue) {",
        "pred_variables": [
            "textValue"
        ],
        "label_variables": [
            "textValue"
        ]
    },
    {
        "code": "public <Q> DeferredChanged<Q> mapOptional(Function<Optional<T>, Optional<Q>> function) {\n    if (valueSet) {\n        Optional<Q> result = function.apply(this.valueOptional);",
        "pred_variables": [
            "function",
            "result"
        ],
        "label_variables": [
            "result",
            "function"
        ]
    },
    {
        "code": "@Override\npublic void afterPropertiesSet() throws Exception {\n    //Messages that do not match the TopicSelector will be discarded\n    nullChannel = applicationContext.getBean(\"nullChannel\", MessageChannel.class);\n    ClassPathBeanDefinitionScanner scanner = scan();\n    String[] names = scanner.getRegistry().getBeanDefinitionNames();\n    for (String beanName : names) {",
        "pred_variables": [
            "beanName"
        ],
        "label_variables": [
            "beanName"
        ]
    },
    {
        "code": "// internal method for issue #323\npublic void getAndCloseSO() {\n    log.debug(\"getAndCloseSO initialised\");\n    // get it\n    if (!hasSharedObject(appScope, \"issue323\")) {\n        if (!createSharedObject(appScope, \"issue323\", false)) {\n            log.warn(\"Shared object creation failed\");\n        }\n    }\n    ISharedObject so = getSharedObject(appScope, \"issue323\");",
        "pred_variables": [
            "so",
            "issue323"
        ],
        "label_variables": [
            "so"
        ]
    },
    {
        "code": "                inStream = url.openStream();\n            } else {\n                warningMessage = \"Bundle context could not find resource \" + TENANT_MGT_XML + \" or user does not have sufficient permission to access the resource.\";\n            }\n        } else {\n            if ((url = this.getClass().getClassLoader().getResource(TENANT_MGT_XML)) != null) {\n                inStream = url.openStream();\n            } else {\n                warningMessage = \"Could not find resource \" + TENANT_MGT_XML + \" or user does not have sufficient permission to access the resource.\";\n            }\n        }\n    }\n    if (inStream == null) {\n        String message = \"Tenant configuration not found. Cause - \" + warningMessage;\n        if (log.isDebugEnabled()) {",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "@Test\npublic void testMakeProduct() throws Exception {\n    Product product = createProduct();\n    assert (product != null);",
        "pred_variables": [],
        "label_variables": [
            "product"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"couchbase\")\nToxiproxyContainer.ContainerProxy couchbaseContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(BEAN_NAME_EMBEDDED_COUCHBASE) CouchbaseContainer couchbase, ConfigurableEnvironment environment) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(couchbase, couchbase.getBootstrapHttpDirectPort());\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.couchbase.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.couchbase.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.couchbase.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedCouchbaseToxiProxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "private long startAndLogTime(GenericContainer<?> container, Logger logger) {\n    Instant startTime = Instant.now();\n    container.start();\n    long startupTime = Duration.between(startTime, Instant.now()).toMillis() / 1000;\n    String dockerImageName = container.getDockerImageName();\n    String buildDate = getBuildDate(container, dockerImageName);\n    // influxdb:1.4.3 build 2018-07-06T17:25:49+02:00 (2 years 11 months ago) startup time is 21 seconds\n    if (startupTime < 10L) {",
        "pred_variables": [
            "dockerImageName"
        ],
        "label_variables": [
            "dockerImageName",
            "startupTime",
            "buildDate"
        ]
    },
    {
        "code": "@Override\npublic boolean accept(File dir, String name) {",
        "pred_variables": [
            "name"
        ],
        "label_variables": [
            "name"
        ]
    },
    {
        "code": "public Object evaluate(final String expression) throws Exception {\n    if (expression == null) {\n        throw new IllegalArgumentException(\"expression\");\n    }",
        "pred_variables": [
            "expression"
        ],
        "label_variables": [
            "expression"
        ]
    },
    {
        "code": "    // setup a consumer to drain messages..\n    MessageConsumer consumer = session.createConsumer(queue);\n    consumer.setMessageListener(new MessageListener() {\n\n        @Override\n        public void onMessage(Message message) {\n        }\n    });\n    // warmup...\n    for (int i = 0; i < 10; i++) {\n        benchmarkNonCallbackRate();\n        benchmarkCallbackRate();\n    }\n    double callbackRate = benchmarkCallbackRate();\n    double nonCallbackRate = benchmarkNonCallbackRate();",
        "pred_variables": [
            "callbackRate"
        ],
        "label_variables": [
            "callbackRate"
        ]
    },
    {
        "code": "@Override\npublic DruidCluster getDruidCluster(String clusterId) throws ClusterNotFoundException {",
        "pred_variables": [
            "clusterId"
        ],
        "label_variables": [
            "clusterId"
        ]
    },
    {
        "code": "void deduce(int rowIndex, int colIndex, int value) {\n    double newValue = cooccurrence.get(rowIndex, colIndex);\n    if (newValue == 0) {",
        "pred_variables": [
            "value",
            "colIndex",
            "rowIndex"
        ],
        "label_variables": [
            "colIndex",
            "rowIndex"
        ]
    },
    {
        "code": "@CheckForNull\nprivate Path locateNode(@Nullable Path configuredNodejsPath) {\n    if (configuredNodejsPath != null) {",
        "pred_variables": [
            "configuredNodejsPath"
        ],
        "label_variables": [
            "configuredNodejsPath"
        ]
    },
    {
        "code": "/**\n * \u63a5\u6536\u5230\u533a\u5757\u62c9\u53d6\u6d88\u606f\n */\n@Override\npublic MessageProcessResult process(Message message, Peer peer) {\n    if (log.isDebugEnabled()) {",
        "pred_variables": [
            "message",
            "peer"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "private static Predicate<? super SonarLintRuleDefinition> isIncludedByConfiguration(Set<String> includedRules) {\n    return r -> {\n        if (includedRules.contains(r.getKey())) {\n            return true;\n        }\n        for (String deprecatedKey : r.getDeprecatedKeys()) {\n            if (includedRules.contains(deprecatedKey)) {",
        "pred_variables": [
            "deprecatedKey",
            "getDeprecatedKeys"
        ],
        "label_variables": [
            "deprecatedKey"
        ]
    },
    {
        "code": "@Test\npublic void testNoGcAtStop() throws Exception {\n    brokerService = createBroker(false);\n    brokerService.start();\n    produceWithScheduledDelayAndConsume();\n    LOG.info(\"job store: \" + jobSchedulerStore);\n    int numSchedulerFiles = jobSchedulerStore.getJournal().getFileMap().size();\n    LOG.info(\"kahadb store: \" + kahaDBPersistenceAdapter);\n    int numKahadbFiles = kahaDBPersistenceAdapter.getStore().getJournal().getFileMap().size();",
        "pred_variables": [
            "numKahadbFiles"
        ],
        "label_variables": [
            "numKahadbFiles"
        ]
    },
    {
        "code": "@Override\npublic void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain) throws IOException, ServletException {\n    var request = validateRequestType(servletRequest);\n    var response = validateResponseType(servletResponse);\n    var path = request.getContextPath() + (request.getPathInfo() == null ? \"\" : request.getPathInfo());\n    if (blacklisted(path)) {",
        "pred_variables": [
            "var",
            "request",
            "chain",
            "servletResponse",
            "path",
            "servletRequest"
        ],
        "label_variables": [
            "path"
        ]
    },
    {
        "code": "public void onPlayStatus(IConnection conn, Map<Object, Object> info) {",
        "pred_variables": [
            "info",
            "Object",
            "conn"
        ],
        "label_variables": [
            "info"
        ]
    },
    {
        "code": "private void checkArm(WebDriverManager wdm) {\n    wdm.arch64().setup();\n    String driverPath = wdm.getDownloadedDriverPath();",
        "pred_variables": [
            "setup"
        ],
        "label_variables": [
            "driverPath"
        ]
    },
    {
        "code": "@Override\npublic void doParse(InputStream input, String baseUri, RDFNotation notation, boolean keepBNode, RDFCallback callback) throws ParserException {\n    try {\n        final TarArchiveInputStream debInputStream = (TarArchiveInputStream) new ArchiveStreamFactory().createArchiveInputStream(\"tar\", input);\n        TarArchiveEntry entry = null;\n        // Make sure that the parser does not close the Tar Stream so we can read the rest of the files.\n        NonCloseInputStream nonCloseIn = new NonCloseInputStream(debInputStream);\n        while ((entry = (TarArchiveEntry) debInputStream.getNextEntry()) != null) {\n            if (entry.isFile() && !entry.getName().contains(\"DS_Store\")) {\n                try {\n                    RDFNotation guessnot = RDFNotation.guess(entry.getName());",
        "pred_variables": [
            "nonCloseIn",
            "entry",
            "DS_Store"
        ],
        "label_variables": [
            "guessnot"
        ]
    },
    {
        "code": "@Override\npublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n    String contextPath = request.getServletContext().getContextPath();",
        "pred_variables": [
            "String"
        ],
        "label_variables": [
            "contextPath"
        ]
    },
    {
        "code": "public void doStart() throws Exception {\n    HashSet<StaticMember> staticMemberCollection = new HashSet<StaticMember>();\n    log.debug(\"Attempting to set static members\");\n    if (staticMember != null) {\n        log.debug(\"Attempting to add static member: {}\", ((StaticMember) staticMember.getStaticMember()).getPort());\n        staticMemberCollection.add((StaticMember) staticMember.getStaticMember());\n        WadiStaticMember nextStaticMember = (WadiStaticMember) staticMember.getNextStaticMember();\n        while (nextStaticMember != null) {\n            log.debug(\"Attempting to add static member: {}\", ((StaticMember) staticMember.getStaticMember()).getPort());\n            staticMemberCollection.add((StaticMember) nextStaticMember.getStaticMember());\n            nextStaticMember = (WadiStaticMember) nextStaticMember.getNextStaticMember();\n        }\n    }",
        "pred_variables": [
            "staticMemberCollection"
        ],
        "label_variables": [
            "staticMemberCollection"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"victoriametrics\")\npublic ToxiproxyContainer.ContainerProxy victoriaMetricsContainerProxy(ToxiproxyContainer toxiproxy, GenericContainer<?> victoriametrics, VictoriaMetricsProperties properties, ConfigurableEnvironment environment) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxy.getProxy(victoriametrics, properties.getPort());\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.victoriametrics.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.victoriametrics.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.victoriametrics.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedVictoriaMetricsToxiProxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "@ParameterizedTest\n@ValueSource(strings = { \"chrome\", \"firefox\" })\nvoid testInteractive(String browser) {\n    assertTimeout(ofMinutes(5), () -> {\n        ByteArrayInputStream intro = new ByteArrayInputStream(\"\\r\\n\".getBytes());\n        System.setIn(intro);",
        "pred_variables": [
            "intro"
        ],
        "label_variables": [
            "browser"
        ]
    },
    {
        "code": "@ParameterizedTest\n@EnumSource(names = { \"WIN\", \"LINUX\", \"MAC\" })\nvoid testForceOs(OperatingSystem operatingSystem) {\n    switch(operatingSystem) {\n        case WIN:\n            wdm.win().setup();\n            break;\n        case LINUX:\n            wdm.linux().setup();\n            break;\n        case MAC:\n            wdm.mac().setup();\n            break;\n    }\n    File driver = new File(wdm.getDownloadedDriverPath());",
        "pred_variables": [
            "setup",
            "wdm"
        ],
        "label_variables": [
            "driver",
            "operatingSystem"
        ]
    },
    {
        "code": "            QueueConnection qConnection = null;\n            QueueSession qSession = null;\n            QueueBrowser qBrowser = null;\n            try {\n                qConFactory = (QueueConnectionFactory) kernel.invoke(JCA_MANAGED_CONNECTION_FACTORY_NAME, \"$getResource\");\n                qConnection = qConFactory.createQueueConnection();\n                qSession = qConnection.createQueueSession(false, QueueSession.AUTO_ACKNOWLEDGE);\n                qBrowser = qSession.createBrowser(queue);\n                qConnection.start();\n                for (Enumeration e = qBrowser.getEnumeration(); e.hasMoreElements(); ) {\n                    Object o = e.nextElement();\n                    ret.add(o);\n                }\n                qConnection.stop();\n            } catch (Exception e) {",
        "pred_variables": [
            "getEnumeration"
        ],
        "label_variables": [
            "e"
        ]
    },
    {
        "code": "//----- WebSocket callback handlers --------------------------------------//\n@Override\npublic void onWebSocketText(String data) {\n    if (data == null) {\n        return;\n    }\n    if (data.equals(\"\\n\")) {\n        LOG.debug(\"New incoming heartbeat read\");\n    } else {",
        "pred_variables": [
            "data"
        ],
        "label_variables": [
            "data"
        ]
    },
    {
        "code": "private void registerEnvironment(GenericContainer<?> victoriaMetrics, ConfigurableEnvironment environment, VictoriaMetricsProperties properties) {\n    Integer mappedPort = victoriaMetrics.getMappedPort(properties.port);\n    String host = victoriaMetrics.getHost();\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.victoriametrics.host\", host);\n    map.put(\"embedded.victoriametrics.port\", mappedPort);",
        "pred_variables": [
            "host",
            "properties",
            "mappedPort",
            "getHost",
            "port"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "@Test(groups = \"wso2.esb\", description = \"Tests level log\")\npublic void testSendingToDefinedEndpoint() throws Exception {\n    OMElement response = axis2Client.sendSimpleStockQuoteRequest(getProxyServiceURLHttp(\"logMediatorLevelTestProxy\"), null, \"WSO2\");\n    Assert.assertTrue(response.toString().contains(\"WSO2\"));",
        "pred_variables": [
            "response",
            "Assert",
            "toString"
        ],
        "label_variables": [
            "response"
        ]
    },
    {
        "code": "@Override\npublic void recoveryCleanupFailed(Path indexFile, IndexDescriptor index, Throwable throwable) {",
        "pred_variables": [
            "indexFile",
            "throwable",
            "index"
        ],
        "label_variables": [
            "throwable",
            "indexFile",
            "index"
        ]
    },
    {
        "code": "public static Client create(Path socketPath) throws IOException {\n    var address = UnixDomainSocketAddress.of(socketPath);\n    var socketChannel = SocketChannel.open(address);",
        "pred_variables": [
            "socketPath"
        ],
        "label_variables": [
            "socketPath"
        ]
    },
    {
        "code": "private void shutdown(String reason) {\n    if (null != reason) {",
        "pred_variables": [
            "reason"
        ],
        "label_variables": [
            "reason"
        ]
    },
    {
        "code": "@Test\npublic void testValidateFromYouTube() {\n    log.info(\"\\ntestValidateFromYouTube\");\n    // client side handshake handler\n    OutboundHandshake out = new OutboundHandshake();\n    // server response\n    IoBuffer y = IoBuffer.allocate(0);\n    y.setAutoExpand(true);\n    y.put(IOUtils.hexStringToByteArray(youtubeS1));\n    y.flip();",
        "pred_variables": [
            "y"
        ],
        "label_variables": [
            "y"
        ]
    },
    {
        "code": " * @param targetStore\n *      The JobSchedulerStore that will receive the replay events from the legacy store.\n *\n * @throws IOException if an error occurs during replay of the legacy store.\n */\npublic void startReplay(JobSchedulerStoreImpl targetStore) throws IOException {\n    checkLoaded();\n    if (targetStore == null) {\n        throw new IOException(\"Cannot replay to a null store\");\n    }\n    try {\n        Set<String> schedulers = store.getJobSchedulerNames();\n        if (!schedulers.isEmpty()) {\n            for (String name : schedulers) {\n                LegacyJobSchedulerImpl scheduler = store.getJobScheduler(name);",
        "pred_variables": [
            "name"
        ],
        "label_variables": [
            "name"
        ]
    },
    {
        "code": "@Override\npublic void run() {\n    try {\n        String name = THREAD_NAME_PREFIX + Thread.currentThread().getName();",
        "pred_variables": [
            "name",
            "getName"
        ],
        "label_variables": [
            "name"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"azurite\")\nToxiproxyContainer.ContainerProxy azuriteQueueContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(AZURITE_BEAN_NAME) GenericContainer<?> azurite, AzuriteProperties properties, ConfigurableEnvironment environment) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(azurite, properties.getQueueStoragePort());\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.azurite.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.azurite.toxiproxy.queueStoragePor\", proxy.getProxyPort());\n    map.put(\"embedded.azurite.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedAzuriteQueueToxiproxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [
            "module"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "@Test\npublic void testVerifyAntifakeCode() throws InterruptedException, ExecutionException, TimeoutException, IOException {\n    log.info(\"best block height {}\", network.getBestBlockHeight());\n    String antifakeCodeContent = \"xFdeHFv8RsHn6PHYRE8JTDLwRKPRe7mcej2R5c\";\n    VerifyAntifakeCodeResult result = accountKit.verifyAntifakeCode(antifakeCodeContent);",
        "pred_variables": [
            "result"
        ],
        "label_variables": [
            "result"
        ]
    },
    {
        "code": "// TODO deduplicate MainWindowController...\nprivate void addOrRevealVault(Path potentialVaultPath) {\n    assert Platform.isFxApplicationThread();\n    try {\n        final Vault v;\n        if (potentialVaultPath.getFileName().toString().endsWith(CRYPTOMATOR_FILENAME_EXT)) {\n            v = vaultListManager.add(potentialVaultPath.getParent());\n        } else {\n            v = vaultListManager.add(potentialVaultPath);\n        }\n        if (v.isUnlocked()) {\n            vaultService.reveal(v);\n        }",
        "pred_variables": [
            "v",
            "potentialVaultPath"
        ],
        "label_variables": [
            "potentialVaultPath"
        ]
    },
    {
        "code": "private void registerVerticaEnvironment(GenericContainer<?> verticaContainer, ConfigurableEnvironment environment, VerticaProperties properties) {\n    Integer mappedPort = verticaContainer.getMappedPort(properties.getPort());\n    String host = verticaContainer.getHost();\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.vertica.port\", mappedPort);\n    map.put(\"embedded.vertica.host\", host);\n    map.put(\"embedded.vertica.database\", properties.getDatabase());\n    map.put(\"embedded.vertica.user\", properties.getUser());\n    map.put(\"embedded.vertica.password\", properties.getPassword());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedVerticaInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [
            "getHost",
            "mappedPort",
            "vertica"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "public void copySavedReport(String saved, String copy) throws Exception {\n    try {\n        reportingAdminServiceStub.copySavedReport(saved, copy);\n    } catch (Exception e) {\n        String msg = \"Unable to copy the report\";",
        "pred_variables": [
            "msg"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "public List<File> filterCacheBy(List<File> input, String key, boolean isVersion) {\n    String pathSeparator = isVersion ? separator : \"\";\n    List<File> output = new ArrayList<>(input);\n    if (!key.isEmpty() && !input.isEmpty()) {\n        output = input.stream().filter(file -> file.toString().toLowerCase(ROOT).contains(pathSeparator + key.toLowerCase(ROOT))).collect(toList());\n    }",
        "pred_variables": [
            "key",
            "input",
            "output"
        ],
        "label_variables": [
            "output",
            "input",
            "key"
        ]
    },
    {
        "code": "@Override\npublic Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable<?, ?> environment) throws Exception {\n    try {\n        // For Tomcat, obj will always be an object of type Reference\n        Reference ref = (Reference) obj;\n        String objectName = name.toString();\n        String targetClassName = ref.getClassName();\n        //Class targetClass = Class.forName(targetClassName);",
        "pred_variables": [
            "name",
            "ref"
        ],
        "label_variables": [
            "targetClassName",
            "objectName"
        ]
    },
    {
        "code": "private void assertDriver(WebDriverManager wdm) {\n    File driver = new File(wdm.getDownloadedDriverPath());",
        "pred_variables": [
            "wdm",
            "driver"
        ],
        "label_variables": [
            "driver"
        ]
    },
    {
        "code": "    parser.getInterpreter().setPredictionMode(PredictionMode.SLL);\n    parser.removeErrorListeners();\n    parser.addErrorListener(errorListener);\n    GremlinParser.QueryListContext queryContext;\n    try {\n        queryContext = parser.queryList();\n    } catch (Exception ex) {\n        // Retry parsing the query again with using LL prediction mode.  LL parsing mode is more powerful\n        // so retrying the parsing would help parsing the rare edge cases.\n        try {\n            // rewind input stream\n            tokens.seek(0);\n            lexer.reset();\n            parser.reset();\n            parser.getInterpreter().setPredictionMode(PredictionMode.LL);",
        "pred_variables": [
            "queryContext",
            "PredictionMode",
            "LL"
        ],
        "label_variables": [
            "query"
        ]
    },
    {
        "code": "@Override\npublic void log(Request request, Response response) {\n    // Trying to replicate this logback pattern:\n    // %h %l %user [%t{dd/MMM/yyyy:HH:mm:ss Z}] \"%r\" %s %b \"%i{Referer}\" \"%i{User-Agent}\" %D\n    String remoteHost = swallowExceptions(request, HttpServletRequest::getRemoteHost);\n    String user = swallowExceptions(request, HttpServletRequest::getRemoteUser);\n    String requestURL = findRequestURI(request);\n    int statusCode = response.getStatus();\n    long length = response.getContentLength();\n    String referer = swallowExceptions(request, r -> r.getHeader(\"Referer\"));\n    String userAgent = swallowExceptions(request, r -> r.getHeader(\"User-Agent\"));\n    long requestTimeStamp = request != null ? request.getTimeStamp() : -1;\n    long now = System.currentTimeMillis();\n    long serviceTime = requestTimeStamp < 0 ? -1 : now - requestTimeStamp;",
        "pred_variables": [
            "request",
            "serviceTime",
            "user",
            "HH"
        ],
        "label_variables": [
            "referer",
            "remoteHost",
            "requestURL",
            "now",
            "length",
            "userAgent",
            "serviceTime",
            "user",
            "statusCode"
        ]
    },
    {
        "code": "protected CustomEntry getEntryByDn(String dn, String... ldapReturnAttributes) {\n    try {\n        return ldapEntryManager.find(dn, CustomEntry.class, ldapReturnAttributes);\n    } catch (EntryPersistenceException epe) {",
        "pred_variables": [
            "dn",
            "ldapReturnAttributes"
        ],
        "label_variables": [
            "dn"
        ]
    },
    {
        "code": "public String[] getMandatoryAttributeNames(String className) throws Exception {\n    try {\n        return reportingAdminServiceStub.getMandatoryAttributeNames(className);\n    } catch (Exception e) {\n        String msg = \"Unable to get mandatory attribute names\";",
        "pred_variables": [
            "msg"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "private static void handleStorage(RedisAPI redisAPI, final String redisKey, int ttl, final Handler<Boolean> callback) {\n    // read from storage\n    redisAPI.get(redisKey, reply -> {\n        if (reply.failed()) {",
        "pred_variables": [
            "ttl",
            "redisKey",
            "Boolean"
        ],
        "label_variables": [
            "redisKey"
        ]
    },
    {
        "code": "public <Q> DeferredChanged<Q> flatMap(Function<Optional<T>, DeferredChanged<Q>> function) {\n    if (valueSet) {\n        DeferredChanged<Q> nextDeferred = function.apply(this.valueOptional);",
        "pred_variables": [
            "flatMap"
        ],
        "label_variables": [
            "function"
        ]
    },
    {
        "code": "        String contentType = msgContext.getProperty(MESSAGE_TYPE).toString();\n        if (log.isDebugEnabled()) {\n            log.debug(\"Message content type retrieved in the message is: \" + contentType);\n        }\n        if (contentType.equalsIgnoreCase(InboundGRPCConstants.CONTENT_TYPE_JSON_MIME_TYPE)) {\n            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(JsonUtil.getJsonPayload(msgContext)));\n            StringBuilder stringBuilder = new StringBuilder();\n            String line;\n            try {\n                while ((line = bufferedReader.readLine()) != null) {\n                    stringBuilder.append(line);\n                }\n                content = stringBuilder.toString();\n            } catch (IOException e) {\n                String msg = \"Error occurred while converting payload to json. \" + e.getMessage();",
        "pred_variables": [
            "msg"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {\n    for (int i = 0; i < callbacks.length; i++) {\n        if (callbacks[i] instanceof DelegationCallback) {\n            DelegationCallback callback = (DelegationCallback) callbacks[i];\n            Element token = SecurityTokenThreadLocal.getToken();\n            if (token == null) {",
        "pred_variables": [
            "i",
            "token"
        ],
        "label_variables": [
            "token"
        ]
    },
    {
        "code": "@Override\nprotected boolean isReady() {\n    String containerId = waitStrategyTarget.getContainerId();",
        "pred_variables": [
            "containerId",
            "getContainerId"
        ],
        "label_variables": [
            "containerId"
        ]
    },
    {
        "code": "@Override\npublic void visitSignedLong(String name, long id, long value) {",
        "pred_variables": [
            "id",
            "name"
        ],
        "label_variables": [
            "name"
        ]
    },
    {
        "code": "private void registerStorageEnvironment(GenericContainer<?> container, ConfigurableEnvironment environment, StorageProperties properties) {\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.google.storage.host\", container.getHost());\n    map.put(\"embedded.google.storage.port\", container.getMappedPort(StorageProperties.PORT));\n    map.put(\"embedded.google.storage.endpoint\", buildContainerEndpoint(container));\n    map.put(\"embedded.google.storage.project-id\", properties.getProjectId());\n    map.put(\"embedded.google.storage.bucket-location\", properties.getBucketLocation());",
        "pred_variables": [
            "location",
            "container"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "@Override\npublic void visit(LockType lockType, ResourceType resourceType, long transactionId, long resourceId, String description, long estimatedWaitTime, long lockIdentityHashCode) {",
        "pred_variables": [
            "estimatedWaitTime",
            "lockType",
            "transactionId",
            "resourceType",
            "resourceId",
            "lockIdentityHashCode"
        ],
        "label_variables": [
            "resourceId",
            "lockIdentityHashCode",
            "estimatedWaitTime",
            "description",
            "transactionId",
            "resourceType"
        ]
    },
    {
        "code": "private static RuleSet toRuleSet(ServerApi serverApi, Map<String, RuleSet> currentRuleSets, QualityProfile profile, boolean forceUpdate, ProgressMonitor progressMonitor) {\n    var language = profile.getLanguage();\n    if (forceUpdate || newlySupportedLanguage(currentRuleSets, language) || profileModifiedSinceLastSync(currentRuleSets, profile, language)) {\n        var profileKey = profile.getKey();",
        "pred_variables": [
            "currentRuleSets",
            "profile"
        ],
        "label_variables": [
            "profileKey",
            "language"
        ]
    },
    {
        "code": "@Override\npublic Response toResponse(Throwable exception) {\n    try {\n        if (exception instanceof WebApplicationException) {\n            final Response response = ((WebApplicationException) exception).getResponse();\n            if (response != null && response.getStatus() > 0) {\n                return response;\n            }\n        }",
        "pred_variables": [
            "response",
            "exception"
        ],
        "label_variables": [
            "exception"
        ]
    },
    {
        "code": "    }\n    URL resourceURL;\n    File f = new File(resourcePath);\n    if (f.isFile()) {\n        resourceURL = f.toURI().toURL();\n    } else {\n        resourceURL = ZipResourceExtractor.class.getResource(resourcePath);\n    }\n    if (resourceURL == null) {\n        throw new NullPointerException(\"Could not retrieve resource for path: \" + resourcePath);\n    }\n    try (InputStream resourceInputStream = resourceURL.openStream()) {\n        try {\n            String outname = new File(resourceURL.getPath()).getName();\n            outname = outname.replaceAll(\"%20\", \" \");",
        "pred_variables": [],
        "label_variables": [
            "outname"
        ]
    },
    {
        "code": "public void abortConsumer(ObjectName consumerToAbort) {\n    Subscription sub = broker.getSubscriber(consumerToAbort);\n    if (sub != null) {\n        LOG.info(\"aborting consumer via jmx: {}\", sub.getConsumerInfo().getConsumerId());\n        strategy.abortConsumer(sub, false);\n    } else {",
        "pred_variables": [
            "consumerToAbort"
        ],
        "label_variables": [
            "consumerToAbort"
        ]
    },
    {
        "code": "    if (e instanceof RenderTemplateException) {\n        RenderTemplateException render = (RenderTemplateException) e;\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        Capability capability = render.getCapability();\n        if (capability instanceof FormCapability) {\n            try {\n                mediaTypeHandlerContainer.write(out, mediaTypeHandler.accept(), FormCapability.class, (FormCapability) capability);\n            } catch (IOException e1) {\n                throw new RuntimeException(e1);\n            }\n        }\n        return new Response(render.getCode(), new String(out.toByteArray()));\n    } else if (e instanceof AbstractHtmlException) {\n        return new Response(((AbstractHtmlException) e).getCode(), e.getMessage());\n    } else {",
        "pred_variables": [
            "capability",
            "e"
        ],
        "label_variables": [
            "e"
        ]
    },
    {
        "code": "@Test\nvoid test() {\n    String sutUrl = \"https://bonigarcia.dev/selenium-webdriver-java/\";\n    driver.get(sutUrl);\n    String title = driver.getTitle();",
        "pred_variables": [],
        "label_variables": [
            "sutUrl",
            "title"
        ]
    },
    {
        "code": "@Override\npublic void failed(Exception e) {",
        "pred_variables": [
            "e"
        ],
        "label_variables": [
            "e"
        ]
    },
    {
        "code": "        jc.usage();\n        System.exit(-1);\n    }\n    if (arguments.help) {\n        jc.usage();\n        System.exit(-1);\n    }\n    Configuration conf = new CompositeConfiguration();\n    conf.setProperty(Stats.STATS_PROVIDER_CLASS, PrometheusMetricsProvider.class.getName());\n    conf.setProperty(\"prometheusStatsHttpPort\", arguments.statsPort);\n    Stats.loadStatsProvider(conf);\n    StatsProvider provider = Stats.get();\n    provider.start(conf);\n    Runtime.getRuntime().addShutdownHook(new Thread(() -> provider.stop(), \"benchmark-worker-shutdown-thread\"));\n    // Dump configuration variables",
        "pred_variables": [],
        "label_variables": [
            "arguments"
        ]
    },
    {
        "code": "public void testElementToTypeMapping() throws Exception {\n    File schema1 = new File(BASEDIR, \"src/test/resources/schema/schema4.xsd\");\n    log.debug(\"SCHEMA 4\");\n    Map map = parse(schema1);\n    assertEquals(3, map.size());\n    Map elements = schemaInfoBuilder.getElementToTypeMap();\n    log.debug(\"ELEMENT MAP\");",
        "pred_variables": [
            "xsd",
            "schema1"
        ],
        "label_variables": [
            "elements"
        ]
    },
    {
        "code": "private void log(String s) {\n    s = s.strip();\n    switch(level) {\n        case INFO ->",
        "pred_variables": [
            "s",
            "strip"
        ],
        "label_variables": [
            "s"
        ]
    },
    {
        "code": "@Test(timeout = 120 * 1000)\npublic void testRecoverWhenSomeLogsAreMissing() throws Exception {\n    fillUpSomeLogFiles();\n    int jobCount = schedulerStore.getJobScheduler(\"JMS\").getAllJobs().size();",
        "pred_variables": [
            "jobCount"
        ],
        "label_variables": [
            "jobCount"
        ]
    },
    {
        "code": "@ParameterizedTest\n@EnumSource(names = { \"DEFAULT\", \"X32\", \"X64\" })\nvoid testLatestVersion(Architecture architecture) throws Exception {\n    WebDriverManager wdm = WebDriverManager.getInstance(driverClass);\n    String osLabel = \"\";\n    if (os != null) {\n        wdm.operatingSystem(os);\n        osLabel = \" os=\" + os;\n    }\n    if (architecture != DEFAULT) {\n        wdm.architecture(architecture);\n    }",
        "pred_variables": [
            "wdm"
        ],
        "label_variables": [
            "osLabel",
            "architecture"
        ]
    },
    {
        "code": "private void createTopic(TopicConfiguration topicConfiguration) {\n    String topic = topicConfiguration.getTopic();\n    int partitions = topicConfiguration.getPartitions();\n    String containerBrokerList = format(\"%s:%d\", KAFKA_HOST_NAME, kafkaProperties.getInternalBrokerPort());\n    String[] createTopicCmd = getCreateTopicCmd(topic, partitions, containerBrokerList);\n    Container.ExecResult execResult = executeInContainer(this.kafka, createTopicCmd);",
        "pred_variables": [
            "ExecResult",
            "kafkaProperties",
            "getTopic"
        ],
        "label_variables": [
            "execResult",
            "topic",
            "createTopicCmd"
        ]
    },
    {
        "code": "@Test\nvoid edgeVersionTest() throws Exception {\n    Config config = new Config();\n    HttpClient httpClient = new HttpClient(config);\n    VersionDetector versionDetector = new VersionDetector(config, httpClient);\n    Optional<String> driverVersion = Optional.empty();\n    URL driverUrl = new URL(\"https://msedgedriver.azureedge.net/\");\n    Charset versionCharset = UTF_16;\n    String driverName = \"msedgedriver\";\n    String versionLabel = \"LATEST_STABLE\";\n    Optional<String> osLabel = Optional.empty();\n    Optional<String> driverVersionFromRepository = versionDetector.getDriverVersionFromRepository(driverVersion, driverUrl, versionCharset, driverName, versionLabel, versionLabel, osLabel);\n    assertThat(driverVersionFromRepository).isPresent();\n    String edgeVersion = driverVersionFromRepository.get();",
        "pred_variables": [],
        "label_variables": [
            "edgeVersion"
        ]
    },
    {
        "code": "public Response requestRpt(String grantType, String ticket, String claimToken, String claimTokenFormat, String pctCode, String rptCode, String scope, HttpServletRequest httpRequest, HttpServletResponse httpResponse) {\n    try {",
        "pred_variables": [
            "claimToken",
            "String",
            "scope",
            "pctCode"
        ],
        "label_variables": [
            "pctCode",
            "ticket",
            "claimToken",
            "rptCode",
            "scope",
            "grantType",
            "claimTokenFormat"
        ]
    },
    {
        "code": "protected ExtendedSelenium createSeleniumClient(String url) throws Exception {\n    super.setUp();\n    if (url == null) {\n        // url = \"http://localhost:\" + SeleniumServer.DEFAULT_PORT;\n        // post 1.0-beta-1 builds don't define DEFAULT_PORT\n        url = \"http://localhost:4444\";\n    }\n    String browser = System.getProperty(\"browser\", \"*firefox\");",
        "pred_variables": [
            "url"
        ],
        "label_variables": [
            "browser",
            "url"
        ]
    },
    {
        "code": "@GET\n@Path(\"/session_status\")\n@Produces({ MediaType.APPLICATION_JSON })\npublic Response requestCheckSessionStatus(@Context HttpServletRequest httpRequest, @Context HttpServletResponse httpResponse, @Context SecurityContext securityContext) throws IOException {\n    String sessionIdCookie = cookieService.getSessionIdFromCookie(httpRequest);",
        "pred_variables": [
            "Context",
            "httpRequest",
            "securityContext"
        ],
        "label_variables": [
            "sessionIdCookie"
        ]
    },
    {
        "code": "        return;\n    } else if (!validPassword(password)) {\n        passwordId.requestFocus();\n        DailogUtil.showTipDailogCenter(\"\u5bc6\u7801\u9519\u8bef\", getThisStage());\n        return;\n    }\n    //\u89e3\u5bc6\u94b1\u5305\u5e76\u5224\u65ad\u7ed3\u679c\n    AccountKit accountKit = InchainInstance.getInstance().getAccountKit();\n    Result result = accountKit.decryptAccount(password, null, 2);\n    if (result.isSuccess()) {\n        resetAndclose();\n        if (callback != null) {\n            callback.ok(null);\n        }\n    } else {",
        "pred_variables": [
            "getInstance"
        ],
        "label_variables": [
            "result"
        ]
    },
    {
        "code": "@Override\npublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n    if (failed || isShuttingDown(ctx)) {\n        return;\n    }\n    // log only the first exception to not pollute the log\n    failed = true;\n    try {\n        // Netty throws a NativeIoException on connection reset - directly importing that class\n        // caused a host of linking errors, because it depends on JNI to work. Hence, we just\n        // test on the message we know we'll get.\n        if (Exceptions.contains(cause, e -> e.getMessage() != null && e.getMessage().contains(\"Connection reset by peer\"))) {\n            log.warn(\"Fatal error occurred when handling a client connection, \" + \"remote peer unexpectedly closed connection: %s\", ctx.channel());\n        } else {",
        "pred_variables": [
            "error",
            "e",
            "cause",
            "peer"
        ],
        "label_variables": [
            "cause"
        ]
    },
    {
        "code": "@Override\npublic Response deviceAuthorization(String clientId, String scope, HttpServletRequest httpRequest, HttpServletResponse httpResponse, SecurityContext securityContext) {\n    // it may be encoded\n    scope = ServerUtil.urlDecode(scope);\n    OAuth2AuditLog oAuth2AuditLog = new OAuth2AuditLog(ServerUtil.getIpAddress(httpRequest), Action.DEVICE_CODE_AUTHORIZATION);\n    oAuth2AuditLog.setClientId(clientId);\n    oAuth2AuditLog.setScope(scope);\n    try {",
        "pred_variables": [
            "clientId",
            "scope",
            "securityContext"
        ],
        "label_variables": [
            "clientId",
            "scope"
        ]
    },
    {
        "code": "public Optional<ServerProject> getSonarProject(String connectionId, String sonarProjectKey) {\n    try {\n        return singleProjectsCache.get(new SonarProjectKey(connectionId, sonarProjectKey), () -> {",
        "pred_variables": [
            "get",
            "String"
        ],
        "label_variables": [
            "connectionId",
            "sonarProjectKey"
        ]
    },
    {
        "code": "                String name = destination.getString(\"name\");\n                Map<String, String> options = new HashMap<>();\n                options.put(\"type\", destination.getString(\"type\"));\n                String typeLocation = null;\n                if (destination.getString(\"type\").equalsIgnoreCase(\"file\")) {\n                    typeLocation = \"file\";\n                } else if (destination.getString(\"type\").equalsIgnoreCase(\"eventBus\")) {\n                    typeLocation = \"address\";\n                    options.put(\"metadata\", StringUtils.getStringOrEmpty(destination.getString(\"metadata\")));\n                    options.put(\"transmission\", StringUtils.getStringOrDefault(destination.getString(\"transmission\"), \"publish\"));\n                }\n                if (typeLocation != null) {\n                    options.put(typeLocation, destination.getString(typeLocation));\n                    destinationEntries.put(name, options);\n                } else {",
        "pred_variables": [
            "destination",
            "typeLocation",
            "name",
            "type"
        ],
        "label_variables": [
            "name"
        ]
    },
    {
        "code": "@Override\npublic Appendable targetUTF8(String name, long id) {",
        "pred_variables": [
            "id",
            "name"
        ],
        "label_variables": [
            "name"
        ]
    },
    {
        "code": "@POST\n@Path(\"/revoke_session\")\n@Produces({ MediaType.APPLICATION_JSON })\npublic Response requestRevokeSession(@FormParam(\"user_criterion_key\") String userCriterionKey, @FormParam(\"user_criterion_value\") String userCriterionValue, @Context HttpServletRequest request, @Context HttpServletResponse response, @Context SecurityContext sec) {\n    try {",
        "pred_variables": [
            "userCriterionValue",
            "user_criterion_key"
        ],
        "label_variables": [
            "userCriterionValue",
            "userCriterionKey"
        ]
    },
    {
        "code": "    if (upToDate(serverPlugin, storedPluginsByKey)) {\n        LOG.debug(\"[SYNC] Code analyzer '{}' is up-to-date. Skip downloading it.\", serverPlugin.getKey());\n        return false;\n    }\n    if (!serverPlugin.isSonarLintSupported()) {\n        LOG.debug(\"[SYNC] Code analyzer '{}' does not support SonarLint. Skip downloading it.\", serverPlugin.getKey());\n        return false;\n    }\n    if (sonarSourceDisabledPluginKeys.contains(serverPlugin.getKey())) {\n        LOG.debug(\"[SYNC] Code analyzer '{}' is disabled in SonarLint (language not enabled). Skip downloading it.\", serverPlugin.getKey());\n        return false;\n    }\n    var pluginVersion = VersionUtils.getJarVersion(serverPlugin.getFilename());\n    if (!pluginsMinVersions.isVersionSupported(serverPlugin.getKey(), pluginVersion)) {\n        var minimumVersion = pluginsMinVersions.getMinimumVersion(serverPlugin.getKey());",
        "pred_variables": [
            "var",
            "getMinimumVersion"
        ],
        "label_variables": [
            "pluginVersion",
            "minimumVersion"
        ]
    },
    {
        "code": "private static void handleException(String msg, Throwable throwable) {",
        "pred_variables": [
            "msg",
            "throwable"
        ],
        "label_variables": [
            "msg",
            "throwable"
        ]
    },
    {
        "code": "@Override\npublic TrustedIdpProtocolHandler getProtocolHandler(String protocol) {\n    for (TrustedIdpProtocolHandler protocolHandler : protocolHandlers) {\n        if (protocolHandler.getProtocol().equals(protocol)) {\n            return protocolHandler;\n        }\n    }",
        "pred_variables": [
            "protocolHandler"
        ],
        "label_variables": [
            "protocol"
        ]
    },
    {
        "code": "@Override\npublic void exec(int executionCounter) {\n    List<String> args = RedisUtils.toPayload(luaScriptState.getSha(), keys.size(), keys, arguments);\n    redisAPI.evalsha(args, event -> {\n        if (event.succeeded()) {\n            Response response = event.result();\n            if (response != null && response.size() != 0) {\n                promise.complete(response);\n            } else {\n                promise.complete(MultiType.EMPTY_MULTI);\n            }\n        } else {\n            String message = event.cause().getMessage();\n            if (message != null && message.startsWith(\"NOSCRIPT\")) {\n                log.warn(\"RemoveExpiredQueuesRedisCommand script couldn't be found, reload it\");",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "executionCounter"
        ]
    },
    {
        "code": "@Test\nvoid testCachePathStartsWithTildeSlash() {\n    String customPath = \"~/webdrivers\";\n    wdm.config().setCachePath(customPath);\n    String cachePath = wdm.config().getCachePath();",
        "pred_variables": [
            "wdm",
            "customPath"
        ],
        "label_variables": [
            "customPath",
            "cachePath"
        ]
    },
    {
        "code": "    final WorkloadGenerationTool.Arguments arguments = new WorkloadGenerationTool.Arguments();\n    JCommander jc = new JCommander(arguments);\n    jc.setProgramName(\"workload-generator\");\n    try {\n        jc.parse(args);\n    } catch (ParameterException e) {\n        System.err.println(e.getMessage());\n        jc.usage();\n        System.exit(-1);\n    }\n    if (arguments.help) {\n        jc.usage();\n        System.exit(-1);\n    }\n    // Dump configuration variables",
        "pred_variables": [
            "usage",
            "arguments"
        ],
        "label_variables": [
            "arguments"
        ]
    },
    {
        "code": "@Override\npublic JobMetadata getDeletedJobMetadata(String jobId) throws IOException, JobNotFoundException {",
        "pred_variables": [
            "jobId"
        ],
        "label_variables": [
            "jobId"
        ]
    },
    {
        "code": "@Override\npublic void partialRecovery(RecoveryPredicate recoveryPredicate, CommittedTransactionRepresentation lastTransaction) {",
        "pred_variables": [
            "recoveryPredicate",
            "lastTransaction"
        ],
        "label_variables": [
            "lastTransaction"
        ]
    },
    {
        "code": "@Override\npublic void onException(IOException error) {\n    synchronized (this) {\n        setHasExpired(true);\n        // only log if not stopped\n        if (!stopped.get()) {",
        "pred_variables": [
            "error"
        ],
        "label_variables": [
            "error"
        ]
    },
    {
        "code": "private void registerEnvironment(GenericContainer<?> azurite, ConfigurableEnvironment environment, AzuriteProperties properties) {\n    Integer mappedBlobStoragePort = azurite.getMappedPort(properties.getBlobStoragePort());\n    Integer mappedQueueStoragePort = azurite.getMappedPort(properties.getQueueStoragePort());\n    Integer mappedTableStoragePort = azurite.getMappedPort(properties.getTableStoragePort());\n    String host = azurite.getHost();\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.azurite.host\", host);\n    map.put(\"embedded.azurite.blobStoragePort\", mappedBlobStoragePort);\n    map.put(\"embedded.azurite.queueStoragePor\", mappedQueueStoragePort);\n    map.put(\"embedded.azurite.tableStoragePort\", mappedTableStoragePort);\n    map.put(\"embedded.azurite.account-name\", AzuriteProperties.ACCOUNT_NAME);\n    map.put(\"embedded.azurite.account-key\", AzuriteProperties.ACCOUNT_KEY);\n    map.put(\"embedded.azurite.blob-endpoint\", \"http://\" + host + \":\" + mappedBlobStoragePort + \"/\" + AzuriteProperties.ACCOUNT_NAME);\n    map.put(\"embedded.azurite.queue-endpoint\", \"http://\" + host + \":\" + mappedQueueStoragePort + \"/\" + AzuriteProperties.ACCOUNT_NAME);\n    map.put(\"embedded.azurite.table-endpoint\", \"http://\" + host + \":\" + mappedTableStoragePort + \"/\" + AzuriteProperties.ACCOUNT_NAME);",
        "pred_variables": [
            "mappedBlobStoragePort",
            "Integer",
            "AzuriteProperties"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "@Override\npublic CompletableFuture<Void> createTopic(String topic, int partitions) {\n    topic = cleanName(topic);",
        "pred_variables": [
            "topic"
        ],
        "label_variables": [
            "partitions",
            "topic"
        ]
    },
    {
        "code": "private void failed(Throwable e) {\n    while (e.getCause() != null && e.getClass() == RuntimeException.class) {\n        e = e.getCause();\n    }\n    setException(e);",
        "pred_variables": [
            "e"
        ],
        "label_variables": [
            "e"
        ]
    },
    {
        "code": "@Override\nprotected void setBatch(MessageId messageId) throws Exception {\n    if (LOG.isTraceEnabled()) {",
        "pred_variables": [
            "messageId"
        ],
        "label_variables": [
            "messageId"
        ]
    },
    {
        "code": "private boolean authorize(String username, String desiredRole) {\n    try {\n        String[] listOfRoles = MicroIntegratorSecurityUtils.getUserStoreManager().getRoleListOfUser(username);\n        if (LOG.isDebugEnabled()) {",
        "pred_variables": [
            "getUserStoreManager",
            "username",
            "desiredRole"
        ],
        "label_variables": [
            "listOfRoles"
        ]
    },
    {
        "code": "@Override\npublic void error(Throwable cause) {",
        "pred_variables": [
            "cause"
        ],
        "label_variables": [
            "cause"
        ]
    },
    {
        "code": "public HttpService getHttpService() throws Exception {\n    if (httpService == null) {\n        String msg = \"Before activating Carbon Core bundle, an instance of \" + HttpService.class.getName() + \" should be in existance\";",
        "pred_variables": [
            "msg",
            "bundle"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "public Optional<String> getDriverFromCache(String driverVersion, String driverName, DriverManagerType driverManagerType, Architecture arch, String os) {",
        "pred_variables": [
            "Architecture",
            "DriverManagerType",
            "driverManagerType"
        ],
        "label_variables": [
            "driverName"
        ]
    },
    {
        "code": "protected boolean addToAlreadyInterestedConsumers(ConsumerInfo info, boolean isForcedDurable) {\n    //If a network subscription and a queue check if isConduitNetworkQueueSubscriptions is true\n    //If true then we want to try and conduit\n    //For topics we always want to conduit regardless of network subscription or not\n    if (info.isNetworkSubscription() && info.getDestination().isQueue() && !configuration.isConduitNetworkQueueSubscriptions()) {\n        return false;\n    }\n    boolean matched = false;\n    // search through existing subscriptions and see if we have a match\n    for (DemandSubscription ds : subscriptionMapByLocalId.values()) {\n        DestinationFilter filter = DestinationFilter.parseFilter(ds.getLocalInfo().getDestination());\n        if (canConduit(ds) && filter.matches(info.getDestination())) {",
        "pred_variables": [
            "getDestination",
            "ds"
        ],
        "label_variables": [
            "info",
            "ds"
        ]
    },
    {
        "code": "@Override\npublic void dispatchEvent(IEvent event) {",
        "pred_variables": [
            "event"
        ],
        "label_variables": [
            "event"
        ]
    },
    {
        "code": "private void handleException(IOSession session, MLLPContext mllpContext, Exception e) {",
        "pred_variables": [
            "e"
        ],
        "label_variables": [
            "e"
        ]
    },
    {
        "code": "private static Predicate<? super SonarLintRuleDefinition> isExcludedByConfiguration(Set<String> excludedRules) {\n    return r -> {\n        if (excludedRules.contains(r.getKey())) {\n            return false;\n        }\n        for (String deprecatedKey : r.getDeprecatedKeys()) {\n            if (excludedRules.contains(deprecatedKey)) {",
        "pred_variables": [
            "deprecatedKey",
            "r",
            "getDeprecatedKeys"
        ],
        "label_variables": [
            "deprecatedKey"
        ]
    },
    {
        "code": "@Override\npublic void onSharedObjectDelete(ISharedObjectBase so, String arg1) {",
        "pred_variables": [
            "so",
            "arg1"
        ],
        "label_variables": [
            "arg1"
        ]
    },
    {
        "code": " * When the configuration resource contains invalid regex patterns, a warning will be logged and the corresponding\n * {@link ContentTypeConstraint} object will not be included in the returned list.\n *\n * @param constraintResourceBuffer the resource to create the {@link ContentTypeConstraint}s from\n * @return a list of {@link ContentTypeConstraint} objects\n */\nstatic List<ContentTypeConstraint> create(Buffer constraintResourceBuffer) {\n    List<ContentTypeConstraint> constraints = new ArrayList<>();\n    JsonObject config = constraintResourceBuffer.toJsonObject();\n    for (String urlPattern : config.fieldNames()) {\n        try {\n            Pattern pattern = Pattern.compile(urlPattern);\n            final List<PatternHolder> allowedTypes = extractAllowedTypes(config.getJsonObject(urlPattern));\n            if (!allowedTypes.isEmpty()) {\n                constraints.add(new ContentTypeConstraint(new PatternHolder(pattern.pattern()), allowedTypes));",
        "pred_variables": [
            "constraintResourceBuffer"
        ],
        "label_variables": [
            "urlPattern"
        ]
    },
    {
        "code": "String ofInstance(Object component, SonarLintLogger log) {\n    var key = component.toString();\n    if (IDENTITY_HASH_PATTERN.matcher(key).matches()) {\n        if (!objectsWithoutToString.add(component.getClass())) {",
        "pred_variables": [
            "key"
        ],
        "label_variables": [
            "key"
        ]
    },
    {
        "code": "public void putValueInResolutionCacheIfEmpty(String key, String value, int ttl) {\n    if (ttl > 0 && getValueFromResolutionCache(key) == null) {\n        props.put(key, value);\n        long now = new Date().getTime();\n        Date expirationDate = new Date(now + SECONDS.toMillis(ttl));\n        String expirationDateStr = formatDate(expirationDate);\n        props.put(getExpirationKey(key), expirationDateStr);\n        if (log.isDebugEnabled()) {",
        "pred_variables": [
            "key",
            "ttl"
        ],
        "label_variables": [
            "expirationDateStr",
            "value",
            "key"
        ]
    },
    {
        "code": "@Test\nvoid testCachePath() throws IOException {\n    Path tmpFolder = createTempDirectory(\"\").toRealPath();\n    wdm.config().setCachePath(tmpFolder.toString());",
        "pred_variables": [
            "tmpFolder"
        ],
        "label_variables": [
            "tmpFolder"
        ]
    },
    {
        "code": "@ParameterizedTest\n@ValueSource(strings = { \"chrome\", \"firefox\" })\nvoid test(String defaultBrowser) {\n    System.setProperty(\"wdm.defaultBrowser\", defaultBrowser);\n    wdm = WebDriverManager.getInstance();\n    driver = wdm.create();\n    String sutUrl = \"https://bonigarcia.dev/selenium-webdriver-java/\";\n    driver.get(sutUrl);\n    String title = driver.getTitle();",
        "pred_variables": [
            "wdm"
        ],
        "label_variables": [
            "sutUrl",
            "title"
        ]
    },
    {
        "code": "public String getSessionId(WebDriver webDriver) {\n    String sessionId = ((RemoteWebDriver) webDriver).getSessionId().toString();",
        "pred_variables": [
            "sessionId",
            "String",
            "toString",
            "webDriver"
        ],
        "label_variables": [
            "sessionId"
        ]
    },
    {
        "code": "protected void unregisterMBean(ObjectName name) {\n    if (name != null) {\n        try {\n            managementContext.unregisterMBean(name);\n        } catch (Throwable e) {",
        "pred_variables": [
            "name"
        ],
        "label_variables": [
            "name"
        ]
    },
    {
        "code": " * @param sourcePrincipal the principal in the source realm\n * @param targetRealm the target realm of the Principal\n * @return the principal in the target realm\n */\npublic Principal mapPrincipal(String sourceRealm, Principal sourcePrincipal, String targetRealm) {\n    if (sourcePrincipal == null) {\n        return null;\n    }\n    String name = sourcePrincipal.getName().toLowerCase();\n    if (name.contains(delimiter)) {\n        // Remove previous realm\n        name = name.substring(0, name.indexOf(delimiter));\n    }\n    // Add target realm\n    name = name + getDelimiter() + targetRealm;",
        "pred_variables": [
            "name",
            "target",
            "delimiter"
        ],
        "label_variables": [
            "name"
        ]
    },
    {
        "code": "@Test\nvoid test() {\n    String sutUrl = \"https://bonigarcia.dev/selenium-webdriver-java/\";\n    driver.get(sutUrl);\n    String title = driver.getTitle();",
        "pred_variables": [],
        "label_variables": [
            "sutUrl",
            "title"
        ]
    },
    {
        "code": "@Override\npublic JobScheduler getJobScheduler(String name) throws Exception {\n    this.lock.lock();\n    try {\n        InMemoryJobScheduler result = this.schedulers.get(name);\n        if (result == null) {",
        "pred_variables": [
            "name"
        ],
        "label_variables": [
            "name"
        ]
    },
    {
        "code": "private long getStateInitValue(final String lastId) {\n    long stateInitValue = 0L;\n    if (lastId != null) {\n        try {\n            stateInitValue = Long.parseLong(lastId) + 1;\n        } catch (NumberFormatException nfe) {",
        "pred_variables": [
            "lastId"
        ],
        "label_variables": [
            "lastId"
        ]
    },
    {
        "code": "private void registerEnvironment(GenericContainer<?> prometheus, ConfigurableEnvironment environment, PrometheusProperties properties) {\n    Integer mappedPort = prometheus.getMappedPort(properties.port);\n    String host = prometheus.getHost();\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.prometheus.host\", host);\n    map.put(\"embedded.prometheus.port\", mappedPort);",
        "pred_variables": [
            "host",
            "port",
            "mappedPort",
            "properties"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "public Xid[] recover(int arg0) throws XAException {\n    Xid[] answer = null;",
        "pred_variables": [
            "arg0"
        ],
        "label_variables": [
            "arg0"
        ]
    },
    {
        "code": "@Test\npublic void testSerialize() throws Exception {\n    TemporaryFolder folder = new TemporaryFolder();\n    folder.create();\n    File source = folder.newFile();\n    MessageTest.writeContentsToFile(source, testString);\n    Message in = new FileMessage(source, \"UTF-8\");\n    assertEquals(testStringLength, in.size());\n    byte[] wire = serializationTester.serialize(in);",
        "pred_variables": [],
        "label_variables": [
            "wire"
        ]
    },
    {
        "code": "    Iterator iterator = result.getChildrenWithLocalName(\"timeStamp\");\n    String timeStampString = null;\n    while (iterator.hasNext()) {\n        OMElement timeStamp = (OMElement) iterator.next();\n        if (timeStampString == null) {\n            timeStampString = timeStamp.getChildrenWithLocalName(\"testTimeStamp\").next().toString();\n            log.info(\"TimeStamp Recv:\" + timeStampString);\n            Assert.assertTrue(timeStampString.contains(\"1970-01-02T05:00:00.000+00:00\"));\n        } else {\n            String tempTimeStamp = timeStamp.getChildrenWithLocalName(\"testTimeStamp\").next().toString();\n            log.info(\"Timestamp Comapre:\" + timeStampString + \"|\" + tempTimeStamp);\n            Assert.assertFalse(timeStampString.equals(tempTimeStamp));\n        }\n    }\n    Assert.assertNotNull(result, \"Response message null \");",
        "pred_variables": [
            "result"
        ],
        "label_variables": [
            "result"
        ]
    },
    {
        "code": "@Override\npublic MessageProcessResult process(Message message, Peer peer) {\n    if (log.isDebugEnabled()) {",
        "pred_variables": [
            "message",
            "peer"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "/**\n * Checks if there exists a handling for the given <code>statusCode</code> in the\n * rules for this request.\n *\n * @param statusCode the original status code\n * @param rule the rule matching the current request\n * @param log extra configured logger\n * @return the translated status or if no translation was carried out the original status code.\n */\npublic static int translateStatusCode(int statusCode, Rule rule, Logger log) {\n    Integer translatedStatus = null;\n    if (rule.getTranslateStatus() != null) {\n        for (Map.Entry<Pattern, Integer> entry : rule.getTranslateStatus().entrySet()) {\n            if (entry.getKey().matcher(\"\" + statusCode).matches()) {\n                if (log != null) {",
        "pred_variables": [
            "statusCode",
            "translatedStatus",
            "rule"
        ],
        "label_variables": [
            "statusCode"
        ]
    },
    {
        "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic void exceptionCaught(IoSession session, Throwable cause) throws Exception {",
        "pred_variables": [
            "cause"
        ],
        "label_variables": [
            "cause"
        ]
    },
    {
        "code": "@Override\npublic Future<Long> cacheEntriesCount() {\n    Promise<Long> promise = Promise.promise();\n    redisAPI.scard(CACHED_REQUESTS, reply -> {\n        if (reply.failed()) {\n            String message = \"Failed to get count of cached requests. Cause: \" + logCause(reply);",
        "pred_variables": [
            "Promise",
            "count",
            "message"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "/**\n * Registers a plug-in.\n *\n * @param plugin\n *            plugin\n */\npublic static void register(IRed5Plugin plugin) {",
        "pred_variables": [
            "plugin"
        ],
        "label_variables": [
            "plugin"
        ]
    },
    {
        "code": "/**\n * Transitions from <code>fromState</code> to <code>toState</code>.\n *\n * @param fromState Previous state\n * @param toState New state\n * @return <code>true</code> if successful\n */\npublic boolean transition(Value fromState, Value toState) {\n    Preconditions.checkArgument(fromState != toState, \"fromState must be different than toState\");\n    boolean success = value.compareAndSet(fromState, toState);\n    if (success) {\n        fireValueChangedEvent();\n    } else {",
        "pred_variables": [
            "checkArgument",
            "toState",
            "value",
            "fromState"
        ],
        "label_variables": [
            "fromState",
            "toState"
        ]
    },
    {
        "code": "@Override\npublic void info(String message, Throwable cause) {",
        "pred_variables": [
            "message",
            "cause"
        ],
        "label_variables": [
            "cause",
            "message"
        ]
    },
    {
        "code": "void addKafkaProducer(KafkaConfiguration config) {",
        "pred_variables": [
            "config"
        ],
        "label_variables": [
            "config"
        ]
    },
    {
        "code": "public DeferredChanged<List<Optional<? super T>>> build() {\n    if (deferredValues.isEmpty()) {\n        return DeferredChanged.empty();\n    }\n    log.debug(\"Building collected deferred {}\", DeferredLogger.logValue(deferredValues));\n    final PendingChanged<List<Optional<? super T>>> changed = new PendingChanged<>();\n    whenSet.forEach(changed::whenSet);\n    Optional[] values = new Optional[deferredValues.size()];\n    IntStream.range(0, deferredValues.size()).forEach(i -> {\n        DeferredChanged<? extends T> deferredItem = deferredValues.get(i);\n        deferredItem.whenSet(value -> {\n            values[i] = value;",
        "pred_variables": [
            "deferredValues",
            "forEach",
            "List"
        ],
        "label_variables": [
            "values"
        ]
    },
    {
        "code": "protected void consumeBatch() throws Exception {\n    Destination destination = session.createQueue(DESTINATION);\n    final MessageConsumer messageConsumer = session.createConsumer(destination);\n    try {\n        for (int i = 0; i < 10; ++i) {\n            final Message message = messageConsumer.receive(1000L);",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"vault\")\nToxiproxyContainer.ContainerProxy vaultContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(BEAN_NAME_EMBEDDED_VAULT) VaultContainer vault, ConfigurableEnvironment environment, VaultProperties properties) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(vault, properties.getPort());\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.vault.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.vault.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.vault.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedVaultToxiproxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [
            "propertySource"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "@Override\npublic void run() {\n    try {\n        String name = THREAD_NAME_PREFIX + Thread.currentThread().getName();",
        "pred_variables": [
            "name",
            "getName"
        ],
        "label_variables": [
            "name"
        ]
    },
    {
        "code": "        for (Peer peer : peerKit.findAvailablePeers()) {\n            if (excludePeer == null || (excludePeer != null && !peer.equals(excludePeer))) {\n                try {\n                    peer.sendMessage(message);\n                    successCount++;\n                } catch (NotYetConnectedException | IOException e) {\n                    log.warn(\"\u5e7f\u64ad\u6d88\u606f\u51fa\u9519\uff0c\u53ef\u80fd\u539f\u56e0\u662f\u8be5\u8282\u70b9\u8fde\u63a5\u5df2\u5173\u95ed, {}\", e.getMessage());\n                }\n            }\n        }\n        return successCount;\n    } else {\n        log.warn(\"\u5e7f\u64ad\u6d88\u606f\u5931\u8d25\uff0c\u6ca1\u6709\u53ef\u5e7f\u64ad\u7684\u8282\u70b9\");\n    }\n    if (log.isDebugEnabled()) {",
        "pred_variables": [
            "excludePeer",
            "peer"
        ],
        "label_variables": [
            "successCount",
            "message"
        ]
    },
    {
        "code": "private void registerMySQLEnvironment(MySQLContainer mysql, ConfigurableEnvironment environment, MySQLProperties properties) {\n    Integer mappedPort = mysql.getMappedPort(properties.getPort());\n    String host = mysql.getHost();\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.mysql.port\", mappedPort);\n    map.put(\"embedded.mysql.host\", host);\n    map.put(\"embedded.mysql.schema\", properties.getDatabase());\n    map.put(\"embedded.mysql.user\", properties.getUser());\n    map.put(\"embedded.mysql.password\", properties.getPassword());\n    String jdbcURL = \"jdbc:mysql://{}:{}/{}\";",
        "pred_variables": [
            "properties"
        ],
        "label_variables": [
            "mappedPort",
            "host",
            "map"
        ]
    },
    {
        "code": "@Override\nprotected void failed() {\n    try {\n        Throwable exception = getException();\n        errorHandlers.stream().filter(handler -> handler.handles(exception)).findFirst().ifPresentOrElse(exceptionHandler -> {\n            exceptionHandler.handle(exception);\n        }, () -> {",
        "pred_variables": [
            "ifPresentOrElse",
            "getException",
            "exception",
            "exceptionHandler"
        ],
        "label_variables": [
            "exception"
        ]
    },
    {
        "code": "public void stopping(Artifact configurationId) {",
        "pred_variables": [
            "configurationId"
        ],
        "label_variables": [
            "configurationId"
        ]
    },
    {
        "code": "    final StringBuilder log = new StringBuilder(0);\n    for (final Map.Entry<Votes, Integer> ent : this.voters.entrySet()) {\n        dirs.add(\"vote\").attr(\"author\", ent.getKey().toString()).attr(\"weight\", ent.getValue());\n        for (final String login : this.logins) {\n            log.setLength(0);\n            try {\n                dirs.add(\"person\").attr(\"login\", login).attr(\"points\", ent.getKey().take(login, log)).set(log.toString()).up();\n            } catch (final IOException err) {\n                throw new IllegalStateException(\"Failed to vote\", err);\n            }\n        }\n        dirs.up();\n    }\n    final String ltag = \"com.zerocracy.election\";\n    if (Logger.isDebugEnabled(ltag)) {",
        "pred_variables": [
            "Logger",
            "com"
        ],
        "label_variables": [
            "ltag"
        ]
    },
    {
        "code": "protected void readMessagesOnBroker(int count) throws Exception {\n    Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n    Queue queue = session.createQueue(getDestinationName());\n    MessageConsumer consumer = session.createConsumer(queue);\n    for (int i = 0; i < MESSAGE_COUNT; ++i) {\n        Message message = consumer.receive(RECEIVE_TIMEOUT);\n        assertNotNull(message);",
        "pred_variables": [
            "i",
            "message"
        ],
        "label_variables": [
            "i"
        ]
    },
    {
        "code": "        repeatId.requestFocus();\n        DailogUtil.showTipDailogCenter(\"\u4e24\u6b21\u8f93\u5165\u7684\u5bc6\u7801\u4e0d\u4e00\u81f4\", getThisStage());\n        return;\n    } else if (!validPassword(password)) {\n        passwordId.requestFocus();\n        DailogUtil.showTipDailogCenter(\"\u8f93\u5165\u7684\u5bc6\u7801\u97006\u4f4d\u6216\u4ee5\u4e0a\uff0c\u4e14\u5305\u542b\u5b57\u6bcd\u548c\u6570\u5b57\", getThisStage());\n        return;\n    }\n    //\u52a0\u5bc6\u5e76\u5224\u65ad\u7ed3\u679c\n    AccountKit accountKit = InchainInstance.getInstance().getAccountKit();\n    Result result = accountKit.encryptWallet(password, null);\n    if (result.isSuccess()) {\n        DailogUtil.showTipDailogCenter(result.getMessage(), getThisStage());\n        resetAndclose();\n    } else {",
        "pred_variables": [],
        "label_variables": [
            "result"
        ]
    },
    {
        "code": "public void execute(ISchedulingService service) {\n    log.debug(\"Reaper running...\");\n    if (sessions != null) {\n        if (!sessions.isEmpty()) {\n            long now = System.currentTimeMillis();\n            for (Map.Entry<String, ISession> entry : sessions.entrySet()) {\n                ISession session = entry.getValue();\n                long creationTime = session.getCreated();\n                // check if session life exceeds max lifetime\n                if (now - creationTime > SessionManager.maxLifetime) {\n                    String key = session.getSessionId();",
        "pred_variables": [
            "maxLifetime"
        ],
        "label_variables": [
            "key"
        ]
    },
    {
        "code": "public void succeeded(Artifact configurationId) {",
        "pred_variables": [
            "configurationId"
        ],
        "label_variables": [
            "configurationId"
        ]
    },
    {
        "code": "@Override\nprotected void failed() {\n    final var throwable = super.getException();",
        "pred_variables": [
            "super"
        ],
        "label_variables": [
            "throwable"
        ]
    },
    {
        "code": "@Test\nvoid ignoredVersionsFirefox() {\n    String[] ignoredVersions = { \"0.28.0\", \"0.29.0\" };\n    wdm = WebDriverManager.firefoxdriver().ignoreDriverVersions(ignoredVersions);\n    wdm.setup();\n    String driverVersion = wdm.getDownloadedDriverVersion();",
        "pred_variables": [
            "wdm",
            "firefoxdriver"
        ],
        "label_variables": [
            "driverVersion"
        ]
    },
    {
        "code": "    driver.findElement(By.xpath(\"//span[text()='=']\")).click();\n    // ... should be 4, wait for it\n    WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));\n    wait.until(ExpectedConditions.textToBe(By.className(\"screen\"), \"4\"));\n    wdm.stopRecording();\n    long timeoutMs = System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(REC_TIMEOUT_SEC);\n    File recFile;\n    do {\n        recFile = new File(targetFolder, REC_FILENAME + REC_EXT);\n        if (System.currentTimeMillis() > timeoutMs) {\n            fail(\"Timeout of \" + REC_TIMEOUT_SEC + \" seconds waiting for recording \" + recFile);\n            break;\n        }\n        Thread.sleep(POLL_TIME_MSEC);\n    } while (!recFile.exists());",
        "pred_variables": [
            "System",
            "targetFolder",
            "recFile",
            "By",
            "timeoutMs",
            "REC_FILENAME"
        ],
        "label_variables": [
            "recFile"
        ]
    },
    {
        "code": "private ObjectName toObjectName(String objectName) {\n    ObjectName result = null;\n    try {\n        result = new ObjectName(objectName);\n    } catch (Exception e) {",
        "pred_variables": [
            "objectName"
        ],
        "label_variables": [
            "objectName"
        ]
    },
    {
        "code": "@Override\npublic Future<Result<Buffer, StatusCode>> fetchData(final String requestUri, HeadersMultiMap requestHeaders, long requestTimeoutMs) {\n    Promise<Result<Buffer, StatusCode>> promise = Promise.promise();\n    requestHeaders.remove(cacheControlHeader);\n    clientRequestCreator.createClientRequest(HttpMethod.GET, requestUri, requestHeaders, requestTimeoutMs, event -> {\n        log.warn(\"Got an error while fetching cache data\", event);\n        promise.complete(Result.err(StatusCode.INTERNAL_SERVER_ERROR));\n    }).onComplete(event -> {\n        if (event.failed()) {",
        "pred_variables": [
            "event"
        ],
        "label_variables": [
            "requestUri"
        ]
    },
    {
        "code": "private static void log(InternalLog log, int level, String message, Throwable throwable) {\n    if (level <= Level.FINE.intValue()) {\n        if (throwable == null) {",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "@Override\npublic void visitSequenceOpen(String name, long id, int length) {\n    tab++;",
        "pred_variables": [
            "id",
            "name"
        ],
        "label_variables": [
            "name",
            "length"
        ]
    },
    {
        "code": "/**\n * Redirect to HTTP port.\n */\n@Override\nprotected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    HttpClient client = HttpConnectionUtil.getClient(connectionTimeout);\n    //setup POST\n    HttpPost post = null;\n    try {\n        post = new HttpPost(postAcceptorURL);\n        String path = req.getContextPath();\n        if (path == null) {\n            path = \"\";\n        }",
        "pred_variables": [
            "path",
            "setup",
            "postAcceptorURL"
        ],
        "label_variables": [
            "path"
        ]
    },
    {
        "code": "@Bean(name = BEAN_NAME_EMBEDDED_NATS_TOXI_PROXY)\n@ConditionalOnToxiProxyEnabled(module = \"nats\")\nToxiproxyContainer.ContainerProxy natsContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(BEAN_NAME_EMBEDDED_NATS) GenericContainer<?> natsContainer, NatsProperties properties, ConfigurableEnvironment environment) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(natsContainer, properties.getClientPort());\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.nats.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.nats.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.nats.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedNatsToxiproxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [
            "propertySource"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "            try {\n                LOG.info(\"Adding admin users from group: \" + groupName);\n                Group group = provider.getGroup(groupName);\n                if (group != null) {\n                    results.addAll(group.getMembers());\n                }\n            } catch (GroupNotFoundException gnfe) {\n                LOG.error(\"Error when trying to load the members of group:\" + groupName, gnfe);\n            }\n        }\n    }\n    if (results.isEmpty()) {\n        // Add default admin account when none was specified\n        results.add(new JID(\"admin\", XMPPServer.getInstance().getServerInfo().getXMPPDomain(), null, true));\n    }",
        "pred_variables": [
            "getServerInfo"
        ],
        "label_variables": [
            "results"
        ]
    },
    {
        "code": "@ParameterizedTest\n@MethodSource(\"data\")\nvoid testServerResolver(String path, String driver) throws IOException {\n    String serverUrl = String.format(\"http://localhost:%s/%s\", serverPort, path);\n    try (CloseableHttpClient client = HttpClientBuilder.create().build()) {\n        HttpUriRequestBase request = new HttpGet(serverUrl);\n        // Assert response",
        "pred_variables": [
            "path",
            "serverUrl"
        ],
        "label_variables": [
            "serverUrl"
        ]
    },
    {
        "code": "public String parse(final String input) {\n    if (input == null) {\n        throw new IllegalArgumentException(\"input\");\n    }",
        "pred_variables": [
            "input"
        ],
        "label_variables": [
            "input"
        ]
    },
    {
        "code": "public boolean modifyIdTokenMethod(CustomScriptConfiguration script, JsonWebResponse jsonWebResponse, ExternalUpdateTokenContext context) {\n    try {",
        "pred_variables": [
            "script",
            "jsonWebResponse"
        ],
        "label_variables": [
            "context",
            "jsonWebResponse"
        ]
    },
    {
        "code": "@Override\npublic Response toResponse(final Exception ex) {",
        "pred_variables": [
            "ex"
        ],
        "label_variables": [
            "ex"
        ]
    },
    {
        "code": "@SuppressWarnings(\"deprecation\")\n@Override\npublic void append(LogEvent event) {\n    if (event.getThrown() != null && event.getThrown() instanceof TransportDisposedIOException) {\n        // Prevent StackOverflowException so we can see a sane stack trace.\n        if (gotExceptionInLog.get()) {\n            return;\n        }\n        gotExceptionInLog.set(Boolean.TRUE);",
        "pred_variables": [
            "event",
            "return",
            "TRUE"
        ],
        "label_variables": [
            "event"
        ]
    },
    {
        "code": " * @param str\n *            String representation of XML\n * @return DOM object\n * @throws IOException\n *             I/O exception\n */\npublic static Document stringToDoc(String str) throws IOException {\n    if (StringUtils.isNotEmpty(str)) {\n        try (Reader reader = new StringReader(str)) {\n            DocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n            EntityResolver noop = (publicId, systemId) -> new InputSource(new StringReader(\"\"));\n            db.setEntityResolver(noop);\n            Document doc = db.parse(new InputSource(reader));\n            return doc;\n        } catch (Exception ex) {",
        "pred_variables": [
            "str",
            "setEntityResolver"
        ],
        "label_variables": [
            "str"
        ]
    },
    {
        "code": "/**\n * \u666e\u901a\u8d26\u6237\u7684\u7b7e\u540d\n */\n@Override\npublic boolean signOneInputs(Transaction tx, ECKey key, int inputIndex) {\n    int numInputs = tx.getInputs().size();\n    if (numInputs < inputIndex + 1) {\n        log.warn(\"\u4ea4\u6613\u8f93\u5165index\u8d8a\u754c\");\n        return false;\n    }\n    TransactionInput txIn = (TransactionInput) tx.getInput(inputIndex);\n    if (txIn.getFroms() == null || txIn.getFroms().size() == 0) {",
        "pred_variables": [
            "key",
            "inputIndex"
        ],
        "label_variables": [
            "inputIndex"
        ]
    },
    {
        "code": "@Override\npublic boolean recoverMessageReference(MessageId messageReference) throws Exception {\n    Message msg = this.store.getMessage(messageReference);\n    if (msg != null) {\n        return recoverMessage(msg);\n    } else {\n        String err = \"Failed to retrieve message for id: \" + messageReference;",
        "pred_variables": [
            "err"
        ],
        "label_variables": [
            "err"
        ]
    },
    {
        "code": "@ParameterizedTest\n@MethodSource(\"data\")\nvoid testChromeDriverVersions(WebDriverManager wdm) {\n    List<String> versions = wdm.getDriverVersions();",
        "pred_variables": [
            "wdm"
        ],
        "label_variables": [
            "versions"
        ]
    },
    {
        "code": "@Override\npublic ApplicationProtocolHandler getProtocolHandler(String protocol) {\n    for (ApplicationProtocolHandler protocolHandler : protocolHandlers) {\n        if (protocolHandler.getProtocol() != null && protocolHandler.getProtocol().equals(protocol)) {\n            return protocolHandler;\n        }\n    }",
        "pred_variables": [
            "protocolHandler"
        ],
        "label_variables": [
            "protocol"
        ]
    },
    {
        "code": "    }\n    VersionMessage peerVersion = peer.getPeerVersionMessage();\n    if (peerVersion != null) {\n        peerVersion.setBestHeight(block.getHeight());\n    }\n    for (Transaction tx : block.getTxs()) {\n        //\u79fb\u9664\u5167\u5b58\u4e2d\u7684\u4ea4\u6613\n        MempoolContainer.getInstace().remove(tx.getHash());\n    }\n    //\u533a\u5757\u53d8\u5316\u76d1\u542c\u5668\n    if (peerKit.getBlockChangedListener() != null) {\n        peerKit.getBlockChangedListener().onChanged(-1l, block.getHeight(), null, hash);\n    }\n    //\u8f6c\u53d1\u65b0\u533a\u5757\u6d88\u606f\n    if (log.isDebugEnabled()) {",
        "pred_variables": [
            "block",
            "peerVersion"
        ],
        "label_variables": [
            "hash"
        ]
    },
    {
        "code": "    // Only process PUT requests and request, which URL can be found\n    if (request.method().equals(HttpMethod.PUT) && propertyUrls.containsKey(request.uri())) {\n        log.info(\"Got a request to update propertyUrl=[{}]\", request.uri());\n        // process body\n        request.bodyHandler(buffer -> {\n            Map<String, String> idProperties = propertyUrls.get(request.uri());\n            JsonObject body = new JsonObject(buffer.toString());\n            boolean found = false;\n            for (String keyId : idProperties.keySet()) {\n                // try to find a watched key in the body\n                if (body.containsKey(keyId)) {\n                    // save the value in the properties\n                    props.put(idProperties.get(keyId), body.getValue(keyId));\n                    // refresh all refreshables\n                    refresh();",
        "pred_variables": [
            "body",
            "idProperties"
        ],
        "label_variables": [
            "keyId"
        ]
    },
    {
        "code": "public boolean externalForceAuthorization(CustomScriptConfiguration scriptConfiguration, ExternalPostAuthnContext context) {\n    try {",
        "pred_variables": [
            "scriptConfiguration",
            "context"
        ],
        "label_variables": [
            "context"
        ]
    },
    {
        "code": "@Test\npublic void patternUpdate() {\n    final String msg = \"pattern\";\n    StdoutRecorder stdoutRecorder = new StdoutRecorder();\n    final String log = stdoutRecorder.record(new Runnable() {\n\n        @Override\n        public void run() {\n            logger = Logger.getLogger(\"patternUpdateLogback\");",
        "pred_variables": [
            "msg"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "@Override\npublic void transactionalLogRecordReadFailure(long[] transactionOffsets, int transactionIndex, long logVersion) {",
        "pred_variables": [
            "transactionIndex",
            "logVersion",
            "transactionOffsets"
        ],
        "label_variables": [
            "logVersion"
        ]
    },
    {
        "code": "@Test\npublic void testA7SliceBug() {\n    log.info(\"\\n testA7SliceBug\");\n    Path path = Paths.get(\"target/test-classes/fixtures/ipadmini-A7.flv\");\n    try {\n        File file = path.toFile();\n        log.info(\"Reading: {}\", file.getName());\n        FLVReader reader = new FLVReader(file, true);\n        ITag tag = null;\n        AVCVideo video = new AVCVideo();\n        while (reader.hasMoreTags()) {\n            tag = reader.readTag();\n            int timestamp = tag.getTimestamp();",
        "pred_variables": [
            "path",
            "tag"
        ],
        "label_variables": [
            "timestamp"
        ]
    },
    {
        "code": "public void setAdditionalTLDs(List<String> additionalTLDs) {\n    // Support additional top level domains\n    if (additionalTLDs != null && !additionalTLDs.isEmpty()) {\n        try {\n            String[] tldsToAddArray = additionalTLDs.toArray(new String[0]);",
        "pred_variables": [
            "toArray",
            "String",
            "additionalTLDs"
        ],
        "label_variables": [
            "tldsToAddArray"
        ]
    },
    {
        "code": "@Override\npublic void exec(int executionCounter) {\n    List<String> args = RedisUtils.toPayload(luaScriptState.getSha(), keys.size(), keys, arguments);\n    redisAPI.evalsha(args, event -> {\n        if (event.succeeded()) {\n            Integer insertCount = event.result().toInteger();\n            Boolean timerStarted = insertCount != null && insertCount > 0;\n            promise.complete(timerStarted);\n        } else {\n            String message = event.cause().getMessage();\n            if (message != null && message.startsWith(\"NOSCRIPT\")) {\n                log.warn(\"StartQueueTimerRedisCommand script couldn't be found, reload it\");",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "executionCounter"
        ]
    },
    {
        "code": "public void handleEvent(Event event) {\n    String topic = event.getTopic();\n    if (topic.equals(SlingConstants.TOPIC_RESOURCE_CHANGED)) {\n        try {\n            String path = (String) event.getProperty(SlingConstants.PROPERTY_PATH);",
        "pred_variables": [
            "path"
        ],
        "label_variables": [
            "path"
        ]
    },
    {
        "code": "public void notifyEndUser(String scope, String acrValues, String authReqId, String deviceRegistrationToken) {\n    try {\n        if (externalCibaEndUserNotificationService.isEnabled()) {\n            log.debug(\"CIBA: Authorization request sending to the end user with custom interception scripts\");\n            ExternalCibaEndUserNotificationContext context = new ExternalCibaEndUserNotificationContext(scope, acrValues, authReqId, deviceRegistrationToken, appConfiguration, cibaEncryptionService);",
        "pred_variables": [
            "cibaEncryptionService",
            "externalCibaEndUserNotificationService",
            "scope"
        ],
        "label_variables": [
            "context"
        ]
    },
    {
        "code": "public boolean uploadDataServiceFile(String fileName, String serviceHierarchy, DataHandler dh) throws ExceptionException, RemoteException {\n    if (log.isDebugEnabled()) {\n        log.debug(\"path to file :\" + dh.getName());\n    }\n    String response = dataServiceFileUploaderStub.uploadService(fileName, serviceHierarchy, dh);\n    if (\"successful\".equalsIgnoreCase(response)) {\n        log.info(\"Artifact Uploaded\");\n        return true;\n    } else {",
        "pred_variables": [
            "response",
            "fileName",
            "dh",
            "serviceHierarchy"
        ],
        "label_variables": [
            "response"
        ]
    },
    {
        "code": "@Override\npublic void initialize(File configurationFile, StatsLogger statsLogger) throws IOException {\n    config = mapper.readValue(configurationFile, Config.class);\n    PropertiesConfiguration propsConf = new PropertiesConfiguration();\n    DistributedLogConfiguration conf = new DistributedLogConfiguration();\n    try {\n        propsConf.load(new StringReader(config.dlogConf));\n        conf.loadConf(propsConf);\n    } catch (ConfigurationException e) {\n        log.error(\"Failed to load dlog configuration : \\n{}\\n\", config.dlogConf, e);\n        throw new IOException(\"Failed to load configuration : \\n\" + config.dlogConf + \"\\n\", e);\n    }\n    URI dlogUri = URI.create(config.dlogUri);\n    dlshade.org.apache.bookkeeper.stats.StatsLogger dlStatsLogger = new CachingStatsLogger(new StatsLoggerAdaptor(statsLogger.scope(\"dlog\")));\n    namespace = NamespaceBuilder.newBuilder().conf(conf).uri(dlogUri).statsLogger(dlStatsLogger).build();",
        "pred_variables": [
            "namespace",
            "dlogUri",
            "uri",
            "configurationFile"
        ],
        "label_variables": [
            "dlogUri"
        ]
    },
    {
        "code": "public void copyToRepository(InputStream source, int size, Artifact destination, FileWriteMonitor monitor) throws IOException {\n    if (!destination.isResolved()) {\n        throw new IllegalArgumentException(\"Artifact \" + destination + \" is not fully resolved\");\n    }\n    // is this a writable repository\n    if (!rootFile.canWrite()) {\n        throw new IllegalStateException(\"This repository is not writable: \" + rootFile.getAbsolutePath() + \")\");\n    }\n    // where are we going to install the file\n    File location = getLocation(destination);\n    // assure that there isn't already a file installed at the specified location\n    if (location.exists()) {\n        throw new IllegalArgumentException(\"Destination \" + location.getAbsolutePath() + \" already exists!\");\n    }\n    ArtifactTypeHandler typeHandler = typeHandlers.get(destination.getType());\n    if (typeHandler == null)\n        typeHandler = DEFAULT_TYPE_HANDLER;\n    typeHandler.install(source, size, destination, monitor, location);\n    if (destination.getType().equalsIgnoreCase(\"car\")) {\n        log.debug(\"Installed module configuration; id={}; location={}\", destination, location);\n    }",
        "pred_variables": [
            "ArtifactTypeHandler",
            "location",
            "getAbsolutePath",
            "destination"
        ],
        "label_variables": [
            "destination",
            "location"
        ]
    },
    {
        "code": "@Override\npublic void didRemoveConfigurationScope(DidRemoveConfigurationScopeParams params) {\n    var idToRemove = params.getRemovedId();\n    var removed = repository.remove(idToRemove);\n    if (removed == null) {",
        "pred_variables": [
            "idToRemove",
            "var",
            "getRemovedId",
            "removed",
            "params"
        ],
        "label_variables": [
            "idToRemove"
        ]
    },
    {
        "code": "@Test(groups = \"wso2.esb\", description = \"Test-Without No_ENTITY_BODY Property\", enabled = false)\npublic void testWithoutOutOnlyPropertyTest() throws Exception {\n    SimpleHttpClient httpClient = new SimpleHttpClient();\n    Map<String, String> headers = new HashMap<String, String>();\n    headers.put(\"Content-Type\", \"text/xml\");\n    headers.put(\"SOAPAction\", \"urn:mediate\");\n    String payload = \"<soapenv:Envelope xmlns:soapenv=\\\"http://schemas.xmlsoap.org/soap/\" + \"envelope/\\\">\\n\" + \"   <soapenv:Header/>\\n\" + \"   <soapenv:Body/>My Request</soapenv:Envelope>\\n\" + \"</soapenv:Envelope>\";",
        "pred_variables": [
            "Envelope"
        ],
        "label_variables": [
            "payload"
        ]
    },
    {
        "code": "private Date getExpirationDateFromResolutionCache(String key) {\n    Date result = new Date(0);\n    try {\n        result = dateFormat.parse(props.getProperty(getExpirationKey(key)));\n        return result;\n    } catch (Exception e) {",
        "pred_variables": [
            "key"
        ],
        "label_variables": [
            "key"
        ]
    },
    {
        "code": "@Test\nvoid edgeVersionsTest() {\n    String[] expectedVersions = { \"75.0.139.20\", \"76.0.183.0\", \"77.0.237.0\", \"78.0.277.0\", \"79.0.313.0\", \"80.0.361.111\", \"81.0.409.0\", \"82.0.459.1\" };\n    List<String> driverVersions = WebDriverManager.edgedriver().getDriverVersions();",
        "pred_variables": [
            "expectedVersions"
        ],
        "label_variables": [
            "expectedVersions"
        ]
    },
    {
        "code": "public void resolving(Artifact configurationId) {",
        "pred_variables": [
            "configurationId"
        ],
        "label_variables": [
            "configurationId"
        ]
    },
    {
        "code": "@Override\npublic MessageProcessResult process(Message message, Peer peer) {\n    VersionMessage versionMessage = (VersionMessage) message;\n    if (peer.getPeerVersionMessage() != null)\n        throw new ProtocolException(\"Got two version messages from peer\");\n    peer.setPeerVersionMessage(versionMessage);\n    // Switch to the new protocol version.\n    long peerTime = versionMessage.getTime();",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "peerTime"
        ]
    },
    {
        "code": "@Override\npublic void visitBytes(String name, long id, ByteBuffer value) {",
        "pred_variables": [
            "id",
            "name"
        ],
        "label_variables": [
            "name"
        ]
    },
    {
        "code": "public static void main(String[] args) throws Exception {\n    if (args.length == 2 || args.length == 4) {\n        String zkQuorum = args[0];\n        String zkPath = args[1];",
        "pred_variables": [
            "args"
        ],
        "label_variables": [
            "zkPath"
        ]
    },
    {
        "code": "public void startupFinished() {\n    try {\n        Set gbeans = kernel.listGBeans((AbstractNameQuery) null);\n        for (Iterator it = gbeans.iterator(); it.hasNext(); ) {\n            AbstractName name = (AbstractName) it.next();\n            int state = kernel.getGBeanState(name);\n            if (state != State.RUNNING_INDEX) {",
        "pred_variables": [
            "state"
        ],
        "label_variables": [
            "name",
            "state"
        ]
    },
    {
        "code": "public String submit(RequestContext context, String homeRealm) {\n    // Check if home realm is known already\n    Cookie homeRealmCookie = homeRealmReminder.readCookie(context);\n    if (homeRealmCookie != null) {",
        "pred_variables": [
            "context",
            "homeRealmCookie"
        ],
        "label_variables": [
            "homeRealmCookie"
        ]
    },
    {
        "code": "@Override\npublic void onException(IOException error) {\n    synchronized (this) {\n        setHasExpired(true);\n        // only log if not stopped\n        if (!stopped.get()) {",
        "pred_variables": [
            "error"
        ],
        "label_variables": [
            "error"
        ]
    },
    {
        "code": "public void debug(String s) {",
        "pred_variables": [
            "s"
        ],
        "label_variables": [
            "s"
        ]
    },
    {
        "code": "private String getFrontchannelHtml(CustomScriptConfiguration scriptConf, EndSessionContext context) {\n    try {",
        "pred_variables": [
            "EndSessionContext",
            "scriptConf"
        ],
        "label_variables": [
            "context"
        ]
    },
    {
        "code": "private void registerLocalStackEnvironment(LocalStackContainer localStack, ConfigurableEnvironment environment, LocalStackProperties properties) {\n    String host = localStack.getHost();\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.localstack.host\", host);\n    map.put(\"embedded.localstack.accessKey\", localStack.getAccessKey());\n    map.put(\"embedded.localstack.secretKey\", localStack.getSecretKey());\n    String prefix = \"embedded.localstack.\";\n    Integer mappedPort = localStack.getMappedPort(properties.getEdgePort());\n    for (LocalStackContainer.Service service : properties.services) {\n        map.put(prefix + service, localStack.getEndpointConfiguration(service).getServiceEndpoint());\n        map.put(prefix + service + \".port\", mappedPort);\n    }",
        "pred_variables": [
            "host",
            "prefix",
            "service",
            "properties"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "private void startDatabase(StandaloneDatabaseContext context) {\n    var namedDatabaseId = context.database().getNamedDatabaseId();\n    try {",
        "pred_variables": [
            "namedDatabaseId",
            "context"
        ],
        "label_variables": [
            "namedDatabaseId"
        ]
    },
    {
        "code": "@Test\npublic void testFBLivePublish() throws InterruptedException {\n    log.info(\"\\n testFBLivePublish\");\n    String host = \"rtmp-api.facebook.com\";\n    int port = 80;\n    String app = \"rtmp\";\n    final String publishName = \"1567066673326082?ds=1&s_l=1&a=ATiBCGoo4bLDTa4c\";",
        "pred_variables": [],
        "label_variables": [
            "publishName"
        ]
    },
    {
        "code": "/**\n * {@inheritDoc}\n */\npublic void decode(IoSession session, IoBuffer in, ProtocolDecoderOutput out) throws ProtocolCodecException {\n    // get the connection from the session\n    String sessionId = (String) session.getAttribute(RTMPConnection.RTMP_SESSION_ID);",
        "pred_variables": [
            "session"
        ],
        "label_variables": [
            "sessionId"
        ]
    },
    {
        "code": "private void registerKeycloakEnvironment(KeycloakContainer keycloak) {\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.keycloak.host\", keycloak.getIp());\n    map.put(\"embedded.keycloak.http-port\", keycloak.getHttpPort());\n    map.put(\"embedded.keycloak.auth-server-url\", keycloak.getAuthServerUrl());",
        "pred_variables": [],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "    Topic topic = session.createTopic(topicFilter);\n    MessageConsumer consumer = session.createDurableSubscriber(topic, testName.getMethodName());\n    assertNotNull(consumer);\n    Topic advisoryTopic = AdvisorySupport.getSlowConsumerAdvisoryTopic(ActiveMQDestination.createDestination(topicA, ActiveMQDestination.TOPIC_TYPE));\n    session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n    MessageConsumer advisoryConsumer = session.createConsumer(advisoryTopic);\n    // start throwing messages at the consumer one for an ongoing series of\n    // matching topics for the subscription's filter.\n    MessageProducer producer = session.createProducer(null);\n    // Send one to the destination where we want a matching advisory\n    producer.send(session.createTopic(topicA), session.createMessage());\n    for (int i = 0; i < MESSAGE_COUNT; i++) {\n        BytesMessage m = session.createBytesMessage();\n        m.writeBytes(new byte[1024]);\n        Topic newTopic = session.createTopic(topicPrefix + UUID.randomUUID().toString());",
        "pred_variables": [
            "newTopic"
        ],
        "label_variables": [
            "newTopic"
        ]
    },
    {
        "code": "public void store(String projectKey, ProjectBranches projectBranches) {\n    var pbFilePath = getProjectBranchesFilePath(projectKey);\n    FileUtils.mkdirs(pbFilePath.getParent());\n    var data = adapt(projectBranches);",
        "pred_variables": [
            "FileUtils",
            "var",
            "pbFilePath"
        ],
        "label_variables": [
            "pbFilePath"
        ]
    },
    {
        "code": "public void removedBundle(Bundle bundle, BundleEvent event, Object object) {\n    List<Driver> drivers = (List<Driver>) object;\n    unregister(drivers);",
        "pred_variables": [
            "object",
            "drivers",
            "event",
            "bundle"
        ],
        "label_variables": [
            "drivers",
            "bundle"
        ]
    },
    {
        "code": " *\n * @param lockImpl the lock implementation\n * @param lock the lock\n * @param token the unique token\n * @param lockExpiryMs the expiry of the lock\n * @param log the logger\n * @return A boolean {@link Future} whether the lock could has been acquired or not\n */\npublic static Future<Boolean> acquireLock(Lock lockImpl, String lock, String token, long lockExpiryMs, Logger log) {\n    Promise<Boolean> promise = Promise.promise();\n    if (lockImpl == null) {\n        log.info(\"No lock implementation defined, going to pretend like we got the lock\");\n        promise.complete(Boolean.TRUE);\n        return promise.future();\n    }",
        "pred_variables": [
            "Promise",
            "lockImpl",
            "token"
        ],
        "label_variables": [
            "lockExpiryMs",
            "lock",
            "token"
        ]
    },
    {
        "code": "@Override\npublic void deleteDruidCluster(String clusterId) throws IOException, ClusterNotFoundException {",
        "pred_variables": [
            "clusterId"
        ],
        "label_variables": [
            "clusterId"
        ]
    },
    {
        "code": "                }\n                // extract the specific resource\n                int len = 0;\n                while ((len = inputStream.read(ZIP_BUFFER_SIZE)) > 0) {\n                    contentBuffer.appendBytes(ZIP_BUFFER_SIZE, 0, len);\n                }\n                foundEntry = true;\n                // only one resource my be extracted this way\n                break;\n            }\n            if (foundEntry) {\n                // append content to response\n                createResponse(req, StatusCode.OK.getStatusCode(), StatusCode.OK.getStatusMessage(), contentBuffer, mimeTypeResolver.resolveMimeType(insidePath));\n            } else {\n                // return 404 - not found",
        "pred_variables": [
            "contentBuffer",
            "foundEntry"
        ],
        "label_variables": [
            "zipUrl",
            "insidePath"
        ]
    },
    {
        "code": "@Test\npublic void patternUpdate() {\n    final String msg = \"pattern\";\n    StdoutRecorder stdoutRecorder = new StdoutRecorder();\n    String log = stdoutRecorder.record(new Runnable() {\n\n        @Override\n        public void run() {\n            logger = LogManager.getLogger(\"patternUpdateLogback\");",
        "pred_variables": [
            "msg",
            "record"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "private void registerClickHouseEnvironment(ClickHouseContainer clickHouseContainer, ConfigurableEnvironment environment, ClickHouseProperties properties, String username, String password) {\n    Integer mappedPort = clickHouseContainer.getMappedPort(properties.port);\n    String host = clickHouseContainer.getHost();\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.clickhouse.schema\", \"default\");\n    map.put(\"embedded.clickhouse.host\", host);\n    map.put(\"embedded.clickhouse.port\", mappedPort);\n    map.put(\"embedded.clickhouse.user\", username);\n    map.put(\"embedded.clickhouse.password\", password);",
        "pred_variables": [
            "host",
            "username"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "protected TextWireFormat asTextWireFormat(WireFormat wireFormat) {\n    if (wireFormat instanceof TextWireFormat) {\n        return (TextWireFormat) wireFormat;\n    }",
        "pred_variables": [
            "wireFormat"
        ],
        "label_variables": [
            "wireFormat"
        ]
    },
    {
        "code": "    });\n    client.setExceptionHandler(new ClientExceptionHandler() {\n\n        @Override\n        public void handleException(Throwable throwable) {\n            throwable.printStackTrace();\n        }\n    });\n    IPendingServiceCallback connectCallback = new IPendingServiceCallback() {\n\n        @Override\n        public void resultReceived(IPendingServiceCall call) {\n            log.info(\"connectCallback\");\n            ObjectMap<?, ?> map = (ObjectMap<?, ?>) call.getResult();\n            String code = (String) map.get(\"code\");",
        "pred_variables": [],
        "label_variables": [
            "code"
        ]
    },
    {
        "code": "private void fillBuffer(IoBuffer buf, String byteDumpFile) throws Exception {\n    File f = new File(String.format(\"%s/target/test-classes/%s\", System.getProperty(\"user.dir\"), byteDumpFile));\n    FileInputStream fis = new FileInputStream(f);",
        "pred_variables": [],
        "label_variables": [
            "byteDumpFile"
        ]
    },
    {
        "code": "@Override\npublic void ioException(OutputStream stream, IOException e) {",
        "pred_variables": [
            "e"
        ],
        "label_variables": [
            "e"
        ]
    },
    {
        "code": "@Override\npublic void addRoute(String urlPattern, Route route) {",
        "pred_variables": [
            "urlPattern",
            "route"
        ],
        "label_variables": [
            "urlPattern"
        ]
    },
    {
        "code": "@Override\npublic Future<Optional<Buffer>> cachedRequest(String cacheIdentifier) {\n    Promise<Optional<Buffer>> promise = Promise.promise();\n    redisAPI.get(CACHE_PREFIX + cacheIdentifier, event -> {\n        if (event.failed()) {\n            String message = \"Failed to get cached request '\" + cacheIdentifier + \"'. Cause: \" + logCause(event);",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "@Override\npublic void handle(ServerEvent event) {\n    Class<? extends ServerEvent> eventType = event.getClass();\n    if (routes.containsKey(eventType)) {\n        routes.get(eventType).forEach(handler -> handler.handle(event));\n    } else {",
        "pred_variables": [
            "eventType",
            "event",
            "routes"
        ],
        "label_variables": [
            "eventType"
        ]
    },
    {
        "code": "@Override\npublic Optional<IssueChangedEvent> parse(String jsonData) {\n    var payload = gson.fromJson(jsonData, IssueChangedEventPayload.class);\n    if (payload.isInvalid()) {",
        "pred_variables": [
            "jsonData",
            "payload"
        ],
        "label_variables": [
            "jsonData"
        ]
    },
    {
        "code": "@Override\npublic void exceptionOccurred(Connection conn, Exception exp) {",
        "pred_variables": [
            "exp",
            "conn"
        ],
        "label_variables": [
            "conn",
            "exp"
        ]
    },
    {
        "code": "private void registerDb2Environment(Db2Container db2Container, ConfigurableEnvironment environment, Db2Properties properties) {\n    Integer mappedPort = db2Container.getMappedPort(Db2Container.DB2_PORT);\n    String host = db2Container.getHost();\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.db2.port\", mappedPort);\n    map.put(\"embedded.db2.host\", host);\n    map.put(\"embedded.db2.database\", properties.getDatabase());\n    map.put(\"embedded.db2.user\", properties.getUser());\n    map.put(\"embedded.db2.password\", properties.getPassword());\n    String jdbcURL = \"jdbc:db2://{}:{}/{}\";",
        "pred_variables": [
            "host",
            "DB2_PORT",
            "mappedPort",
            "properties"
        ],
        "label_variables": [
            "mappedPort",
            "host",
            "map"
        ]
    },
    {
        "code": "public CustomScriptConfiguration determineScript(String[] scriptNames) {",
        "pred_variables": [
            "scriptNames"
        ],
        "label_variables": [
            "scriptNames"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"azurite\")\nToxiproxyContainer.ContainerProxy azuriteBlobContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(AZURITE_BEAN_NAME) GenericContainer<?> azurite, AzuriteProperties properties, ConfigurableEnvironment environment) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(azurite, properties.getBlobStoragePort());\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.azurite.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.azurite.toxiproxy.blobStoragePort\", proxy.getProxyPort());\n    map.put(\"embedded.azurite.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedAzuriteBlobToxiproxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [
            "module"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "@Override\npublic void onStreamEvent(Notify notify) {",
        "pred_variables": [
            "notify"
        ],
        "label_variables": [
            "notify"
        ]
    },
    {
        "code": "@Override\npublic MessageProcessResult process(Message message, Peer peer) {\n    if (log.isDebugEnabled()) {",
        "pred_variables": [
            "message",
            "peer"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "public void testLoadTempAdvisoryTopics() throws Exception {\n    for (int i = 0; i < MESSAGE_COUNT; i++) {\n        TemporaryTopic tempTopic = session.createTemporaryTopic();\n        MessageConsumer consumer = session.createConsumer(tempTopic);\n        MessageProducer producer = session.createProducer(tempTopic);\n        consumer.close();\n        producer.close();\n        tempTopic.delete();\n    }\n    AdvisoryBroker ab = (AdvisoryBroker) broker.getBroker().getAdaptor(AdvisoryBroker.class);\n    assertTrue(ab.getAdvisoryDestinations().size() == 0);\n    assertTrue(ab.getAdvisoryConsumers().size() == 0);\n    assertTrue(ab.getAdvisoryProducers().size() == 0);\n    RegionBroker rb = (RegionBroker) broker.getBroker().getAdaptor(RegionBroker.class);\n    for (Destination dest : rb.getDestinationMap().values()) {",
        "pred_variables": [
            "dest"
        ],
        "label_variables": [
            "dest"
        ]
    },
    {
        "code": "@Test\npublic void testRemvoeJob() throws Exception {\n    JobSchedulerViewMBean view = getJobSchedulerMBean();\n    assertNotNull(view);\n    assertTrue(view.getAllJobs().isEmpty());\n    scheduleMessage(60000, 0, 0);\n    assertFalse(view.getAllJobs().isEmpty());\n    TabularData jobs = view.getAllJobs();\n    assertEquals(1, jobs.size());\n    for (Object key : jobs.keySet()) {\n        String jobId = ((List<?>) key).get(0).toString();",
        "pred_variables": [
            "jobId"
        ],
        "label_variables": [
            "jobId"
        ]
    },
    {
        "code": "public void checkSignature(String appId, ClientData clientData, RawAuthenticateResponse rawAuthenticateResponse, byte[] publicKey) throws BadInputException {\n    String rawClientData = clientData.getRawClientData();\n    byte[] signedBytes = packBytesToSign(signatureVerification.hash(appId), rawAuthenticateResponse.getUserPresence(), rawAuthenticateResponse.getCounter(), signatureVerification.hash(rawClientData));",
        "pred_variables": [
            "signatureVerification"
        ],
        "label_variables": [
            "signedBytes"
        ]
    },
    {
        "code": "protected final void log2SecurityLog(String message, String issuedBy) {\n    String logMessage = (StringUtils.isEmpty(issuedBy)) ? message : message + \" issued by \" + issuedBy;",
        "pred_variables": [
            "issuedBy",
            "message"
        ],
        "label_variables": [
            "logMessage"
        ]
    },
    {
        "code": "protected void printMessage(final String message, final PrintStream stream, final int priority) {\n    assert message != null;\n    assert stream != null;\n    switch(priority) {\n        case Project.MSG_ERR:",
        "pred_variables": [
            "priority",
            "message"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "public String generateId(IdType p_idType, String p_idPrefix) {\n    String inum;\n    int counter = 0;\n    try {\n        while (true) {\n            final StringBuilder sb = new StringBuilder();\n            sb.append(p_idPrefix).append(InumGenerator.SEPARATOR).append(p_idType.getInum()).append(InumGenerator.SEPARATOR);\n            if ((IdType.CLIENTS == p_idType) || (IdType.PEOPLE == p_idType)) {\n                sb.append(INumGenerator.generate(4));\n            } else {\n                sb.append(INumGenerator.generate(2));\n            }\n            inum = sb.toString();\n            if (StringUtils.isBlank(inum)) {",
        "pred_variables": [
            "sb",
            "getInum",
            "p_idType",
            "StringUtils",
            "SEPARATOR"
        ],
        "label_variables": [
            "inum"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"consul\")\nToxiproxyContainer.ContainerProxy consulContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(BEAN_NAME_EMBEDDED_CONSUL) GenericContainer<?> consulContainer, ConsulProperties properties, ConfigurableEnvironment environment) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(consulContainer, properties.getPort());\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.consul.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.consul.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.consul.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedConsulToxiproxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [
            "propertySource",
            "addFirst"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "public SchemaDiffOperation addSchema(RecursiveSchemaSet refSet, CacheKey key, Schema left, Schema right) {\n    if (!cache.containsKey(key)) {",
        "pred_variables": [
            "key",
            "left"
        ],
        "label_variables": [
            "key"
        ]
    },
    {
        "code": "@Override\npublic void handle(final Callback[] callbacks) throws IOException, UnsupportedCallbackException {\n    String name = null;\n    for (Callback callback : callbacks) {\n        if (callback instanceof RealmCallback) {\n            ((RealmCallback) callback).setText(XMPPServer.getInstance().getServerInfo().getXMPPDomain());\n        } else if (callback instanceof NameCallback) {\n            name = ((NameCallback) callback).getName();\n            if (name == null) {\n                name = ((NameCallback) callback).getDefaultName();\n            }",
        "pred_variables": [
            "name",
            "String",
            "callback"
        ],
        "label_variables": [
            "name"
        ]
    },
    {
        "code": "private void removeMetric(final String metric) {",
        "pred_variables": [],
        "label_variables": [
            "metric"
        ]
    },
    {
        "code": " * but with additional support for changing the coded timeout with an extended value.\n *\n * @return either a {@link FailOnTimeout}, or the supplied {@link Statement} as appropriate.\n */\n@SuppressWarnings(\"deprecation\")\n@Override\nprotected Statement withPotentialTimeout(FrameworkMethod frameworkMethod, Object testInstance, Statement next) {\n    long testTimeout = getOriginalTimeout(frameworkMethod);\n    if (testTimeout > 0) {\n        String multiplierString = System.getProperty(\"org.apache.activemq.junit.testTimeoutMultiplier\");\n        double multiplier = 0.0;\n        try {\n            multiplier = Double.parseDouble(multiplierString);\n        } catch (NullPointerException npe) {\n        } catch (NumberFormatException nfe) {",
        "pred_variables": [
            "testTimeout",
            "multiplier"
        ],
        "label_variables": [
            "multiplier",
            "testTimeout"
        ]
    },
    {
        "code": "            allowing(brokerService).stop();\n            then(broker.is(\"stopped\"));\n        }\n    });\n    LeaseLockerIOExceptionHandler underTest = new LeaseLockerIOExceptionHandler();\n    underTest.setBrokerService(brokerService);\n    try {\n        underTest.handle(new IOException());\n        fail(\"except suppress reply ex\");\n    } catch (SuppressReplyException expected) {\n    }\n    assertTrue(\"broker stopped state triggered\", Wait.waitFor(new Wait.Condition() {\n\n        @Override\n        public boolean isSatisified() throws Exception {",
        "pred_variables": [
            "broker"
        ],
        "label_variables": [
            "broker"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"neo4j\")\nToxiproxyContainer.ContainerProxy neo4jContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(BEAN_NAME_EMBEDDED_NEO4J) Neo4jContainer neo4j, Neo4jProperties properties, ConfigurableEnvironment environment) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(neo4j, properties.getBoltPort());\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.neo4j.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.neo4j.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.neo4j.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedNeo4jToxiProxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "            if (eventPublisherConfig == null) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Newly creating publisher configuration.\");\n                }\n                synchronized (HL7EventPublisher.class) {\n                    eventPublisherConfig = new EventPublisherConfig();\n                    DataPublisher asyncDataPublisher;\n                    try {\n                        if (serverConfig.getSecureUrl() != null) {\n                            asyncDataPublisher = new DataPublisher(DataEndpointConstants.THRIFT_DATA_AGENT_TYPE, serverConfig.getUrl(), serverConfig.getSecureUrl(), serverConfig.getUsername(), serverConfig.getPassword());\n                        } else {\n                            asyncDataPublisher = new DataPublisher(serverConfig.getUrl(), serverConfig.getUsername(), serverConfig.getPassword());\n                        }\n                    } catch (DataEndpointAgentConfigurationException | DataEndpointException | DataEndpointConfigurationException | DataEndpointAuthenticationException | TransportException e) {\n                        String errorMsg = \"Error occurred while creating data publisher\";",
        "pred_variables": [
            "Error",
            "asyncDataPublisher"
        ],
        "label_variables": [
            "errorMsg"
        ]
    },
    {
        "code": "@Override\npublic void visitSequenceClose(String name, long id) {\n    tab--;",
        "pred_variables": [
            "id",
            "name"
        ],
        "label_variables": [
            "name"
        ]
    },
    {
        "code": "@ParameterizedTest\n@EnumSource(names = { \"DEFAULT\", \"X32\", \"X64\" })\nvoid testSpecificVersions(Architecture architecture) throws Exception {\n    for (String specificVersion : specificVersions) {\n        WebDriverManager wdm = WebDriverManager.getInstance(driverClass).avoidResolutionCache().driverVersion(specificVersion);\n        if (architecture != DEFAULT) {\n            wdm.architecture(architecture);\n        }\n        String osLabel = \"\";\n        if (os != null) {\n            wdm.operatingSystem(os);\n            osLabel = \" os=\" + os;\n        }",
        "pred_variables": [
            "driverClass",
            "architecture"
        ],
        "label_variables": [
            "specificVersion",
            "osLabel",
            "architecture"
        ]
    },
    {
        "code": "@Override\npublic CompletableFuture<Void> createTopic(String topic, int partitions) {\n    return CompletableFuture.runAsync(() -> {\n        try {\n            namespace.createLog(topic);\n            if (partitions > 1) {\n                for (int i = 0; i < partitions; i++) {\n                    namespace.createLog(getFullyQualifiedPartitionedStreamName(topic, i));\n                }\n            }",
        "pred_variables": [
            "i"
        ],
        "label_variables": [
            "partitions",
            "topic"
        ]
    },
    {
        "code": "@Override\npublic void started(Path logFile, long logVersion) {",
        "pred_variables": [
            "logVersion",
            "logFile"
        ],
        "label_variables": [
            "logFile",
            "logVersion"
        ]
    },
    {
        "code": "/**\n * \u751f\u4ea7\u9632\u4f2a\u7801\uff0c\u8c03\u7528accountKit\u91cc\u9762\u5c01\u88c5\u597d\u7684\u65b9\u6cd5\n * @throws IOException\n * @throws VerificationException\n */\n@Test\npublic void makeAntifakeCode() throws VerificationException, IOException {\n    log.info(\"make anti code------------------------------------------------------- \", network.getBestBlockHeight());\n    BroadcastMakeAntifakeCodeResult result = null;\n    for (int i = 0; i < 1; i++) {\n        String productTx = \"ec0618332cd5330f82fb4d28b931b9e88c74db802b2ff7fff9bf84fa7f13187f\";\n        Coin reward = Coin.ZERO;\n        result = accountKit.makeAntifakeCode(productTx, reward, \"inchain123\");\n        log.info(\"code :\" + (i + 1));",
        "pred_variables": [
            "reward",
            "result"
        ],
        "label_variables": [
            "result"
        ]
    },
    {
        "code": "public void contextInitialized(ServletContextEvent event) {\n    LOG.debug(\"Initializing ActiveMQ WebConsole...\");\n    String webconsoleType = getWebconsoleType();\n    ServletContext servletContext = event.getServletContext();\n    WebApplicationContext context = createWebapplicationContext(servletContext, webconsoleType);\n    initializeWebClient(servletContext, context);\n    // for embedded console log what port it uses\n    if (\"embedded\".equals(webconsoleType)) {\n        // show the url for the web consoles / main page so people can spot it\n        String port = System.getProperty(\"jetty.port\");\n        String host = System.getProperty(\"jetty.host\");\n        if (host != null && port != null) {",
        "pred_variables": [
            "host",
            "port"
        ],
        "label_variables": [
            "port",
            "host"
        ]
    },
    {
        "code": "@Test\npublic void testGetNextScheduledJob() throws Exception {\n    JobSchedulerViewMBean view = getJobSchedulerMBean();\n    assertNotNull(view);\n    assertTrue(view.getAllJobs().isEmpty());\n    scheduleMessage(60000, 0, 0);\n    assertFalse(view.getAllJobs().isEmpty());\n    long before = System.currentTimeMillis() + 57 * 1000;\n    long toLate = System.currentTimeMillis() + 63 * 1000;\n    String next = view.getNextScheduleTime();\n    long nextTime = JobSupport.getDataTime(next);",
        "pred_variables": [
            "before",
            "next"
        ],
        "label_variables": [
            "next",
            "before"
        ]
    },
    {
        "code": "private static Optional<? extends ServerEvent> parse(Event event) {\n    var eventType = event.getType();\n    if (!parsersByType.containsKey(eventType)) {",
        "pred_variables": [
            "event",
            "eventType",
            "var",
            "Event"
        ],
        "label_variables": [
            "eventType"
        ]
    },
    {
        "code": "public static void printMBeanInfo(ObjectName objectName, String className) {",
        "pred_variables": [
            "objectName",
            "className"
        ],
        "label_variables": [
            "className"
        ]
    },
    {
        "code": "@Test\npublic void testClientDigest() throws InterruptedException {\n    log.info(\"\\ntestClientDigest\");\n    OutboundHandshake out = new OutboundHandshake();\n    int algorithm = 0;\n    byte[] handshakeBytes = out.generateClientRequest1().array();\n    // get the handshake digest\n    int digestPos = out.getDigestOffset(algorithm, handshakeBytes, 0);",
        "pred_variables": [
            "digestPos"
        ],
        "label_variables": [
            "digestPos"
        ]
    },
    {
        "code": "public void variousLogMessageSafe(Log log) {\n    String input = \"\";",
        "pred_variables": [
            "input",
            "log"
        ],
        "label_variables": [
            "input"
        ]
    },
    {
        "code": "/**\n * Release a lock.\n *\n * @param lockImpl the lock implementation\n * @param lock the lock\n * @param token the unique token\n * @param log the Logger\n */\npublic static void releaseLock(Lock lockImpl, String lock, String token, Logger log) {\n    if (lockImpl == null) {\n        log.info(\"No lock implementation defined, going to pretend like we released the lock\");\n        return;\n    }",
        "pred_variables": [
            "lockImpl",
            "token"
        ],
        "label_variables": [
            "lock",
            "token"
        ]
    },
    {
        "code": "private void registerCouchbaseEnvironment(CouchbaseContainer couchbase, ConfigurableEnvironment environment, CouchbaseProperties properties) {\n    Integer mappedHttpPort = couchbase.getBootstrapHttpDirectPort();\n    Integer mappedCarrierPort = couchbase.getBootstrapCarrierDirectPort();\n    String host = couchbase.getHost();\n    System.setProperty(\"com.couchbase.bootstrapHttpDirectPort\", String.valueOf(mappedHttpPort));\n    System.setProperty(\"com.couchbase.bootstrapCarrierDirectPort\", String.valueOf(mappedCarrierPort));\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.couchbase.bootstrapHttpDirectPort\", mappedHttpPort);\n    map.put(\"embedded.couchbase.bootstrapCarrierDirectPort\", mappedCarrierPort);\n    map.put(\"embedded.couchbase.host\", host);\n    map.put(\"embedded.couchbase.bucket\", properties.bucket);\n    map.put(\"embedded.couchbase.user\", properties.user);\n    map.put(\"embedded.couchbase.password\", properties.password);",
        "pred_variables": [
            "host",
            "mappedHttpPort",
            "properties",
            "com"
        ],
        "label_variables": [
            "mappedHttpPort",
            "map"
        ]
    },
    {
        "code": "private void addVault(Path pathToVault) {\n    try {\n        if (pathToVault.getFileName().toString().endsWith(CRYPTOMATOR_FILENAME_EXT)) {\n            vaultListManager.add(pathToVault.getParent());\n        } else {\n            vaultListManager.add(pathToVault);\n        }\n    } catch (IOException e) {",
        "pred_variables": [
            "toString",
            "pathToVault"
        ],
        "label_variables": [
            "pathToVault"
        ]
    },
    {
        "code": "@Override\npublic void removeConnection(ConnectionContext context, ConnectionInfo info, Throwable error) throws Exception {",
        "pred_variables": [
            "error"
        ],
        "label_variables": [
            "error"
        ]
    },
    {
        "code": "@Override\npublic void run() {\n    final FileTime now = FileTime.fromMillis(System.currentTimeMillis());\n    for (final Handler handler : this.server.getChildHandlersByClass(WebAppContext.class)) {\n        final File tempDirectory = ((WebAppContext) handler).getTempDirectory();\n        try {",
        "pred_variables": [
            "tempDirectory"
        ],
        "label_variables": [
            "tempDirectory"
        ]
    },
    {
        "code": "private static void log(String message) {",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "        return true;\n    }\n    if (!this.canHandleData(data)) {\n        return false;\n    }\n    byte first = data.get();\n    //log.trace(\"First byte: {}\", HexDump.toHexString(first));\n    data.rewind();\n    // get frame type\n    int frameType = (first & MASK_VIDEO_FRAMETYPE) >> 4;\n    if (frameType != FLAG_FRAMETYPE_KEYFRAME) {\n        // Not a keyframe\n        try {\n            int lastInterframe = numInterframes.getAndIncrement();\n            if (frameType != FLAG_FRAMETYPE_DISPOSABLE) {",
        "pred_variables": [
            "frameType",
            "keyframe"
        ],
        "label_variables": [
            "lastInterframe"
        ]
    },
    {
        "code": "    driver.findElement(By.xpath(\"//span[text()='=']\")).click();\n    // ... should be 4, wait for it\n    WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));\n    wait.until(ExpectedConditions.textToBe(By.className(\"screen\"), \"4\"));\n    wdm.stopRecording();\n    long timeoutMs = System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(REC_TIMEOUT_SEC);\n    File recFile;\n    do {\n        recFile = new File(targetFolder, REC_FILENAME + REC_EXT);\n        if (System.currentTimeMillis() > timeoutMs) {\n            fail(\"Timeout of \" + REC_TIMEOUT_SEC + \" seconds waiting for recording \" + recFile);\n            break;\n        }\n        Thread.sleep(POLL_TIME_MSEC);\n    } while (!recFile.exists());",
        "pred_variables": [
            "System",
            "targetFolder",
            "recFile",
            "By",
            "timeoutMs",
            "REC_FILENAME"
        ],
        "label_variables": [
            "recFile"
        ]
    },
    {
        "code": "@Override\npublic void run() {\n    try {\n        int i = 0;\n        while (consumer.receive(1000) != null) {\n            i++;\n            if (i % 1000 == 0) {",
        "pred_variables": [
            "i"
        ],
        "label_variables": [
            "i"
        ]
    },
    {
        "code": "private void loggingThroughFile(OAuth2AuditLog oAuth2AuditLog) {\n    try {",
        "pred_variables": [
            "oAuth2AuditLog"
        ],
        "label_variables": [
            "oAuth2AuditLog"
        ]
    },
    {
        "code": "@Override\npublic boolean accept(File dir, String name) {",
        "pred_variables": [
            "name"
        ],
        "label_variables": [
            "name"
        ]
    },
    {
        "code": "/**\n * \u6d4b\u8bd5\u7f51\u7edc\u7684\u521b\u4e16\u5757\n */\n@Override\npublic BlockStore getGengsisBlock() {\n    BlockStore gengsisBlock = new BlockStore(this, Hex.decode(\"00000000000000000000000000000000000000000000000000000000000000000000000000cc3019924136d3f7ccdd2bc73066941f916c2ea728bf91a4b781c6ab8677e6fdda7e59000000000000fdda7e59832102883a9625a871e79c070e316edafc97eac2f6c97b218d0e55726f25be2a963e9276a9144237cccf6ff9a7674a8fc47c60278fdd23e9f30988473045022100822be165776411571bee4f885a2785dacef21506408788024490b8d63883b14202207c2071d5cbaa367a7c7e22160c540347b8aa51dee1b4c42c3670b9a49f3d3566ac140101000000010012117468697320612067656e6773697320747800000000010080faca73f91f00000000001976a914bb7e4d6ffb3266a0b533b21847bef4dacce95f4688acfdda7e59000000000002010000000101c58e0dfe559f48f3eae222e0d679dd648e70e7c0f4af06bcd5c2b510fcb7e837000000006a473044022055c76d8395f95118958e71ad2a10db0bf62bdc54dd129686cd334fb2a84dc2390220787796e6a843140091ce6aa807118f2ec5727cb468d20c2aea65738684be9a4501210276c52ff14acd4c4d3e08f9596e0127a15e98207b3d0024426364825cd724c86dffffffff020080c6a47e8d03000078c2481976a9144237cccf6ff9a7674a8fc47c60278fdd23e9f30988ac00003426f56b1c00000000001976a914bb7e4d6ffb3266a0b533b21847bef4dacce95f4688acfeda7e5900000000000601000000feda7e59822102883a9625a871e79c070e316edafc97eac2f6c97b218d0e55726f25be2a963e9276a9144237cccf6ff9a7674a8fc47c60278fdd23e9f30988463044022100c8276028ab51982a34fa3d3aa5b5749669ae44448fd2bbf1c2e98bee64e96353021f459cd25897462a186ecea74984b29d5167be43954d9e23185f81d5b2931e24ac4237cccf6ff9a7674a8fc47c60278fdd23e9f30901000000000000000000000000000000000000000000000000000000000000000000000000000000000002010000000101d071ee50c095aa0c51c0b4d1eae4783fd60c17eeeaf055ed35d15697f5a8aa1a010000006a473044022074cf760a00d5bc6fb01baa24a94fa2b7cea3ee770138dc4fe9bd167ea8b7224c02202c3a421fa6c7b0e1df152d31ffd3406bd8ba2c2b26f4ad04234db6d587afdcbb01210276c52ff14acd4c4d3e08f9596e0127a15e98207b3d0024426364825cd724c86dffffffff020010a5d4e8000000000000001976a9144237cccf6ff9a7674a8fc47c60278fdd23e9f30988ac00c0b91502111c00000000001976a914bb7e4d6ffb3266a0b533b21847bef4dacce95f4688acfeda7e59000000000003010000000000feda7e590000000000822102883a9625a871e79c070e316edafc97eac2f6c97b218d0e55726f25be2a963e9276a9144237cccf6ff9a7674a8fc47c60278fdd23e9f3098846304402204b2eb744c120e5484a8c8f78bc56242a4dd29501a47776a6600d9d5a36a05d7f02205c4816cf6230ba3c9d6f77d517242256ba33dfa85ab7d74dc9ede6d8339823f7ac82db86974237cccf6ff9a7674a8fc47c60278fdd23e9f3090601000000feda7e59832103a7db4a854e3f2ae3a30aa759bfd39045f6a80c967b3fd81036acebc54b557ece76a9142c1179b1e05fb8652644f6c61a033d28431009128847304502210091bc31854e35679cf0d590de1744dd1d58414ea8c602baa6c002c6d16270a76c02204a208ca7f5e4b07e7c525ff7f13885ff9e64598321b6c826c0d89f2f11b74ec7ac2c1179b1e05fb8652644f6c61a033d2843100912010000000000000000000000000000000000000000000000000000000000000000000000000000000000020100000001016f18243ef25c20e27b444018c6d3973afe5dc5e17a76900a35602934abfcbc6d010000006a473044022047e4be626483eb49874d84cace06f6270e7069ef03b17607e6c154d3314792a802201761c8d752fb4f3ced897e8681b5348dbb6620b5e87f4b3044726279215c870f01210276c52ff14acd4c4d3e08f9596e0127a15e98207b3d0024426364825cd724c86dffffffff020010a5d4e8000000000000001976a9142c1179b1e05fb8652644f6c61a033d284310091288ac00803f050fb61b00000000001976a914bb7e4d6ffb3266a0b533b21847bef4dacce95f4688acfeda7e59000000000003010000000000feda7e590000000000822103a7db4a854e3f2ae3a30aa759bfd39045f6a80c967b3fd81036acebc54b557ece76a9142c1179b1e05fb8652644f6c61a033d284310091288463044022063ed166fb3e3302156799053c1965be1a4b14c4be4388495803285fb336c4a5f02207995aaae813270e78a4e81538404ee806d9e479b2449d4200fe46d3991bcb563ac95db86972c1179b1e05fb8652644f6c61a033d28431009120601000000feda7e598321033e371b2f3d42dd525833bcce12cb0d404fb73898bdea3e6794bd8ec552c9ba9c76a914b3fcd687a5c2b2617de0d504cfa7d12db93bb00c88473045022100a7037bbf30c8a7b1d5d4889611b6a7847e1890a183772144fe0d7b31cc8239de02203dbcc972e939993be5a630c762aa7e71aa13e8c32db89694789df883e8b5bdf6acb3fcd687a5c2b2617de0d504cfa7d12db93bb00c01000000000000000000000000000000000000000000000000000000000000000000000000000000000002010000000101fc68d536143f463dc9faf5f7fd91c164a7452430190428909231bc5b35dc4f49010000006a473044022022e49a752f7b0cc62eaafd5e674c05fc1f8912b3f4ab06f6f08a620e0ab99d02022026f5d1ca0afc368a0fcae5ba9d3d5e4e302d44f45511bcef3549243b2d8d6d4701210276c52ff14acd4c4d3e08f9596e0127a15e98207b3d0024426364825cd724c86dffffffff020010a5d4e8000000000000001976a914b3fcd687a5c2b2617de0d504cfa7d12db93bb00c88ac0040c5f41b5b1b00000000001976a914bb7e4d6ffb3266a0b533b21847bef4dacce95f4688acfeda7e59000000000003010000000000feda7e5900000000008321033e371b2f3d42dd525833bcce12cb0d404fb73898bdea3e6794bd8ec552c9ba9c76a914b3fcd687a5c2b2617de0d504cfa7d12db93bb00c88473045022100a1582b1152f841141f58e7039dafda5188ebd86337e79f382e87c1d3c485b7f002203fdd9d53d015fd700c3177f16dffbbcff928a439fdd03eb50aae3617ff4c520aac9adb8697b3fcd687a5c2b2617de0d504cfa7d12db93bb00c0601000000feda7e59832103bf7759e9b81f8ff1b99732b3ee36aea0abff68c818b8839c318ad350e9642cb076a914c3bfdb8a67f35b6e4ea1ee3ae7b91eff58ec81a8884730450221008ed069cd3d6a80b581988134f5064a0da1318f4c76d69bb7499a4d2000a1561c02204cd2c2662e9b8c0ec042d5a815ec7be626c6c5cf9be9ce6885e0e373d23f32a2acc3bfdb8a67f35b6e4ea1ee3ae7b91eff58ec81a8010000000000000000000000000000000000000000000000000000000000000000000000000000000000020100000001017bf6dec121b65c8c8ce4f9d22fbf644733fea228e351180585033bde0e1b85a2010000006a473044022028dc85f0e5c6c2a868825943c175013abe82f1085a03ad90f8e9857992f440ed0220744b338f005d43731e717f31a873cfec5803ef42ccc1ff4087b01aef5e8fd31401210276c52ff14acd4c4d3e08f9596e0127a15e98207b3d0024426364825cd724c86dffffffff020010a5d4e8000000000000001976a914c3bfdb8a67f35b6e4ea1ee3ae7b91eff58ec81a888ac00004be428001b00000000001976a914bb7e4d6ffb3266a0b533b21847bef4dacce95f4688acfeda7e5900000000000601000000feda7e5983210200d482122f8537ad2fa1af1914e088d6b308824a8ef4dc8b68fa0e0a88c484e376a9145f1a078b610d92a3110b2c1a7f880b0d2442e53088473045022100c36001db4676050eef55bc0f9100c761e3c72517defc1fa3b43e15736f5283eb0220494f9b47180e83ea508046ac51789b451b4475688b12773539bc8bdb891f4615ac5f1a078b610d92a3110b2c1a7f880b0d2442e53001000000000000000000000000000000000000000000000000000000000000000000000000000000000002010000000101f7e2e4ba55fab9e14f17e80cb3dc40e26b1efb3689ed1d2fd1de6fb96b2e7412010000006a47304402200dba9df5c1445d73af50a0f6f13469f6e4c50abeb1958073b3b0aa5fdca1b2410220472c198c3fc288f651a0f552932f51f3989ed8b457e76e138b1527e5be0d008101210276c52ff14acd4c4d3e08f9596e0127a15e98207b3d0024426364825cd724c86dffffffff020010a5d4e8000000000000001976a9145f1a078b610d92a3110b2c1a7f880b0d2442e53088ac00c0d0d335a51a00000000001976a914bb7e4d6ffb3266a0b533b21847bef4dacce95f4688acfeda7e5900000000000601000000feda7e59832103e8769d1901a4ef006054405c16716d6648fffe628385db5586c7fa18c3df5da876a914df639c6066a817a6be28b532839f8e1e85594cd488473045022100ac7e5e7b619007a14c997edb67ea8027c53aee3803bc11f855aeb7b709abb6d002206c8970a35f68620130f80b3350a2a929e1258e8169eeb128141770411d2259bbacdf639c6066a817a6be28b532839f8e1e85594cd401000000000000000000000000000000000000000000000000000000000000000000000000000000000002010000000101d952e5a18d84d31851f2945406586d909323709c054d6c2a4f6993b1cc37207e010000006a473044022076f0a9cdd46046a3fdf018a21e8d1be98e46510b6c8dfff26206836b34d1c641022067ff8112c3f430dfab5e15eb9288f29786a8f7781520e3d387373150453d66cc01210276c52ff14acd4c4d3e08f9596e0127a15e98207b3d0024426364825cd724c86dffffffff020010a5d4e8000000000000001976a914df639c6066a817a6be28b532839f8e1e85594cd488ac008056c3424a1a00000000001976a914bb7e4d6ffb3266a0b533b21847bef4dacce95f4688acfeda7e5900000000000601000000feda7e59832103368f8061e02694e37da199c07c3e2f2506cdd748efee493f0d1c52ae7494428f76a914e3453a80144f6ac24baf01f20455c6167b985485884730450221009a406555174e5ace2a970281cd9ee5480ff3a380f5e83a3640f65bf1b6ecb815022003f3691301ff45fe4cf91a013bb9dd0c4450f5bae9912cc9ec4868a88ec6d96bace3453a80144f6ac24baf01f20455c6167b9854850100000000000000000000000000000000000000000000000000000000000000000000000000000000000201000000010137ad0d22028c39abc39d21066ee7ae9d7b495ad048a17f9b4a14a48af998e68d010000006a47304402206b8d399e52b28bb5cfa5153f4c8909fb2549b9b8097864e47e29a387d84a0f71022079535b406d28416a3b9268be689113a0f100c46bbcb74d7fdaac6f3302a34db301210276c52ff14acd4c4d3e08f9596e0127a15e98207b3d0024426364825cd724c86dffffffff020010a5d4e8000000000000001976a914e3453a80144f6ac24baf01f20455c6167b98548588ac0040dcb24fef1900000000001976a914bb7e4d6ffb3266a0b533b21847bef4dacce95f4688acfeda7e5900000000000b0100000043da7e5982c220256303b7fa1e89761bf37c1a8415524dbcb9ec1b4033ce71d4224699e8459235c314dd1c14ee4f4642eb9c3e14cc97a3c3d3629708ea88473045022100c50a56f6bb25ea2ade3b83def48d7b55401916f711a634a8b2163b555343cef502203cda9a0c6735c72cf4599def1eaec90f32206e69ded301be46168aa2ad0286aaacdd1c14ee4f4642eb9c3e14cc97a3c3d3629708eadd1c14ee4f4642eb9c3e14cc97a3c3d3629708ea01fd23022b046e616d6506e5908de7a7b01ee9878de5ba86e58db0e993bee7a791e68a80e69c89e99990e585ace58fb822076164647265737306e59cb0e59d8012e9878de5ba86e5b882e58d97e5b2b8e58cba44046c6f676f06e59bbee7898737687474703a2f2f66696c652e696e636861696e2e6f72672f696d616765732f696e636861696e5f6c6f676f5f313030783130302e706e672b0a637265646974436f64650ce4bfa1e794a8e4bba3e7a0811239313530303130384d41355542333248334e1a0570686f6e6506e794b5e8af9d0c3032332d383633333130363927077765627369746506e5ae98e7bd911768747470733a2f2f7777772e696e636861696e2e6f7267fd1d0108646573637269707406e68f8fe8bfb0fd0a01e9878de5ba86e58db0e993bee7a791e68a80e69c89e99990e585ace58fb8e698afe4b880e5aeb6e4bba5e58cbae59d97e993bee68a80e69cafe9a9b1e58aa8e79a84e5889be696b0e59e8be4bc81e4b89aefbc8ce585b6e4b8bbe5afbce79a84e58cbae59d97e993bee7a4bee58cbae9a1b9e79bae496e636861696e2de58db0e993bee698afe4b880e4b8aae4bba5e998b2e4bcaae4b8bae59fbae7a180e4b89ae58aa1e79a84e585ace5bc80e5b9b3e58fb0efbc8ce4b8bae7a4bee4bc9ae59084e4bc81e4b89ae38081e69cbae69e84e38081e889bae69cafe5aeb6e7ad89e68f90e4be9be59381e7898ce38081e79fa5e8af86e4baa7e69d83e4bf9de68aa4e69c8de58aa1e380820221023cbfda1ae93a41187634206177a0482ee2c890540bd907a7f6fbdde9e5a31c3b2103489e3933f41327c2463b664776a4355860cf5b093c106d21f0253f83dda76465012103df243c24dfe4ea420c776e8d46fbc2a86c6e439648119f64b583a38a0c7d84fd00\"));\n    Sha256Hash merkleHash = gengsisBlock.getBlock().buildMerkleHash();\n    if (log.isDebugEnabled()) {",
        "pred_variables": [
            "Sha256Hash",
            "merkleHash"
        ],
        "label_variables": [
            "merkleHash"
        ]
    },
    {
        "code": "/**\n * Assigns the property name to an id value of a given url. <br >\n * You can add for example:\n *\n * <pre>\n * addProperty(\"/vehicle/v1/id\", \"identityId\", \"identity.id\")\n * addProperty(\"/vehicle/v1/id\", \"vehicleId\", \"vehicle.id\")\n * </pre>\n *\n * @param url\n * @param value\n * @param propertyName\n */\npublic void addProperty(String url, String value, String propertyName) {",
        "pred_variables": [
            "url",
            "propertyName",
            "value",
            "vehicle"
        ],
        "label_variables": [
            "propertyName",
            "value",
            "url"
        ]
    },
    {
        "code": "public List<DockerHubTag> listTags(String dockerImageFormat) {\n    log.debug(\"Getting browser image list from Docker Hub\");\n    List<DockerHubTag> results = new ArrayList<>();\n    String dockerHubUrl = config.getDockerHubUrl();\n    String repo = dockerImageFormat.substring(0, dockerImageFormat.indexOf(\":\"));\n    Object url = String.format(GET_IMAGE_TAGS_PATH_FORMAT, dockerHubUrl, repo, 1);\n    Gson gson = new GsonBuilder().create();\n    try {\n        do {",
        "pred_variables": [
            "url"
        ],
        "label_variables": [
            "url"
        ]
    },
    {
        "code": "@Test(timeout = 60000)\npublic void testTempQueueIssue() throws JMSException, InterruptedException {\n    ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(\"vm://localhost?broker.persistent=false&broker.useJmx=false\");\n    final PooledConnectionFactory cf = new PooledConnectionFactory();\n    cf.setConnectionFactory(factory);\n    Connection connection = cf.createConnection();\n    connection.start();\n    Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);",
        "pred_variables": [
            "connection"
        ],
        "label_variables": [
            "connection"
        ]
    },
    {
        "code": "@Override\npublic void onWebSocketClose(int arg0, String arg1) {\n    try {\n        if (protocolLock.tryLock() || protocolLock.tryLock(ORDERLY_CLOSE_TIMEOUT, TimeUnit.SECONDS)) {",
        "pred_variables": [
            "arg0",
            "arg1"
        ],
        "label_variables": [
            "arg1",
            "arg0"
        ]
    },
    {
        "code": "private boolean executeExternalAuthenticate(CustomScriptConfiguration customScriptConfiguration, ExternalResourceOwnerPasswordCredentialsContext context) {\n    try {",
        "pred_variables": [
            "customScriptConfiguration"
        ],
        "label_variables": [
            "context"
        ]
    },
    {
        "code": "@Override\nprotected void channelRead0(ChannelHandlerContext ctx, RequestMessage msg) throws Exception {",
        "pred_variables": [
            "msg"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "// doc comment inherited from LogWriter\npublic void logReceivedException(Logger log, IOException error) {",
        "pred_variables": [
            "error"
        ],
        "label_variables": [
            "error"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"oracle\")\nToxiproxyContainer.ContainerProxy oracleContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(BEAN_NAME_EMBEDDED_ORACLE) OracleContainer oracle, ConfigurableEnvironment environment) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(oracle, ORACLE_PORT);\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.oracle.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.oracle.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.oracle.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedOracleToxiproxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [
            "propertySource"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "@GET\n@Path(\"{id}\")\n@Produces({ UmaConstants.JSON_MEDIA_TYPE })\npublic Response getScopeDescription(@PathParam(\"id\") String id) {",
        "pred_variables": [
            "id"
        ],
        "label_variables": [
            "id"
        ]
    },
    {
        "code": "    // Add \"Authenticated\" role\n    List<String> roles = wfRes.getRoles();\n    if (roles == null || roles.isEmpty()) {\n        roles = Collections.singletonList(\"Authenticated\");\n    } else if (getFedizContext().isAddAuthenticatedRole()) {\n        roles = new ArrayList<>(roles);\n        roles.add(\"Authenticated\");\n    }\n    // proceed creating the JAAS Subject\n    FedizPrincipal principal = new FederationPrincipalImpl(wfRes.getUsername(), roles, wfRes.getClaims(), wfRes.getToken());\n    Session session = ((Request) request).getSessionInternal();\n    // Save Federation response in our session\n    session.setNote(FederationAuthenticator.FEDERATION_NOTE, wfRes);\n    // Save Federation response in public session\n    request.getSession(true).setAttribute(FederationAuthenticator.SECURITY_TOKEN, wfRes.getToken());",
        "pred_variables": [
            "roles"
        ],
        "label_variables": [
            "principal"
        ]
    },
    {
        "code": "    params.put(\"ignore\", \".csv\");\n    String url = YahooFinance.HISTQUOTES_BASE_URL + \"?\" + Utils.getURLParameters(params);\n    // Get CSV from Yahoo\n    log.info(\"Sending request: \" + url);\n    URL request = new URL(url);\n    RedirectableRequest redirectableRequest = new RedirectableRequest(request, 5);\n    redirectableRequest.setConnectTimeout(YahooFinance.CONNECTION_TIMEOUT);\n    redirectableRequest.setReadTimeout(YahooFinance.CONNECTION_TIMEOUT);\n    URLConnection connection = redirectableRequest.openConnection();\n    InputStreamReader is = new InputStreamReader(connection.getInputStream());\n    BufferedReader br = new BufferedReader(is);\n    // skip the first line\n    br.readLine();\n    // Parse CSV\n    for (String line = br.readLine(); line != null; line = br.readLine()) {",
        "pred_variables": [
            "line"
        ],
        "label_variables": [
            "line"
        ]
    },
    {
        "code": "        for (String excludedPath : excludedPaths) {\n            String requestURI = httpRequest.getRequestURI();\n            if (requestURI.startsWith(excludedPath)) {\n                chain.doFilter(httpRequest, httpResponse);\n                return;\n            }\n        }\n    }\n    RequestWrapper requestWrapper = new RequestWrapper(httpRequest);\n    ResponseWrapper responseWrapper = new ResponseWrapper(httpResponse);\n    chain.doFilter(httpRequest, httpResponse);\n    Duration duration = duration(start);\n    // yuriyz: log request and response only after filter handling.\n    // #914 - we don't want to effect server functionality due to logging. Currently content can be messed if it is InputStream.\n    if (log.isDebugEnabled()) {",
        "pred_variables": [
            "duration",
            "requestURI"
        ],
        "label_variables": [
            "duration",
            "requestWrapper"
        ]
    },
    {
        "code": "private void registerRabbitMQEnvironment(RabbitMQContainer rabbitMQ, ConfigurableEnvironment environment, RabbitMQProperties properties) {\n    Integer mappedPort = rabbitMQ.getMappedPort(properties.getPort());\n    Integer mappedHttpPort = rabbitMQ.getMappedPort(properties.getHttpPort());\n    String host = rabbitMQ.getHost();\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.rabbitmq.port\", mappedPort);\n    map.put(\"embedded.rabbitmq.host\", host);\n    map.put(\"embedded.rabbitmq.vhost\", properties.getVhost());\n    map.put(\"embedded.rabbitmq.user\", rabbitMQ.getAdminUsername());\n    map.put(\"embedded.rabbitmq.password\", rabbitMQ.getAdminPassword());\n    map.put(\"embedded.rabbitmq.httpPort\", mappedHttpPort);",
        "pred_variables": [
            "rabbitmq",
            "mappedPort",
            "properties"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "@Override\nprotected void addGraph(final String name, final String configurationFile) {\n    try {\n        final Graph newGraph = GraphFactory.open(configurationFile);\n        putGraph(name, newGraph);",
        "pred_variables": [
            "newGraph"
        ],
        "label_variables": [
            "configurationFile",
            "name"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"influxdb\")\nToxiproxyContainer.ContainerProxy influxdbContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(EMBEDDED_INFLUX_DB) ConcreteInfluxDbContainer influxdb, InfluxDBProperties properties, ConfigurableEnvironment environment) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(influxdb, properties.getPort());\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.influxdb.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.influxdb.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.influxdb.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedInfluxDBToxiproxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "/**\n * Return scope associated with given path from given root scope.\n *\n * @param root\n *            Scope to start from\n * @param path\n *            Scope path\n * @return Scope object\n */\npublic IScope resolveScope(IScope root, String path) {",
        "pred_variables": [
            "path",
            "root"
        ],
        "label_variables": [
            "path",
            "root"
        ]
    },
    {
        "code": "@Override\npublic void visitFragmentClose(String name, long id) {\n    tab--;",
        "pred_variables": [
            "id",
            "name"
        ],
        "label_variables": [
            "name"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"postgresql\")\nToxiproxyContainer.ContainerProxy postgresqlContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(BEAN_NAME_EMBEDDED_POSTGRESQL) PostgreSQLContainer postgresql, ConfigurableEnvironment environment) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(postgresql, PostgreSQLContainer.POSTGRESQL_PORT);\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.postgresql.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.postgresql.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.postgresql.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedPostgresqlToxiproxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "public boolean revokeToken(CustomScriptConfiguration script, RevokeTokenContext context) {\n    try {",
        "pred_variables": [
            "script"
        ],
        "label_variables": [
            "context"
        ]
    },
    {
        "code": "/**\n * Performs the initial GET request of the zip resource.\n *\n * @param req\n * @param zipUrl\n * @param insidePath\n */\nprotected void performGETRequest(final HttpServerRequest req, final String zipUrl, final String insidePath) {\n    Logger log = RequestLoggerFactory.getLogger(ZipExtractHandler.class, req);\n    // perform Initial GET request\n    selfClient.request(HttpMethod.GET, zipUrl).onComplete(asyncReqResult -> {\n        if (asyncReqResult.failed()) {",
        "pred_variables": [
            "request",
            "zipUrl",
            "req"
        ],
        "label_variables": [
            "zipUrl"
        ]
    },
    {
        "code": "@Test\npublic void testFLVReaderFileWithMetaData() {\n    log.info(\"\\n testFLVReaderFileWithMetaData\");\n    String[] paths = new String[] { \"target/test-classes/fixtures/flashContent.flv\", \"target/test-classes/fixtures/flashContent1.flv\" };\n    try {\n        for (String path : paths) {\n            File file = Paths.get(path).toFile();\n            if (file.exists() && file.canRead()) {\n                log.info(\"Reading: {}\", file.getName());\n                FLVReader reader = new FLVReader(file, false);\n                ITag tag = null;\n                while (reader.hasMoreTags()) {\n                    tag = reader.readTag();\n                    if (tag != null && tag.getDataType() > 9) {",
        "pred_variables": [],
        "label_variables": [
            "tag"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"pulsar\")\nToxiproxyContainer.ContainerProxy pulsarContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(EMBEDDED_PULSAR) PulsarContainer embeddedPulsar, PulsarProperties pulsarProperties, ConfigurableEnvironment environment) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(embeddedPulsar, pulsarProperties.getBrokerPort());\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.pulsar.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.pulsar.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.pulsar.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedPulsarToxiproxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [
            "propertySource"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "private void updateConnection(AbstractConnectionConfiguration connectionConfiguration) {\n    var connectionId = connectionConfiguration.getConnectionId();\n    var previous = repository.addOrReplace(connectionConfiguration);\n    if (previous == null) {",
        "pred_variables": [
            "connectionConfiguration",
            "var"
        ],
        "label_variables": [
            "connectionId"
        ]
    },
    {
        "code": "public MqttAsyncClient getMqttClient(String identifier) {\n    if (tenantLoadingFlagMap.containsKey(identifier)) {\n        //this is manually tenant loading case should return the client\n        return mqttClientMap.get(identifier);\n    } else {\n        MqttAsyncCallback callback = mqttCallbackMap.get(identifier);\n        //this is the case where recreation of same bounded inbound endpoint for server host\n        //server port, client id\n        String msg = \"Client ID: \" + callback.getMqttConnectionConsumer().getMqttAsyncClient().getClientId() + \" Server Host: \" + callback.getMqttConnectionConsumer().getMqttConnectionFactory().getServerHost() + \" Server Port: \" + callback.getMqttConnectionConsumer().getMqttConnectionFactory().getServerPort() + \" is bound to existing MQTT Inbound Endpoint.\";",
        "pred_variables": [
            "Server",
            "identifier"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "public void commence(final HttpServletRequest servletRequest, final HttpServletResponse response, final AuthenticationException authenticationException) throws IOException, ServletException {\n    FedizContext fedContext = federationConfig.getFedizContext();",
        "pred_variables": [
            "fedContext",
            "FedizContext"
        ],
        "label_variables": [
            "fedContext"
        ]
    },
    {
        "code": "        ngramInfoIterator = ngramInfo.iterator();\n        for (String term : terms) {\n            try {\n                if (ngramInfoIterator.seekExact(new BytesRef(term.getBytes(\"UTF-8\")))) {\n                    PostingsEnum docEnum = ngramInfoIterator.postings(null);\n                    int doc = 0;\n                    while ((doc = docEnum.nextDoc()) != PostingsEnum.NO_MORE_DOCS) {\n                        //tf in document\n                        int tfid = docEnum.freq();\n                        feature.increment(term, tfid);\n                        feature.incrementTermFrequencyInDocument(term, doc, tfid);\n                    }\n                    totalSuccess++;\n                } else {\n                    String warning = String.format(\"'%s'  is a candidate term, but not indexed in the n-gram \" + \"information field. It's score may be mis-computed. You may have used different text \" + \"analysis process (e.g., different tokenizers, different analysis order, limited \" + \"n-gram range) for the text-2-candidate-term and text-2-ngram fields.) \", term);",
        "pred_variables": [
            "warning"
        ],
        "label_variables": [
            "warning"
        ]
    },
    {
        "code": "@Override\npublic CompletableFuture<Void> createTopic(String topic, int partitions) {\n    try {\n        JetStreamManagement jsm = connection.jetStreamManagement();\n        StreamInfo streamInfo = jsm.addStream(StreamConfiguration.builder().name(topic).subjects(topic).storageType(StorageType.File).replicas(config.replicationFactor).build());",
        "pred_variables": [
            "topic",
            "addStream",
            "File"
        ],
        "label_variables": [
            "topic",
            "streamInfo"
        ]
    },
    {
        "code": "@Override\npublic void visitUTF8(String name, long id, CharSequence value) {",
        "pred_variables": [
            "id",
            "name"
        ],
        "label_variables": [
            "name"
        ]
    },
    {
        "code": "@Override\npublic void recoveryCleanupRegistered(Path indexFile, IndexDescriptor index) {",
        "pred_variables": [
            "indexFile",
            "index"
        ],
        "label_variables": [
            "indexFile",
            "index"
        ]
    },
    {
        "code": "@Override\npublic void pauseDetected(VmPauseMonitor.VmPauseInfo info) {",
        "pred_variables": [
            "VmPauseInfo",
            "info"
        ],
        "label_variables": [
            "info"
        ]
    },
    {
        "code": "public void fatalError(SAXParseException exception) {",
        "pred_variables": [
            "exception"
        ],
        "label_variables": [
            "exception"
        ]
    },
    {
        "code": "@Override\npublic void uncaughtException(Thread t, Throwable e) {\n    if (e instanceof OutOfMemoryError) {",
        "pred_variables": [
            "e"
        ],
        "label_variables": [
            "e"
        ]
    },
    {
        "code": "Optional<URL> buildUrl(String driverVersion, Config config) {\n    Optional<URL> optionalUrl = empty();\n    if (!config.isUseMirror()) {\n        String downloadUrlPattern = config.getEdgeDownloadUrlPattern();\n        OperatingSystem os = config.getOperatingSystem();\n        Architecture arch = config.getArchitecture();\n        String archLabel = os.isWin() ? arch.toString() : \"64\";\n        String osName = arch != ARM64 ? os.getName() : \"arm\";\n        String builtUrl = os == MAC && arch == ARM64 ? String.format(downloadUrlPattern, driverVersion, \"mac\", \"64_m1\") : String.format(downloadUrlPattern, driverVersion, osName, archLabel);",
        "pred_variables": [
            "arch",
            "String",
            "archLabel"
        ],
        "label_variables": [
            "builtUrl"
        ]
    },
    {
        "code": "public void reading(Artifact configurationId) {",
        "pred_variables": [
            "configurationId"
        ],
        "label_variables": [
            "configurationId"
        ]
    },
    {
        "code": "public void stopScheduledReport(String reportName) throws Exception {\n    try {\n        reportingAdminServiceStub.stopScheduledReport(reportName);\n    } catch (Exception e) {\n        String msg = \"Unable to stop the scheduled report\";",
        "pred_variables": [
            "msg"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "private void registerEnvironment(GenericContainer<?> grafana, ConfigurableEnvironment environment, GrafanaProperties properties) {\n    Integer mappedPort = grafana.getMappedPort(properties.port);\n    String host = grafana.getHost();\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.grafana.host\", host);\n    map.put(\"embedded.grafana.port\", mappedPort);\n    map.put(\"embedded.grafana.username\", properties.getUsername());\n    map.put(\"embedded.grafana.password\", properties.getPassword());",
        "pred_variables": [
            "host",
            "properties",
            "mappedPort",
            "getHost",
            "port"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "private void handleException(String msg, Exception ex) {",
        "pred_variables": [
            "msg",
            "ex"
        ],
        "label_variables": [
            "msg",
            "ex"
        ]
    },
    {
        "code": "public void scheduleReport(ReportConfigurationBean configuration) throws Exception {\n    try {\n        reportingAdminServiceStub.scheduleReport(configuration);\n    } catch (Exception e) {\n        String msg = \"Unable to schedule the report\";",
        "pred_variables": [
            "msg"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "@Override\npublic Void extractData(ResultSet rs) throws SQLException, DataAccessException {\n    Upgrade19DataPointRowMapper dprw = new Upgrade19DataPointRowMapper();\n    try (PrintWriter pw = new PrintWriter(createUpdateLogOutputStream())) {\n        while (rs.next()) {\n            RawDataPoint rdp = dprw.mapRow(rs, rs.getRow());\n            if (rdp.dataTypeId != null) {\n                String message = \"Updating dpid: \" + rdp.id + \" setting data type id to: \" + rdp.dataTypeId;\n                if (LOG.isDebugEnabled())",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "@Logging(logEvent = true)\npublic String handleRequest(final ScheduledEvent input, final Context context) {\n    String queueUrl = System.getenv(\"QUEUE_URL\");\n    // Push 5 messages on each invoke.\n    List<SendMessageBatchRequestEntry> batchRequestEntries = IntStream.range(0, 5).mapToObj(value -> {\n        Map<String, MessageAttributeValue> attributeValueHashMap = new HashMap<>();\n        attributeValueHashMap.put(\"Key\" + value, MessageAttributeValue.builder().dataType(\"String\").stringValue(\"Value\" + value).build());\n        byte[] array = new byte[7];\n        random.nextBytes(array);\n        return SendMessageBatchRequestEntry.builder().messageAttributes(attributeValueHashMap).id(input.getId() + value).messageBody(\"Sample Message \" + value).build();\n    }).collect(toList());\n    SendMessageBatchResponse sendMessageBatchResponse = sqsClient.sendMessageBatch(SendMessageBatchRequest.builder().queueUrl(queueUrl).entries(batchRequestEntries).build());",
        "pred_variables": [
            "String",
            "entries",
            "batchRequestEntries"
        ],
        "label_variables": [
            "sendMessageBatchResponse"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"artifactory\")\nToxiproxyContainer.ContainerProxy artifactoryContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(ARTIFACTORY_BEAN_NAME) GenericContainer<?> artifactory, ArtifactoryProperties properties, ConfigurableEnvironment environment) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(artifactory, properties.getRestApiPort());\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.artifactory.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.artifactory.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.artifactory.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedArtifactoryToxiproxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [
            "propertySource"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "SonarLintInputFile create(ClientInputFile inputFile) {\n    var defaultInputFile = new SonarLintInputFile(inputFile, f -> {\n        LOG.debug(\"Initializing metadata of file {}\", f.uri());\n        var charset = f.charset();\n        InputStream stream;\n        try {\n            stream = f.inputStream();\n        } catch (IOException e) {\n            throw new IllegalStateException(\"Failed to open a stream on file: \" + f.uri(), e);\n        }\n        return fileMetadata.readMetadata(stream, charset != null ? charset : Charset.defaultCharset(), f.uri(), exclusionsScanner.createCharHandlerFor(f));\n    });\n    defaultInputFile.setType(inputFile.isTest() ? Type.TEST : Type.MAIN);\n    var fileLanguage = inputFile.language();\n    if (fileLanguage != null) {",
        "pred_variables": [
            "f"
        ],
        "label_variables": [
            "fileLanguage"
        ]
    },
    {
        "code": "/**\n * This is to get the GenericInboundListener instance for given params\n *\n * @param inboundParams\n * @return\n */\npublic static synchronized GenericInboundListener getInstance(InboundProcessorParams inboundParams) {\n    String classImpl = inboundParams.getClassImpl();\n    String name = inboundParams.getName();\n    if (null == classImpl) {\n        String msg = \"GenericEndpointManager class not found\";",
        "pred_variables": [
            "msg"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "@Override\npublic void visitSignedInteger(String name, long id, int value) {",
        "pred_variables": [
            "id",
            "name"
        ],
        "label_variables": [
            "name"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"rabbitmq\")\nToxiproxyContainer.ContainerProxy rabbitmqContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(BEAN_NAME_EMBEDDED_RABBITMQ) RabbitMQContainer rabbitmq, ConfigurableEnvironment environment, RabbitMQProperties properties) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(rabbitmq, properties.getPort());\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.rabbitmq.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.rabbitmq.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.rabbitmq.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedRabbitmqToxiproxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [
            "propertySource"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "            for (VirtualDestination existingVirtualDest : existingVirtualDests) {\n                if (!newVirtualDests.contains(existingVirtualDest)) {\n                    removedVirtualDests.add(existingVirtualDest);\n                }\n            }\n            virtualDestinationInterceptor.setVirtualDestinations(getVirtualDestinations());\n            plugin.info(\"applied updates to: \" + virtualDestinationInterceptor);\n            updatedExistingInterceptor = true;\n            ConnectionContext connectionContext;\n            try {\n                connectionContext = plugin.getBrokerService().getAdminConnectionContext();\n                //signal updates\n                if (plugin.getBrokerService().isUseVirtualDestSubs()) {\n                    for (VirtualDestination removedVirtualDest : removedVirtualDests) {\n                        plugin.virtualDestinationRemoved(connectionContext, removedVirtualDest);",
        "pred_variables": [
            "removedVirtualDest"
        ],
        "label_variables": [
            "removedVirtualDest"
        ]
    },
    {
        "code": "public SessionId getConsentSession(HttpServletRequest httpRequest, HttpServletResponse httpResponse, String userDn, boolean create) {\n    String cookieId = cookieService.getConsentSessionIdFromCookie(httpRequest);",
        "pred_variables": [
            "httpResponse",
            "httpRequest",
            "cookieId"
        ],
        "label_variables": [
            "cookieId"
        ]
    },
    {
        "code": "public Path dumpState(Locks lm, LockWorker... workers) throws IOException {\n    try (OutputStream out = Files.newOutputStream(file)) {\n        InternalLogProvider logProvider = new Log4jLogProvider(out);\n        //  * locks held by the lock manager\n        lm.accept(new DumpLocksVisitor(logProvider.getLog(LockWorkFailureDump.class)));\n        //  * rag manager state;\n        //  * workers state\n        InternalLog log = logProvider.getLog(getClass());\n        for (LockWorker worker : workers) {\n            // - what each is doing and have up to now",
        "pred_variables": [
            "worker"
        ],
        "label_variables": [
            "worker"
        ]
    },
    {
        "code": "@Override\npublic void onAcceptError(Exception error) {",
        "pred_variables": [
            "error"
        ],
        "label_variables": [
            "error"
        ]
    },
    {
        "code": "private void processLine(String line) {\n    if (line.trim().length() == 0) {\n        return;\n    }\n    // first check the single regexp patterns that can be used to totally exclude a file\n    for (Pattern pattern : allFilePatterns) {\n        if (pattern.matcher(line).find()) {\n            // nothing more to do on this file",
        "pred_variables": [
            "line"
        ],
        "label_variables": [
            "pattern"
        ]
    },
    {
        "code": "/**\n * {@inheritDoc}\n */\n@Override\nprotected void startConnector(String server, int port) {",
        "pred_variables": [
            "port",
            "server"
        ],
        "label_variables": [
            "server",
            "port"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"mssqlserver\")\nToxiproxyContainer.ContainerProxy mssqlserverContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(BEAN_NAME_EMBEDDED_MSSQLSERVER) EmbeddedMSSQLServerContainer mssqlserver, ConfigurableEnvironment environment) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(mssqlserver, MSSQLServerContainer.MS_SQL_SERVER_PORT);\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.mssqlserver.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.mssqlserver.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.mssqlserver.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedMSSQLServerToxiproxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [
            "propertySource"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "    for (IssuePattern pattern : multicriteriaPatterns) {\n        if (pattern.matchRule(issue.ruleKey())) {\n            atLeastOneRuleMatched = true;\n            var component = ((DefaultFilterableIssue) issue).getComponent();\n            if (component.isFile()) {\n                var file = (SonarLintInputFile) component;\n                if (pattern.matchFile(file.relativePath())) {\n                    atLeastOnePatternFullyMatched = true;\n                    matchingPattern = pattern;\n                }\n            }\n        }\n    }\n    if (atLeastOneRuleMatched) {\n        if (atLeastOnePatternFullyMatched) {",
        "pred_variables": [
            "component",
            "pattern",
            "file"
        ],
        "label_variables": [
            "matchingPattern",
            "issue"
        ]
    },
    {
        "code": "private static void parseSetting(Map<SettingKey, Serializable> settings, String name, String value) {\n    SettingKey settingKey = SettingKey.definedSettingKeys().get(name.toLowerCase(Locale.ROOT));\n    if (settingKey != null) {\n        settings.put(settingKey, settingKey.type().deserializeURL(value));\n    } else {",
        "pred_variables": [
            "name",
            "value",
            "type"
        ],
        "label_variables": [
            "name",
            "value"
        ]
    },
    {
        "code": "                            feature.mweHasSymbol(term, true);\n                        else\n                            feature.mweHasSymbol(term, false);\n                        if (metadata.getMetaData(MWEMetadataType.HAS_NUMERIC_TOKEN).equalsIgnoreCase(\"true\"))\n                            feature.mweHasNumber(term, true);\n                        else\n                            feature.mweHasNumber(term, false);\n                        if (metadata.getMetaData(MWEMetadataType.HAS_ACRONYM_TOKEN).equalsIgnoreCase(\"true\"))\n                            feature.mweHasAcronym(term, true);\n                        else\n                            feature.mweHasAcronym(term, false);\n                    }\n                    totalSuccess++;\n                } else {\n                    String warning = String.format(\"'%s'  is a candidate term, but not indexed in the n-gram \" + \"information field. It's score may be mis-computed. You may have used different text \" + \"analysis process (e.g., different tokenizers, different analysis order, limited \" + \"n-gram range) for the text-2-candidate-term and text-2-ngram fields.) \", term);",
        "pred_variables": [
            "warning"
        ],
        "label_variables": [
            "warning"
        ]
    },
    {
        "code": "@Override\npublic void onException(JMSException exception) {",
        "pred_variables": [
            "exception"
        ],
        "label_variables": [
            "exception"
        ]
    },
    {
        "code": "private void tryToEnqueueFileOpenRequest(AppLaunchEvent launchEvent) {\n    if (!launchEventQueue.offer(launchEvent)) {",
        "pred_variables": [
            "launchEvent"
        ],
        "label_variables": [
            "launchEvent"
        ]
    },
    {
        "code": "@Override\npublic void onSharedObjectUpdate(ISharedObjectBase so, Map<String, Object> map) {",
        "pred_variables": [
            "so"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "@Override\npublic void onCommand(Object command) {\n    if (command.getClass() == ConnectionInfo.class || command.getClass() == BrokerInfo.class) {\n        synchronized (this) {\n            try {",
        "pred_variables": [
            "command"
        ],
        "label_variables": [
            "command"
        ]
    },
    {
        "code": "// fail only when we get an authoritative answer from the db w/o exceptions\n@Override\nprotected boolean hasLockOwnership() throws IOException {\n    boolean hasLock = true;\n    if (broker.getPersistenceAdapter() instanceof LockableServiceSupport) {\n        Locker locker = ((LockableServiceSupport) broker.getPersistenceAdapter()).getLocker();\n        if (locker != null) {\n            try {\n                if (!locker.keepAlive()) {\n                    hasLock = false;\n                }\n            } catch (SuppressReplyException ignoreWhileHandlingInProgress) {\n            } catch (IOException ignored) {\n            }\n            if (!hasLock) {",
        "pred_variables": [
            "locker"
        ],
        "label_variables": [
            "locker"
        ]
    },
    {
        "code": "@Override\npublic Message formatException(String origin, String arg1, Message arg2, Throwable arg3) {\n    NotImplementedException e = new NotImplementedException();",
        "pred_variables": [
            "e"
        ],
        "label_variables": [
            "e"
        ]
    },
    {
        "code": "    }\n    Crypto issuerCrypto = CertsUtils.getCryptoFromCertificate(idp.getCertificate());\n    X509Certificate[] issuerCerts = null;\n    String issuerKeyName = null;\n    if (issuerCrypto != null) {\n        CryptoType cryptoType = new CryptoType(CryptoType.TYPE.ALIAS);\n        issuerKeyName = issuerCrypto.getDefaultX509Identifier();\n        cryptoType.setAlias(issuerKeyName);\n        issuerCerts = issuerCrypto.getX509Certificates(cryptoType);\n    }\n    if (issuerCerts == null || issuerCerts.length == 0) {\n        throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"empty\", new Object[] { \"No issuer certs were found to sign the SAML Assertion using issuer name: \" + issuerKeyName });\n    }\n    String sigAlgo = SignatureConstants.ALGO_ID_SIGNATURE_RSA_SHA1;\n    String pubKeyAlgo = issuerCerts[0].getPublicKey().getAlgorithm();",
        "pred_variables": [
            "issuerCrypto",
            "cryptoType"
        ],
        "label_variables": [
            "pubKeyAlgo"
        ]
    },
    {
        "code": "@Override\npublic void enable(long reconciledTransactionId) {\n    requireNonNegative(reconciledTransactionId);\n    initializationLock.writeLock().lock();\n    try {\n        if (sequence == null) {",
        "pred_variables": [
            "sequence",
            "reconciledTransactionId"
        ],
        "label_variables": [
            "reconciledTransactionId"
        ]
    },
    {
        "code": "@Override\nprotected List<File> postDownload(File archive) {",
        "pred_variables": [
            "archive"
        ],
        "label_variables": [
            "archive"
        ]
    },
    {
        "code": "public void log(AuditLogEntry entry) {\n    for (AuditLog log : factory.getAuditLogs()) {",
        "pred_variables": [
            "entry"
        ],
        "label_variables": [
            "entry"
        ]
    },
    {
        "code": "        errorMap.put(\"exceptionClass\", throwable.getClass().getName());\n        errorMap.put(\"message\", throwable.getMessage());\n        errorMap.put(\"path\", path);\n        if (statusCode < 300) {\n            statusCode = 500;\n        }\n        errorMap.put(\"code\", Integer.toString(statusCode));\n        if (throwable.getCause() != null) {\n            try {\n                errorMap.put(\"cause\", objectMapper.valueToTree(throwable.getCause()));\n            } catch (Exception e) {\n                errorMap.put(\"cause\", throwable.getCause().getMessage());\n            }\n        }\n        if (throwable.getStackTrace() != null && statusCode >= 500) {",
        "pred_variables": [
            "statusCode"
        ],
        "label_variables": [
            "throwable"
        ]
    },
    {
        "code": "@Test\nvoid test() {\n    String browserContainerId = wdm.getDockerBrowserContainerId();\n    String[] command = { \"ls\", \"-l\" };\n    String result = wdm.getDockerService().execCommandInContainer(browserContainerId, command);",
        "pred_variables": [
            "wdm",
            "command"
        ],
        "label_variables": [
            "result",
            "command"
        ]
    },
    {
        "code": "public Object addingBundle(Bundle bundle, BundleEvent event) {\n    URL providerURL = bundle.getEntry(\"META-INF/services/java.sql.Driver\");\n    if (providerURL != null) {\n        List<Driver> drivers = loadDrivers(bundle, providerURL);\n        register(drivers);",
        "pred_variables": [
            "bundle"
        ],
        "label_variables": [
            "drivers",
            "bundle"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"grafana\")\nToxiproxyContainer.ContainerProxy grafanaContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(GRAFANA_BEAN_NAME) GenericContainer<?> grafana, GrafanaProperties properties, ConfigurableEnvironment environment) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(grafana, properties.getPort());\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.grafana.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.grafana.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.grafana.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedGrafanaToxiproxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [
            "propertySource"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "@Override\npublic Response requestBackchannelDeviceRegistrationPost(String idTokenHint, String deviceRegistrationToken, HttpServletRequest httpRequest, HttpServletResponse httpResponse, SecurityContext securityContext) {\n    OAuth2AuditLog oAuth2AuditLog = new OAuth2AuditLog(ServerUtil.getIpAddress(httpRequest), Action.BACKCHANNEL_DEVICE_REGISTRATION);\n    // ATTENTION : please do not add more parameter in this debug method because it will not work with Seam 2.2.2.Final,\n    // there is limit of 10 parameters (hardcoded), see: org.jboss.seam.core.Interpolator#interpolate",
        "pred_variables": [
            "httpRequest",
            "OAuth2AuditLog",
            "oAuth2AuditLog"
        ],
        "label_variables": [
            "deviceRegistrationToken",
            "idTokenHint"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"mysql\")\nToxiproxyContainer.ContainerProxy mysqlContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(BEAN_NAME_EMBEDDED_MYSQL) MySQLContainer mysql, MySQLProperties properties, ConfigurableEnvironment environment) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(mysql, properties.getPort());\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.mysql.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.mysql.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.mysql.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedMysqlToxiProxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": " * @param algorithm               The encryption / decryption algorithm\n * @param javaSecurityAPIProvider\n * @return The cleartext\n * @throws CryptoException If something unexpected happens during the decryption operation.\n */\npublic byte[] decrypt(byte[] ciphertext, String algorithm, String javaSecurityAPIProvider) throws CryptoException {\n    try {\n        Cipher cipher;\n        if (StringUtils.isBlank(javaSecurityAPIProvider)) {\n            cipher = Cipher.getInstance(algorithm);\n        } else {\n            cipher = Cipher.getInstance(algorithm, javaSecurityAPIProvider);\n        }\n        cipher.init(Cipher.DECRYPT_MODE, getPrivateKeyFromKeyStore());\n        if (log.isDebugEnabled()) {",
        "pred_variables": [
            "ciphertext",
            "javaSecurityAPIProvider",
            "cipher"
        ],
        "label_variables": [
            "javaSecurityAPIProvider",
            "algorithm"
        ]
    },
    {
        "code": "public void onStatus(IConnection conn, ObjectMap<String, Object> status) {",
        "pred_variables": [
            "conn",
            "String"
        ],
        "label_variables": [
            "status"
        ]
    },
    {
        "code": "private void traceOrDebug(boolean traceOn, String msg) {\n    if (traceOn) {\n        trace.info(msg);\n    }\n    if (log.isDebugEnabled()) {",
        "pred_variables": [
            "msg"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "@Override\npublic void put(final String uri, MultiMap headers, Buffer buffer, final Handler<Integer> doneHandler) {\n    client.request(HttpMethod.PUT, uri).onComplete(asyncResult -> {\n        if (asyncResult.failed()) {",
        "pred_variables": [],
        "label_variables": [
            "uri"
        ]
    },
    {
        "code": "public void variousLogMessageUnsafe(String input, Log log) {",
        "pred_variables": [
            "input",
            "log"
        ],
        "label_variables": [
            "input"
        ]
    },
    {
        "code": "public static File getRootDirectory(String path) {\n    if (path == null) {\n        String msg = \"Path can not be null\";",
        "pred_variables": [
            "msg"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "    } catch (Exception e) {\n        log.warn(\"Could not replace wildcards with environment properties for the router configuration \" + \"due to following reason: {}\", e.getMessage());\n        return Optional.empty();\n    }\n    Integer requestHopsLimit = config.getInteger(REQUEST_HOPS_LIMIT_PROPERTY);\n    JsonObject authConfigs = config.getJsonObject(AUTH_CONFIGS_PROPERTY);\n    if (authConfigs == null) {\n        return Optional.of(new RouterConfiguration(requestHopsLimit, Collections.emptyMap()));\n    }\n    Map<OAuthId, OAuthConfiguration> oAuthConfigurationsMap = new HashMap<>();\n    for (String authConfigId : authConfigs.fieldNames()) {\n        JsonObject authConfig = authConfigs.getJsonObject(authConfigId);\n        String flowTypeStr = authConfig.getString(FLOWTYPE_PROPERTY);\n        OAuth2FlowType flowType = flowTypeFromStr(flowTypeStr);\n        if (flowType == null) {",
        "pred_variables": [
            "AUTH_CONFIGS_PROPERTY"
        ],
        "label_variables": [
            "authConfigId"
        ]
    },
    {
        "code": "public TextSearchIndex<ServerProject> getTextSearchIndex(String connectionId) {\n    try {\n        return textSearchIndexCache.get(connectionId, () -> {",
        "pred_variables": [
            "String",
            "connectionId"
        ],
        "label_variables": [
            "connectionId"
        ]
    },
    {
        "code": "protected InternalServerErrorException internalServerError(Exception e) {",
        "pred_variables": [
            "e"
        ],
        "label_variables": [
            "e"
        ]
    },
    {
        "code": "private void handleCreateProducers(Context ctx) throws Exception {\n    List<String> topics = (List<String>) mapper.readValue(ctx.body(), List.class);",
        "pred_variables": [
            "mapper",
            "body"
        ],
        "label_variables": [
            "topics"
        ]
    },
    {
        "code": "private void sendTestMessages(int numMessages) throws JMSException {\n    Session session = connection.createSession(true, Session.SESSION_TRANSACTED);\n    MessageProducer producer = session.createProducer(queue);\n    final TextMessage textMessage = session.createTextMessage();\n    textMessage.setText(\"Message\");\n    for (int i = 1; i <= numMessages; i++) {\n        producer.send(textMessage);\n        if (i % 1000 == 0) {",
        "pred_variables": [
            "i"
        ],
        "label_variables": [
            "i"
        ]
    },
    {
        "code": "@Override\npublic void exec(int executionCounter) {\n    List<String> args = RedisUtils.toPayload(luaScriptState.getSha(), keys.size(), keys, arguments);\n    redisAPI.evalsha(args, event -> {\n        if (event.succeeded()) {\n            promise.complete();\n        } else {\n            String message = event.cause().getMessage();\n            if (message != null && message.startsWith(\"NOSCRIPT\")) {\n                log.warn(\"ReOpenCircuitRedisCommand script couldn't be found, reload it\");",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "executionCounter"
        ]
    },
    {
        "code": "@Override\npublic CompletableFuture<BenchmarkProducer> createProducer(String topic) {\n    return CompletableFuture.supplyAsync(() -> {\n        try {\n            DistributedLogManager dlm = namespace.openLog(topic);",
        "pred_variables": [
            "namespace",
            "supplyAsync"
        ],
        "label_variables": [
            "topic"
        ]
    },
    {
        "code": "@EventListener\n@Async(\"taskExecutor\")\npublic void processArticleDeleteEvent(ArticleDeleteEvent articleDeleteEvent) throws InterruptedException {\n    Thread.sleep(1000);",
        "pred_variables": [
            "articleDeleteEvent"
        ],
        "label_variables": [
            "articleDeleteEvent"
        ]
    },
    {
        "code": "@Override\npublic void offerReconciledTransactionId(long reconciledTransactionId) {\n    requireNonNegative(reconciledTransactionId);\n    initializationLock.readLock().lock();\n    try {\n        if (sequence == null) {",
        "pred_variables": [
            "sequence",
            "reconciledTransactionId"
        ],
        "label_variables": [
            "reconciledTransactionId"
        ]
    },
    {
        "code": "public String[] getAttributeNames(String className) throws Exception {\n    try {\n        return reportingAdminServiceStub.getAttributeNames(className);\n    } catch (Exception e) {\n        String msg = \"Unable to get attribute names\";",
        "pred_variables": [
            "msg"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "public void deleteSavedReport(String name) throws Exception {\n    try {\n        reportingAdminServiceStub.deleteSavedReport(name);\n    } catch (Exception e) {\n        String msg = \"Unable to delete saved report\";",
        "pred_variables": [
            "msg"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "    ByteArrayOutputStream out = new ByteArrayOutputStream();\n    Output output = new Output(out);\n    kryoTL.get().writeObject(output, mapping);\n    output.flush();\n    /* [1] -> flowData */\n    eventData[1] = compress(out.toByteArray());\n    if (log.isDebugEnabled()) {\n        ObjectMapper mapper = new ObjectMapper();\n        String jsonString = null;\n        try {\n            jsonString = mapper.writeValueAsString(mapping);\n        } catch (JsonProcessingException e) {\n            log.error(\"Unable to convert\", e);\n        }\n        log.debug(\"Uncompressed data :\");",
        "pred_variables": [
            "data",
            "ObjectMapper"
        ],
        "label_variables": [
            "jsonString"
        ]
    },
    {
        "code": "/**\n * {@inheritDoc}\n */\npublic void run() {\n    while (isStarted && providerPipe != null && consumerPipe != null) {\n        try {\n            IMessage message = providerPipe.pullMessage();\n            if (log.isDebugEnabled()) {",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "@Override\npublic void onStreamEvent(Notify notify) {",
        "pred_variables": [
            "notify"
        ],
        "label_variables": [
            "notify"
        ]
    },
    {
        "code": "public void handle() throws FacesException {\n    final Iterator<ExceptionQueuedEvent> i = getUnhandledExceptionQueuedEvents().iterator();\n    while (i.hasNext()) {\n        ExceptionQueuedEvent event = i.next();\n        ExceptionQueuedEventContext context = (ExceptionQueuedEventContext) event.getSource();\n        Throwable t = context.getException();\n        final FacesContext fc = FacesContext.getCurrentInstance();\n        final ExternalContext externalContext = fc.getExternalContext();\n        try {\n            if (isInvalidSessionStateException(t)) {",
        "pred_variables": [
            "t",
            "fc",
            "ExceptionQueuedEventContext"
        ],
        "label_variables": [
            "t"
        ]
    },
    {
        "code": "public DataHandler modifyExcelURL(String dbsFilePath) throws XMLStreamException, IOException {\n    try {\n        OMElement dbsFile = AXIOMUtil.stringToOM(FileManager.readFile(dbsFilePath));\n        OMElement dbsConfig = dbsFile.getFirstChildWithName(new QName(\"config\"));\n        Iterator configElement1 = dbsConfig.getChildElements();\n        String productFilePath = resourceFileLocation + File.separator + \"resources\" + File.separator + \"Products-sql.xls\";\n        while (configElement1.hasNext()) {\n            OMElement property = (OMElement) configElement1.next();\n            String value = property.getAttributeValue(new QName(\"name\"));\n            if (\"url\".equals(value)) {\n                property.setText(\"jdbc:wso2:excel:filePath=\" + productFilePath);\n            }\n        }",
        "pred_variables": [
            "property"
        ],
        "label_variables": [
            "dbsFile"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"prometheus\")\nToxiproxyContainer.ContainerProxy prometheusContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(PROMETHEUS_BEAN_NAME) GenericContainer<?> prometheus, ConfigurableEnvironment environment, PrometheusProperties properties) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(prometheus, properties.getPort());\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.prometheus.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.prometheus.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.prometheus.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedPrometheusToxiproxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [
            "getProxy",
            "propertySource",
            "GenericContainer"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "        URL url = new URL(containerEndpoint + \"/_internal/config\");\n        connection = (HttpURLConnection) url.openConnection();\n        connection.setConnectTimeout(5_000);\n        connection.setReadTimeout(5_000);\n        connection.setRequestMethod(\"PUT\");\n        connection.setDoOutput(true);\n        connection.setRequestProperty(\"Content-Type\", \"application/json\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        try (OutputStreamWriter osw = new OutputStreamWriter(connection.getOutputStream())) {\n            osw.write(requestBody);\n            osw.flush();\n        }\n        int responseCode = connection.getResponseCode();\n        if (responseCode != 200) {\n            String response = getResponseBody(connection);",
        "pred_variables": [
            "requestBody"
        ],
        "label_variables": [
            "response",
            "responseCode"
        ]
    },
    {
        "code": "@Nullable\nprivate static OAuth2FlowType flowTypeFromStr(String flowTypeStr) {\n    try {\n        return OAuth2FlowType.valueOf(flowTypeStr);\n    } catch (IllegalArgumentException ex) {",
        "pred_variables": [
            "valueOf",
            "flowTypeStr"
        ],
        "label_variables": [
            "flowTypeStr"
        ]
    },
    {
        "code": "// doc comment inherited from LogWriter\npublic void logOneWay(Logger log, Object command) {",
        "pred_variables": [
            "command"
        ],
        "label_variables": [
            "command"
        ]
    },
    {
        "code": "@Override\npublic void decode(IoSession session, IoBuffer in, ProtocolDecoderOutput out) throws ProtocolCodecException {\n    if (log.isDebugEnabled()) {",
        "pred_variables": [
            "out"
        ],
        "label_variables": [
            "in",
            "out"
        ]
    },
    {
        "code": "public static DockerImageName getDockerImageName(CommonContainerProperties properties) {\n    String customImageName = properties.getDockerImage();\n    String defaultDockerImageName = properties.getDefaultDockerImage();\n    if (customImageName == null && defaultDockerImageName == null) {\n        throw new IllegalStateException(\"Please specify dockerImage for the container.\");\n    }\n    if (customImageName == null) {\n        return setupImage(defaultDockerImageName, properties);\n    }\n    DockerImageName customImage = setupImage(customImageName, properties);\n    if (defaultDockerImageName == null) {\n        return customImage;\n    }\n    DockerImageName defaultImage = DockerImageName.parse(defaultDockerImageName);",
        "pred_variables": [
            "defaultDockerImageName",
            "String",
            "properties",
            "customImageName"
        ],
        "label_variables": [
            "customImage",
            "defaultImage"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"dynamodb\")\nToxiproxyContainer.ContainerProxy dynamodbContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(BEAN_NAME_EMBEDDED_DYNAMODB) GenericContainer<?> dynamoDb, DynamoDBProperties properties, ConfigurableEnvironment environment) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(dynamoDb, properties.getPort());\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.dynamodb.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.dynamodb.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.dynamodb.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedDynamoDBToxiproxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [
            "propertySource"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "private void logCryptomatorSystemProperty(String propertyName) {",
        "pred_variables": [
            "propertyName"
        ],
        "label_variables": [
            "propertyName"
        ]
    },
    {
        "code": "@Override\npublic void onWSDisconnect(WebSocketConnection conn) {",
        "pred_variables": [
            "conn"
        ],
        "label_variables": [
            "conn"
        ]
    },
    {
        "code": "@Override\npublic void onMessage(Message message) {",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "@ExceptionHandler(Exception.class)\npublic ResponseEntity<Object> prepareException(Exception e, WebRequest request) {",
        "pred_variables": [
            "e"
        ],
        "label_variables": [
            "e"
        ]
    },
    {
        "code": "//\n// TODO: See if start-server can share some of this code\n//\nprotected void doExecute() throws Exception {\n    log.info(\"Waiting for Geronimo server...\");\n    // Setup a callback to time out verification\n    final ObjectHolder verifyTimedOut = new ObjectHolder();\n    TimerTask timeoutTask = new TimerTask() {\n\n        public void run() {\n            verifyTimedOut.set(Boolean.TRUE);\n        }\n    };\n    if (timeout > 0) {\n        log.debug(\"Starting verify timeout task; triggers in: \" + timeout + \"s\");\n        timer.schedule(timeoutTask, timeout * 1000);\n    }\n    // Verify server started\n    ServerProxy server = new ServerProxy(hostname, port, username, password);\n    boolean started = false;\n    while (!started) {\n        if (verifyTimedOut.isSet()) {\n            throw new MojoExecutionException(\"Unable to verify if the server was started in the given time\");\n        }\n        started = server.isFullyStarted();\n        if (!started) {\n            Throwable error = server.getLastError();\n            if (error != null) {\n                log.debug(\"Server query failed; ignoring\", error);\n            }\n            Thread.sleep(1000);\n        }\n    }\n    server.closeConnection();\n    // Stop the timer, server should be up now\n    timeoutTask.cancel();\n    log.info(\"Geronimo server started\");",
        "pred_variables": [
            "error"
        ],
        "label_variables": [
            "error"
        ]
    },
    {
        "code": "public synchronized void executePeriodically(final Runnable task, long period) {\n    TimerTask existing = timerTasks.get(task);\n    if (existing != null) {",
        "pred_variables": [
            "task"
        ],
        "label_variables": [
            "task"
        ]
    },
    {
        "code": "public void setDestinationDirectory(String destinationDir) {",
        "pred_variables": [
            "destinationDir"
        ],
        "label_variables": [
            "destinationDir"
        ]
    },
    {
        "code": "@Test\nvoid testCachePathContainsTilde() {\n    String customPath = \"C:\\\\user\\\\abcdef~1\\\\path\";\n    wdm.config().setCachePath(customPath);\n    String cachePath = wdm.config().getCachePath();",
        "pred_variables": [
            "path",
            "customPath",
            "user"
        ],
        "label_variables": [
            "customPath",
            "cachePath"
        ]
    },
    {
        "code": "public List getDLQContents(QueueBrowser qb) {\n    List list = new ArrayList();\n    try {\n        for (Enumeration e = qb.getEnumeration(); e.hasMoreElements(); ) {\n            Object o = e.nextElement();\n            list.add(o);\n        }\n        connection.stop();\n        dlqBrowser.close();\n        session.close();\n        connection.close();\n    } catch (Exception e) {",
        "pred_variables": [
            "e",
            "getEnumeration"
        ],
        "label_variables": [
            "e"
        ]
    },
    {
        "code": "/**\n * Checks the whether the provided uri matches the provided {@link RuleFeatures.Feature}.\n *\n * @param feature the feature to check against\n * @param uri the uri to check\n * @return returns true when the uri matches the feature, else returns false.\n */\npublic boolean isFeatureRequest(RuleFeatures.Feature feature, String uri) {\n    for (RuleFeatures features : getFeaturesList()) {\n        if (features.getUrlPattern().matcher(uri).matches()) {\n            if (features.hasFeature(feature)) {",
        "pred_variables": [
            "uri",
            "features"
        ],
        "label_variables": [
            "uri"
        ]
    },
    {
        "code": "        c.setOpTosUri(appConfiguration.getOpTosUri());\n        c.setOpPolicyUri(appConfiguration.getOpPolicyUri());\n        c.setJwksUri(appConfiguration.getJwksUri());\n        c.setServiceDocumentation(appConfiguration.getServiceDocumentation());\n        c.setUmaProfilesSupported(new String[0]);\n        c.setRegistrationEndpoint(appConfiguration.getRegistrationEndpoint());\n        c.setTokenEndpoint(appConfiguration.getTokenEndpoint());\n        c.setAuthorizationEndpoint(appConfiguration.getAuthorizationEndpoint());\n        c.setIntrospectionEndpoint(baseEndpointUri + \"/rpt/status\");\n        c.setResourceRegistrationEndpoint(baseEndpointUri + \"/host/rsrc/resource_set\");\n        c.setPermissionEndpoint(baseEndpointUri + \"/host/rsrc_pr\");\n        c.setScopeEndpoint(baseEndpointUri + UMA_SCOPES_SUFFIX);\n        c.setClaimsInteractionEndpoint(baseEndpointUri + UMA_CLAIMS_GATHERING_PATH);\n        // convert manually to avoid possible conflicts between resteasy providers, e.g. jettison, jackson\n        final String entity = ServerUtil.asPrettyJson(c);",
        "pred_variables": [
            "entity",
            "c"
        ],
        "label_variables": [
            "entity"
        ]
    },
    {
        "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic void messageReceived(IoSession session, Object in) {\n    if (log.isDebugEnabled()) {\n        if (in instanceof IoBuffer) {\n            log.debug(\"Handskake\");\n            return;\n        }\n        try {\n            final Packet packet = (Packet) in;\n            final Object message = packet.getMessage();\n            final Header source = packet.getHeader();",
        "pred_variables": [
            "message",
            "source"
        ],
        "label_variables": [
            "source"
        ]
    },
    {
        "code": "@Override\npublic void onSharedObjectSend(ISharedObjectBase so, String arg1, List<?> list) {",
        "pred_variables": [
            "list",
            "so"
        ],
        "label_variables": [
            "arg1",
            "list"
        ]
    },
    {
        "code": "@Override\npublic void deleteClaim(String claimType) {\n    Query query = em.createQuery(\"select c from Claim c where c.claimType=:claimtype\");\n    query.setParameter(\"claimtype\", claimType);\n    Object claimObj = query.getSingleResult();\n    em.remove(claimObj);",
        "pred_variables": [
            "Object",
            "query",
            "claimType"
        ],
        "label_variables": [
            "claimType"
        ]
    },
    {
        "code": "/**\n * @param buffer\n * @param bufferIndex\n * @param maxLen\n * @return position of terminating null bytes\n */\npublic static int findUNITermination(byte[] buffer, int bufferIndex, int maxLen) {\n    int len = 0;\n    while (buffer[bufferIndex + len] != (byte) 0x00 || buffer[bufferIndex + len + 1] != (byte) 0x00) {\n        len += 2;\n        if (len > maxLen) {\n            if (log.isDebugEnabled()) {\n                log.warn(\"Failed to find string termination with max length \" + maxLen);",
        "pred_variables": [
            "termination",
            "len"
        ],
        "label_variables": [
            "len",
            "buffer",
            "bufferIndex"
        ]
    },
    {
        "code": "@ParameterizedTest\n@MethodSource(\"data\")\nvoid testServerSeleniumServer(Capabilities capabilities) throws Exception {\n    String serverUrl = String.format(\"http://localhost:%s/\", serverPort);\n    WebDriver driver = new RemoteWebDriver(new URL(serverUrl), capabilities);\n    String sutUrl = \"https://bonigarcia.dev/selenium-webdriver-java/\";\n    driver.get(sutUrl);\n    String title = driver.getTitle();",
        "pred_variables": [
            "capabilities"
        ],
        "label_variables": [
            "sutUrl",
            "title"
        ]
    },
    {
        "code": "public int compare(String v1, String v2) {\n    String[] v1split = v1.split(\"\\\\.\");\n    String[] v2split = v2.split(\"\\\\.\");\n    int length = max(v1split.length, v2split.length);\n    for (int i = 0; i < length; i++) {\n        try {\n            int v1Part = i < v1split.length ? parseInt(v1split[i]) : 0;\n            int v2Part = i < v2split.length ? parseInt(v2split[i]) : 0;\n            if (v1Part < v2Part) {\n                return -1;\n            }\n            if (v1Part > v2Part) {\n                return 1;\n            }\n        } catch (Exception e) {",
        "pred_variables": [
            "i",
            "v2split"
        ],
        "label_variables": [
            "v1",
            "v2"
        ]
    },
    {
        "code": "/**\n * \u8ba4\u8bc1\u8d26\u6237\u7684\u7b7e\u540d\n * @param tx\n * @param eckeys\n * @param txid\n * @param hash160\n */\npublic boolean signCertAccountInputs(Transaction tx, ECKey[] eckeys, byte[] txid, byte[] hash160) {\n    int numInputs = tx.getInputs().size();\n    for (int i = 0; i < numInputs; i++) {\n        TransactionInput txIn = (TransactionInput) tx.getInput(i);\n        if (txIn.getFroms() == null || txIn.getFroms().size() == 0) {",
        "pred_variables": [
            "tx",
            "numInputs"
        ],
        "label_variables": [
            "i"
        ]
    },
    {
        "code": "@ParameterizedTest\n@ValueSource(strings = { \"chrome\", \"firefox\", \"edge\", \"opera\", \"chromium\", \"not-a-browser\" })\nvoid pathTest(String browser) {\n    Optional<Path> detectedPath = versionDetector.getBrowserPath(browser);\n    if (detectedPath.isPresent()) {",
        "pred_variables": [
            "browser",
            "String"
        ],
        "label_variables": [
            "browser"
        ]
    },
    {
        "code": "public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {\n    for (int i = 0; i < callbacks.length; i++) {\n        if (callbacks[i] instanceof HomeRealmCallback) {\n            HomeRealmCallback callback = (HomeRealmCallback) callbacks[i];\n            String homeRealm = (String) callback.getRequest().getParameter(FederationConstants.PARAM_HOME_REALM);\n            if (homeRealm == null || homeRealm.length() == 0) {\n                LOG.debug(\"No home realm found in request\");\n            } else {",
        "pred_variables": [
            "i"
        ],
        "label_variables": [
            "homeRealm"
        ]
    },
    {
        "code": "// doc comment inherited from LogWriter\npublic void logReceivedException(Logger log, IOException error) {",
        "pred_variables": [
            "error"
        ],
        "label_variables": [
            "error"
        ]
    },
    {
        "code": "/*\n     * (non-Javadoc)\n     * \n     * @see java.io.OutputStream#write(int)\n     */\n@Override\npublic void write(int arg0) throws IOException {\n    try {\n        byte b = (byte) arg0;\n        if (LOG.isDebugEnabled())",
        "pred_variables": [
            "arg0"
        ],
        "label_variables": [
            "b"
        ]
    },
    {
        "code": "private void collectMetrics(Buffer buffer) {\n    Map<String, String> map = new HashMap<>();\n    Splitter.on(System.lineSeparator()).omitEmptyStrings().trimResults().splitToList(buffer.toString()).stream().filter(input -> input != null && input.contains(DELIMITER) && !input.contains(\"executable\") && !input.contains(\"config_file\")).forEach(entry -> {\n        List<String> keyValue = Splitter.on(DELIMITER).omitEmptyStrings().trimResults().splitToList(entry);\n        if (keyValue.size() == 2) {\n            map.put(keyValue.get(0), keyValue.get(1));\n        }\n    });",
        "pred_variables": [
            "keyValue",
            "trimResults",
            "map"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "/**\n * \u63a5\u6536\u5230\u5171\u8bc6\u6d88\u606f\uff0c\u5728\u6b64\u505a2\u4e2a\u9a8c\u8bc1\uff0c\u7b2c\u4e00\u7b7e\u540d\u662f\u5426\u6b63\u786e\uff0c\u7b2c\u4e8c\u662f\u5426\u662f\u5171\u8bc6\u8282\u70b9\u53d1\u51fa\u7684\u6d88\u606f\uff0c\u9a8c\u8bc1\u901a\u8fc7\u4e4b\u540e\uff0c\u5c31\u653e\u5230\u5171\u8bc6\u4f1a\u8bae\u8bb0\u5f55\u91cc\u9762\u53bb\uff0c\u7136\u540e\u8f6c\u53d1\u8be5\u6761\u6d88\u606f\n */\n@Override\npublic MessageProcessResult process(Message message, Peer peer) {\n    ConsensusMessage consensusMessage = (ConsensusMessage) message;\n    MessageProcessResult result = new MessageProcessResult(consensusMessage.getId(), false);\n    //\u9a8c\u8bc1\u7b7e\u540d\u662f\u5426\u6b63\u786e\n    //\u6240\u6709\u8282\u70b9\u53c2\u4e0e\u5171\u8bc6\uff0c\u5fc5\u987b\u4ee5\u4e66\u9762\u534f\u8bae\u5f62\u5f0f\u8fdb\u884c\u7b7e\u540d\uff0c\u786e\u4fdd\u6076\u610f\u8282\u70b9\u80fd\u88ab\u8ffd\u8e2a\u5904\u7406\n    if (consensusMessage.getSigns() == null) {",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "consensusMessage"
        ]
    },
    {
        "code": "@Override\npublic void onException(JMSException e) {",
        "pred_variables": [
            "e"
        ],
        "label_variables": [
            "e"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"mariadb\")\nToxiproxyContainer.ContainerProxy mariadbContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(BEAN_NAME_EMBEDDED_MARIADB) MariaDBContainer mariadbContainer, MariaDBProperties properties, ConfigurableEnvironment environment) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(mariadbContainer, properties.getPort());\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.mariadb.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.mariadb.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.mariadb.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedMariadbToxiproxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "@Test\nvoid testEdgeMac() {\n    String libName = \"libc++.dylib\";\n    String driverVersion = \"87.0.664.75\";\n    WebDriverManager wdm = WebDriverManager.edgedriver().driverVersion(driverVersion).mac();\n    wdm.setup();\n    String downloadedDriverPath = wdm.getDownloadedDriverPath();",
        "pred_variables": [
            "wdm",
            "driverVersion"
        ],
        "label_variables": [
            "downloadedDriverPath"
        ]
    },
    {
        "code": "@Override\npublic boolean beforeExecute(ForestRequest request) {\n    log.info(\"invoke Base Error beforeExecute\");\n    Object[] args = request.getArguments();",
        "pred_variables": [
            "args"
        ],
        "label_variables": [
            "args"
        ]
    },
    {
        "code": "private void handleSpanChunk(PSpanChunk spanChunk) {\n    if (isDebug) {",
        "pred_variables": [
            "spanChunk"
        ],
        "label_variables": [
            "spanChunk"
        ]
    },
    {
        "code": "@ParameterizedTest\n@ValueSource(strings = { \"chrome\", \"firefox\", \"edge\", \"opera\", \"chromium\" })\nvoid commandsTest(String browser) {\n    Optional<String> detectedVersion = versionDetector.getBrowserVersionFromTheShell(browser);\n    if (detectedVersion.isPresent()) {",
        "pred_variables": [
            "String",
            "versionDetector"
        ],
        "label_variables": [
            "browser"
        ]
    },
    {
        "code": "private static void handleException(String msg, Exception e) {",
        "pred_variables": [
            "msg",
            "e"
        ],
        "label_variables": [
            "msg",
            "e"
        ]
    },
    {
        "code": "public Object resolve(String name, Class clz) throws NamingException {\n    Context ctx = new InitialContext();\n    ctx = (Context) ctx.lookup(\"java:comp/env\");",
        "pred_variables": [
            "name",
            "clz"
        ],
        "label_variables": [
            "name"
        ]
    },
    {
        "code": "public void assertBeanMarshalls(Object original) throws IOException {\n    super.assertBeanMarshalls(original);\n    String xml = getXStreamWireFormat().marshalText(original);\n    LOG.info(original.getClass().getName() + \" as XML is:\");",
        "pred_variables": [
            "xml"
        ],
        "label_variables": [
            "xml"
        ]
    },
    {
        "code": "/**\n * Return a static value MapMetastore\n * @param tileTable The table name with tile data\n * @param pointTable The table name with point data\n * @return The metastore\n */\npublic static MapMetastore newStaticMapsMeta(String tileTable, String pointTable) {",
        "pred_variables": [
            "pointTable",
            "tileTable"
        ],
        "label_variables": [
            "tileTable",
            "pointTable"
        ]
    },
    {
        "code": "    }\n    final QueueViewMBean queueView = getProxyToQueue(dlq.getQueueName());\n    assertTrue(\"Message should be DLQ'd\", Wait.waitFor(new Wait.Condition() {\n\n        @Override\n        public boolean isSatisified() throws Exception {\n            return queueView.getQueueSize() == MSG_COUNT;\n        }\n    }));\n    LOG.info(\"DLQ has captured all expired messages\");\n    Deque<String> browsed = new LinkedList<String>();\n    CompositeData[] elements = queueView.browse();\n    assertEquals(MSG_COUNT, elements.length);\n    for (CompositeData element : elements) {\n        String messageID = (String) element.get(\"JMSMessageID\");",
        "pred_variables": [
            "messageID"
        ],
        "label_variables": [
            "messageID"
        ]
    },
    {
        "code": "@Override\npublic void delete(final String uri, final Handler<Integer> doneHandler) {\n    client.request(HttpMethod.DELETE, uri).onComplete(asyncResult -> {\n        if (asyncResult.failed()) {",
        "pred_variables": [
            "uri"
        ],
        "label_variables": [
            "uri"
        ]
    },
    {
        "code": "@Override\npublic void removeFromClusterIdIndex(String clusterId) {",
        "pred_variables": [
            "clusterId"
        ],
        "label_variables": [
            "clusterId"
        ]
    },
    {
        "code": "@GET\n@Path(\"{id}\")\n@Produces({ UmaConstants.JSON_MEDIA_TYPE })\npublic Response getScopeDescription(@PathParam(\"id\") String id) {",
        "pred_variables": [
            "id"
        ],
        "label_variables": [
            "id"
        ]
    },
    {
        "code": "@Override\nprotected boolean hasLockOwnership() throws IOException {\n    boolean hasLock = true;\n    if (broker.getPersistenceAdapter() instanceof JDBCPersistenceAdapter) {\n        JDBCPersistenceAdapter jdbcPersistenceAdapter = (JDBCPersistenceAdapter) broker.getPersistenceAdapter();\n        Locker locker = jdbcPersistenceAdapter.getLocker();\n        if (locker != null) {\n            try {\n                if (!locker.keepAlive()) {\n                    hasLock = false;\n                }\n            } catch (SuppressReplyException ignoreWhileHandlingInProgress) {\n            } catch (IOException ignored) {\n            }\n            if (!hasLock) {",
        "pred_variables": [
            "locker"
        ],
        "label_variables": [
            "locker"
        ]
    },
    {
        "code": "@Override\npublic void exec(int executionCounter) {\n    List<String> args = RedisUtils.toPayload(luaScriptState.getSha(), keys.size(), keys, arguments);\n    redisAPI.evalsha(args, event -> {\n        if (event.succeeded()) {\n            Response result = event.result();\n            promise.complete(result);\n        } else {\n            String message = event.cause().getMessage();\n            if (message != null && message.startsWith(\"NOSCRIPT\")) {\n                log.warn(\"UnlockSampleQueuesRedisCommand script couldn't be found, reload it\");",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "executionCounter"
        ]
    },
    {
        "code": "public boolean dispatch(MessageReference node, MessageEvaluationContext msgContext, List<Subscription> consumers) throws Exception {\n    List<Subscription> duplicateFreeSubs = new ArrayList<Subscription>();\n    synchronized (consumers) {\n        for (Subscription sub : consumers) {\n            ConsumerInfo info = sub.getConsumerInfo();\n            if (info.isNetworkSubscription()) {\n                boolean highestPrioritySub = true;\n                for (Iterator<Subscription> it = duplicateFreeSubs.iterator(); it.hasNext(); ) {\n                    Subscription candidate = it.next();\n                    if (matches(candidate, info)) {\n                        if (hasLowerPriority(candidate, info)) {\n                            it.remove();\n                        } else {\n                            // higher priority matching sub exists\n                            highestPrioritySub = false;",
        "pred_variables": [
            "sub",
            "duplicateFreeSubs",
            "highestPrioritySub",
            "info",
            "Subscription",
            "msgContext"
        ],
        "label_variables": [
            "sub",
            "candidate"
        ]
    },
    {
        "code": "@Override\npublic void warn(String s, Throwable throwable) {",
        "pred_variables": [
            "s",
            "throwable"
        ],
        "label_variables": [
            "s",
            "throwable"
        ]
    },
    {
        "code": "@Override\npublic void deleteRole(String name) {\n    Query query = em.createQuery(\"select r from Role r where r.name=:name\");\n    query.setParameter(\"name\", name);\n    Object roleObj = query.getSingleResult();\n    em.remove(roleObj);",
        "pred_variables": [
            "where",
            "name",
            "r"
        ],
        "label_variables": [
            "name"
        ]
    },
    {
        "code": "private void deleteTopics() {\n    synchronized (createdTopics) {\n        for (String topic : createdTopics) {",
        "pred_variables": [
            "topic"
        ],
        "label_variables": [
            "topic"
        ]
    },
    {
        "code": "        }\n    }\n    producerConnection.close();\n    LOG.info(\"Mem usage after producer done: \" + broker.getSystemUsage().getMemoryUsage().getPercentUsage() + \"%\");\n    // Browse the queue.\n    Connection connection = factory.createConnection();\n    connection.start();\n    Session session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);\n    QueueBrowser browser = session.createBrowser(queue);\n    Enumeration<?> enumeration = browser.getEnumeration();\n    int browsed = 0;\n    while (enumeration.hasMoreElements()) {\n        TextMessage m = (TextMessage) enumeration.nextElement();\n        browsed++;\n        if ((browsed % 1000) == 0) {",
        "pred_variables": [
            "browsed"
        ],
        "label_variables": [
            "browsed"
        ]
    },
    {
        "code": "@ParameterizedTest\n@MethodSource(\"data\")\nvoid testFilterCacheBy(String version, int expectedVersions) {\n    CacheHandler cacheHandler = new CacheHandler(new Config());\n    List<File> filteredList = cacheHandler.filterCacheBy(getInputFileList(), version, true);",
        "pred_variables": [
            "cacheHandler"
        ],
        "label_variables": [
            "filteredList",
            "version"
        ]
    },
    {
        "code": "@Override\npublic MessageProcessResult process(Message message, Peer peer) {",
        "pred_variables": [
            "message",
            "peer"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "private RecoveryCondition createIndexRecoveryCondition(final InternalLogProvider logProvider, final TokenNameLookup tokenNameLookup) {\n    return new RecoveryCondition() {\n\n        private final InternalLog log = logProvider.getLog(IndexSamplingController.class);\n\n        @Override\n        public boolean test(IndexDescriptor descriptor) {\n            IndexSample indexSample = indexStatisticsStore.indexSample(descriptor.getId());\n            long samples = indexSample.sampleSize();\n            long size = indexSample.indexSize();\n            boolean empty = (samples == 0) || (size == 0);\n            if (empty) {",
        "pred_variables": [
            "samples",
            "empty",
            "size",
            "tokenNameLookup"
        ],
        "label_variables": [
            "tokenNameLookup"
        ]
    },
    {
        "code": "private void loadingKeyFailed(Throwable e) {\n    if (e instanceof UnlockCancelledException) {\n        // ok\n    } else if (e instanceof VaultKeyInvalidException) {\n        //TODO: specific error screen",
        "pred_variables": [
            "e"
        ],
        "label_variables": [
            "e"
        ]
    },
    {
        "code": "@Override\npublic void exec(int executionCounter) {\n    List<String> args = RedisUtils.toPayload(luaScriptState.getSha(), keys.size(), keys, arguments);\n    redisAPI.evalsha(args, event -> {\n        if (event.succeeded()) {\n            promise.complete();\n        } else {\n            String message = event.cause().getMessage();\n            if (message != null && message.startsWith(\"NOSCRIPT\")) {\n                log.warn(\"CloseCircuitRedisCommand script couldn't be found, reload it\");",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "executionCounter"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"mongodb\")\nToxiproxyContainer.ContainerProxy mongodbContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(BEAN_NAME_EMBEDDED_MONGODB) GenericContainer<?> mongodb, MongodbProperties properties, ConfigurableEnvironment environment) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(mongodb, properties.getPort());\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.mongodb.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.mongodb.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.mongodb.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedMongodbToxiProxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "private void registerMongodbEnvironment(GenericContainer<?> mongodb, ConfigurableEnvironment environment, MongodbProperties properties) {\n    Integer mappedPort = mongodb.getMappedPort(properties.getPort());\n    String host = mongodb.getHost();\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.mongodb.port\", mappedPort);\n    map.put(\"embedded.mongodb.host\", host);\n    map.compute(\"embedded.mongodb.username\", (k, v) -> properties.getUsername());\n    map.compute(\"embedded.mongodb.password\", (k, v) -> properties.getPassword());\n    map.put(\"embedded.mongodb.database\", properties.getDatabase());",
        "pred_variables": [
            "properties",
            "mongodb"
        ],
        "label_variables": [
            "mappedPort",
            "host",
            "map"
        ]
    },
    {
        "code": "@Override\npublic void errorOccurred(Connection conn, String error) {",
        "pred_variables": [
            "error"
        ],
        "label_variables": [
            "conn",
            "error"
        ]
    },
    {
        "code": "    HeadersMultiMap headers = defaultRequestHeaders();\n    headers.add(\"Accept\", \"application/json\");\n    headers.add(SELF_REQUEST_HEADER, \"true\");\n    clientRequestCreator.createClientRequest(HttpMethod.GET, schemaLocation.schemaLocation(), headers, TIMEOUT_MS, event -> {\n        log.warn(\"Got an error while fetching schema\", event);\n        promise.complete(Optional.empty());\n    }).onComplete(asyncResult -> {\n        HttpClientRequest fetchSchemaRequest = asyncResult.result();\n        fetchSchemaRequest.setChunked(true);\n        fetchSchemaRequest.send(responseAsyncResult -> {\n            HttpClientResponse cRes = responseAsyncResult.result();\n            cRes.bodyHandler(data -> {\n                if (StatusCode.OK.getStatusCode() == cRes.statusCode()) {\n                    String contentType = cRes.getHeader(CONTENT_TYPE_HEADER);\n                    if (contentType != null && !contentType.contains(CONTENT_TYPE_JSON)) {",
        "pred_variables": [
            "contentType",
            "CONTENT_TYPE_JSON"
        ],
        "label_variables": [
            "contentType"
        ]
    },
    {
        "code": "@Test\npublic void testCtor() throws Exception {\n    File file = new File(\"target/test-classes/fixtures/sample.m4a\");\n    M4AReader reader = new M4AReader(file);\n    ITag tag = reader.readTag();",
        "pred_variables": [
            "tag",
            "file"
        ],
        "label_variables": [
            "tag"
        ]
    },
    {
        "code": "private void closeStreamFromURL(String strURL, InputStream inputStream) {\n    if (inputStream != null) {\n        try {\n            inputStream.close();\n        } catch (Exception e) {",
        "pred_variables": [
            "inputStream",
            "strURL"
        ],
        "label_variables": [
            "strURL"
        ]
    },
    {
        "code": "private void updateLoggingResources(Buffer buffer) throws ValidationException {\n    extractLoggingFilterValues(buffer);\n    for (Map<String, String> payloadFilters : getLoggingResource().getPayloadFilters()) {",
        "pred_variables": [
            "getPayloadFilters",
            "buffer"
        ],
        "label_variables": [
            "payloadFilters"
        ]
    },
    {
        "code": "                if (tag != null) {\n                    switch(tag.getDataType()) {\n                        case IoConstants.TYPE_AUDIO:\n                            audio++;\n                            break;\n                        case IoConstants.TYPE_VIDEO:\n                            video++;\n                            break;\n                        case IoConstants.TYPE_METADATA:\n                            meta++;\n                            break;\n                    }\n                }\n            }\n            reader.close();",
        "pred_variables": [
            "case",
            "audio",
            "tag"
        ],
        "label_variables": [
            "meta",
            "audio",
            "video"
        ]
    },
    {
        "code": "public boolean externalForceReAuthentication(CustomScriptConfiguration scriptConfiguration, ExternalPostAuthnContext context) {\n    try {",
        "pred_variables": [
            "scriptConfiguration",
            "context"
        ],
        "label_variables": [
            "context"
        ]
    },
    {
        "code": "@Override\npublic Response requestAccessToken(String token, String tokenTypeHint, String clientId, HttpServletRequest request, HttpServletResponse response, SecurityContext sec) {",
        "pred_variables": [
            "request",
            "clientId",
            "sec"
        ],
        "label_variables": [
            "tokenTypeHint",
            "token"
        ]
    },
    {
        "code": "/**\n * Logs the given {@link Throwable} and try ending the response.\n *\n * @param throwable the {@link Throwable} to log in error.\n * @param response the response to end.\n *\n * @return a completed {@link Completable} in any circumstances.\n */\nprivate Completable handleError(Throwable throwable, HttpServerResponse response) {",
        "pred_variables": [
            "response",
            "throwable"
        ],
        "label_variables": [
            "throwable"
        ]
    },
    {
        "code": "@Override\npublic void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n    if (ctx.channel().isWritable()) {\n        if (reaperFuture != null) {\n            reaperFuture.cancel(false);\n            reaperFuture = null;\n        }\n    } else {\n        if (reaperFuture == null) {\n            reaperFuture = ctx.executor().schedule(() -> {\n                var ex = new TransportThrottleException(this.maxWriteLockMillis);",
        "pred_variables": [
            "ctx"
        ],
        "label_variables": [
            "ex"
        ]
    },
    {
        "code": "@Override\npublic void storeXDeltaResponseHeader(String xDeltaResponseNumber) {\n    if (log.isTraceEnabled()) {",
        "pred_variables": [
            "xDeltaResponseNumber"
        ],
        "label_variables": [
            "xDeltaResponseNumber"
        ]
    },
    {
        "code": "@Override\npublic void handleSimple(ServerRequest<GeneratedMessageV3> serverRequest) {\n    final GeneratedMessageV3 data = serverRequest.getData();\n    if (data instanceof PSpan) {\n        handleSpan((PSpan) data);\n    } else {",
        "pred_variables": [
            "data"
        ],
        "label_variables": [
            "serverRequest"
        ]
    },
    {
        "code": "            driverManagerType = FIREFOX;\n            break;\n        case \"org/openqa/selenium/opera/OperaDriver\":\n            driverManagerType = OPERA;\n            break;\n        case \"org/openqa/selenium/edge/EdgeDriver\":\n            driverManagerType = EDGE;\n            break;\n        case \"org/openqa/selenium/ie/InternetExplorerDriver\":\n            driverManagerType = IEXPLORER;\n            break;\n        default:\n            break;\n    }\n    if (driverManagerType != null) {",
        "pred_variables": [
            "OPERA",
            "driverManagerType",
            "edge",
            "EDGE"
        ],
        "label_variables": [
            "driverManagerType"
        ]
    },
    {
        "code": "        message.setLongProperty(\"sendTime\", sendTime);\n        producer.send(message);\n        LOG.debug(\"Receiving message \" + i);\n        Message receivedMessage = consumer.receive(5000);\n        assertNotNull(\"On message \" + i, receivedMessage);\n        assertTrue(\"On message \" + i, receivedMessage instanceof BytesMessage);\n        BytesMessage receivedBytesMessage = (BytesMessage) receivedMessage;\n        int numElements = 0;\n        try {\n            while (true) {\n                receivedBytesMessage.readBoolean();\n                numElements++;\n            }\n        } catch (Exception ex) {\n        }",
        "pred_variables": [
            "i",
            "numElements"
        ],
        "label_variables": [
            "i",
            "numElements"
        ]
    },
    {
        "code": "private static void log(String title, SonarLintPathPattern[] patterns) {\n    if (patterns.length > 0) {",
        "pred_variables": [
            "patterns"
        ],
        "label_variables": [
            "title"
        ]
    },
    {
        "code": "public DeferredChanged<ChangedSchema> getOrAddSchema(RecursiveSchemaSet refSet, CacheKey key, Schema left, Schema right) {\n    // don't allow recursive references to schemas\n    if (refSet.contains(key)) {",
        "pred_variables": [
            "key",
            "right",
            "left"
        ],
        "label_variables": [
            "key"
        ]
    },
    {
        "code": "@Override\npublic void handle(Exception ex) {",
        "pred_variables": [
            "ex"
        ],
        "label_variables": [
            "ex"
        ]
    },
    {
        "code": "public boolean externalModify(JSONObject rptAsJson, CustomScriptConfiguration scriptConfiguration, ExternalUmaRptClaimsContext context) {\n    try {",
        "pred_variables": [
            "rptAsJson",
            "scriptConfiguration",
            "CustomScriptConfiguration"
        ],
        "label_variables": [
            "context"
        ]
    },
    {
        "code": "@Override\npublic void failToRecoverTransactionsAfterPosition(Throwable t, LogPosition recoveryFromPosition) {",
        "pred_variables": [
            "recoveryFromPosition",
            "t"
        ],
        "label_variables": [
            "t",
            "recoveryFromPosition"
        ]
    },
    {
        "code": "                for (ConsumerInfo nc : networkConsumerList) {\n                    if (!nc.isNetworkConsumersEmpty()) {\n                        for (ConsumerId id : nc.getNetworkConsumerIds()) {\n                            if (id.equals(info.getConsumerId())) {\n                                nc.removeNetworkConsumerId(id);\n                                if (nc.isNetworkConsumersEmpty()) {\n                                    gcList.add(nc);\n                                }\n                            }\n                        }\n                    }\n                }\n                for (ConsumerInfo nc : gcList) {\n                    networkConsumerList.remove(nc);\n                    super.removeConsumer(context, nc);",
        "pred_variables": [
            "nc"
        ],
        "label_variables": [
            "nc"
        ]
    },
    {
        "code": "private void registerConsulEnvironment(GenericContainer<?> consul, ConfigurableEnvironment environment, ConsulProperties properties) {\n    Integer mappedPort = consul.getMappedPort(properties.getPort());\n    String host = consul.getHost();\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.consul.port\", mappedPort);\n    map.put(\"embedded.consul.host\", host);",
        "pred_variables": [
            "host",
            "properties",
            "consul",
            "mappedPort",
            "String",
            "getHost"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "@Idempotent\npublic APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent input, final Context context) {\n    handlerExecuted = true;\n    Map<String, String> headers = new HashMap<>();\n    headers.put(\"Content-Type\", \"application/json\");\n    headers.put(\"Access-Control-Allow-Origin\", \"*\");\n    headers.put(\"Access-Control-Allow-Methods\", \"GET, OPTIONS\");\n    headers.put(\"Access-Control-Allow-Headers\", \"*\");\n    APIGatewayProxyResponseEvent response = new APIGatewayProxyResponseEvent().withHeaders(headers);\n    try {\n        String address = JsonConfig.get().getObjectMapper().readTree(input.getBody()).get(\"address\").asText();\n        final String pageContents = this.getPageContents(address);\n        String output = String.format(\"{ \\\"message\\\": \\\"hello world\\\", \\\"location\\\": \\\"%s\\\" }\", pageContents);",
        "pred_variables": [
            "output"
        ],
        "label_variables": [
            "pageContents"
        ]
    },
    {
        "code": "@Override\npublic void visitDecimal(String name, long id, int exp, long mant) {",
        "pred_variables": [
            "id",
            "name",
            "exp"
        ],
        "label_variables": [
            "name"
        ]
    },
    {
        "code": "/**\n * Merges headers, makes sure that only one value of all headers ends up in the destination MultiMap.\n *\n * Note: This is not 100% in line with https://www.rfc-editor.org/rfc/rfc7230#section-3.2.2 to be further looked into.\n *\n * @param context optional context information to be used for logging purposes, not used for the actual merge\n */\npublic static void mergeHeaders(@Nonnull MultiMap destination, @Nonnull MultiMap source, @Nullable String context) {\n    source.forEach(sourceHeader -> {\n        if (destination.contains(sourceHeader.getKey())) {\n            // we already have such a header\n            String destinationValue = destination.get(sourceHeader.getKey());\n            String sourceValue = source.get(sourceHeader.getKey());\n            if (!destinationValue.equals(sourceValue)) {",
        "pred_variables": [
            "destination",
            "String",
            "destinationValue",
            "source"
        ],
        "label_variables": [
            "destinationValue",
            "context",
            "sourceValue"
        ]
    },
    {
        "code": "@Override\npublic void get(final String path, final Handler<Buffer> bodyHandler) {",
        "pred_variables": [],
        "label_variables": [
            "path"
        ]
    },
    {
        "code": "private double nextRate(long periodNanos, long actual, long expected, long backlog, String type) {",
        "pred_variables": [
            "expected",
            "periodNanos"
        ],
        "label_variables": [
            "backlog",
            "type"
        ]
    },
    {
        "code": "@Override\npublic void recoveryCleanupClosed(Path indexFile, IndexDescriptor index) {",
        "pred_variables": [
            "indexFile",
            "index"
        ],
        "label_variables": [
            "indexFile",
            "index"
        ]
    },
    {
        "code": "@Override\npublic void warning(String message) {",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "public void failed(Artifact configurationId, Throwable cause) {",
        "pred_variables": [
            "cause"
        ],
        "label_variables": [
            "cause",
            "configurationId"
        ]
    },
    {
        "code": "public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {\n    for (int i = 0; i < callbacks.length; i++) {\n        if (callbacks[i] instanceof HomeRealmCallback) {\n            HomeRealmCallback callback = (HomeRealmCallback) callbacks[i];\n            final String loginHint = (String) callback.getRequest().getParameter(\"login_hint\");\n            if (loginHint == null || loginHint.isEmpty()) {\n                LOG.debug(\"No login_hint found in request to set home realm\");\n            } else {\n                String[] homeRealm = loginHint.split(\"@\");\n                if (homeRealm.length == 2) {\n                    LOG.debug(\"Home realm '{}' found in request\", StringEscapeUtils.escapeHtml4(homeRealm[1]));\n                    callback.setHomeRealm(homeRealm[1]);\n                } else {",
        "pred_variables": [
            "i",
            "homeRealm",
            "escapeHtml4",
            "realm"
        ],
        "label_variables": [
            "loginHint"
        ]
    },
    {
        "code": "@Override\npublic void readExternal(IDataInput in) {\n    log.debug(\"CommandMessage - Read external\");\n    super.readExternal(in);\n    short[] flagsArray = readFlags(in);\n    for (int i = 0; i < flagsArray.length; ++i) {\n        short flags = flagsArray[i];",
        "pred_variables": [
            "i",
            "flags",
            "flagsArray"
        ],
        "label_variables": [
            "flags"
        ]
    },
    {
        "code": "Optional<Pair<KafkaProducer<String, String>, Pattern>> findMatchingKafkaProducer(String topic) {\n    for (Map.Entry<Pattern, KafkaProducer<String, String>> entry : kafkaProducers.entrySet()) {\n        Matcher matcher = entry.getKey().matcher(topic);\n        if (matcher.matches()) {",
        "pred_variables": [
            "topic",
            "Entry"
        ],
        "label_variables": [
            "topic"
        ]
    },
    {
        "code": "private void registerSchemaRegistryEnvironment(GenericContainer<?> schemaRegistry, ConfigurableEnvironment environment, SchemaRegistryConfigurationProperties properties) {\n    String host = schemaRegistry.getHost();\n    Integer port = schemaRegistry.getMappedPort(properties.getPort());\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.kafka.schema-registry.host\", host);\n    map.put(\"embedded.kafka.schema-registry.port\", port);\n    if (properties.isBasicAuthenticationEnabled()) {\n        map.put(\"embedded.kafka.schema-registry.username\", SchemaRegistryConfigurationProperties.USERNAME);\n        map.put(\"embedded.kafka.schema-registry.password\", SchemaRegistryConfigurationProperties.PASSWORD);\n    }",
        "pred_variables": [
            "host",
            "properties",
            "port",
            "SchemaRegistryConfigurationProperties",
            "LinkedHashMap",
            "getHost"
        ],
        "label_variables": [
            "port",
            "host",
            "map"
        ]
    },
    {
        "code": "@Override\npublic void debug(String s, Throwable throwable) {",
        "pred_variables": [
            "s",
            "throwable"
        ],
        "label_variables": [
            "s",
            "throwable"
        ]
    },
    {
        "code": "    JsonObject config;\n    List<KafkaConfiguration> configurations = new ArrayList<>();\n    try {\n        replacedConfig = StringUtils.replaceWildcardConfigs(configurationResourceBuffer.toString(UTF_8), properties);\n        config = new JsonObject(Buffer.buffer(replacedConfig));\n    } catch (Exception e) {\n        log.warn(\"Could not replace wildcards with environment properties for kafka configurations due to following reason: {}\", e.getMessage());\n        return configurations;\n    }\n    for (String topicPattern : config.fieldNames()) {\n        try {\n            Pattern pattern = Pattern.compile(topicPattern);\n            final Map<String, String> additionalConfig = extractAdditionalConfig(config.getJsonObject(topicPattern));\n            setUniqueClientId(additionalConfig);\n            configurations.add(new KafkaConfiguration(pattern, additionalConfig));",
        "pred_variables": [
            "topicPattern"
        ],
        "label_variables": [
            "topicPattern"
        ]
    },
    {
        "code": "@Test\npublic void test() throws IOException {\n    // get dummy scope\n    WebScope scope = (WebScope) applicationContext.getBean(\"web.scope\");\n    // test file fixture\n    File file = new File(\"target/test-classes/fixtures/test.flv\");\n    // new file provider instance\n    FileProvider provider = new FileProvider(scope, file);\n    // data pipe\n    IPipe pipe = new InMemoryPullPullPipe();\n    // subscribe the provider to the pipe\n    pipe.subscribe(provider, null);\n    // grab a message from the pipe (can do this until no messages are remaining)\n    IMessage msg = pipe.pullMessage();",
        "pred_variables": [
            "msg"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "public void info(String s, Throwable t) {",
        "pred_variables": [
            "s",
            "t"
        ],
        "label_variables": [
            "s",
            "t"
        ]
    },
    {
        "code": "public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {",
        "pred_variables": [
            "applicationContext"
        ],
        "label_variables": [
            "applicationContext"
        ]
    },
    {
        "code": "public boolean checkKeyInResolutionCache(String key, boolean showLog) {\n    String valueFromResolutionCache = getValueFromResolutionCache(key);\n    boolean valueInResolutionCache = valueFromResolutionCache != null && !valueFromResolutionCache.isEmpty();\n    if (valueInResolutionCache) {\n        Date expirationDate = getExpirationDateFromResolutionCache(key);\n        valueInResolutionCache &= checkValidity(key, valueFromResolutionCache, expirationDate);\n        if (valueInResolutionCache) {\n            String strDate = formatDate(expirationDate);\n            if (showLog) {",
        "pred_variables": [
            "key"
        ],
        "label_variables": [
            "valueFromResolutionCache",
            "strDate",
            "key"
        ]
    },
    {
        "code": "@Override\npublic void setBus(Bus bus) {\n    if (bus != null) {\n        String busInfo = String.format(\"Successfully created %s with SpringBus [%s]\", getName(), bus.getId());",
        "pred_variables": [
            "busInfo"
        ],
        "label_variables": [
            "busInfo"
        ]
    },
    {
        "code": "@Override\npublic void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {",
        "pred_variables": [
            "exception",
            "session"
        ],
        "label_variables": [
            "exception"
        ]
    },
    {
        "code": "        }\n        final Set<GrantedAuthority> authorities = new HashSet<>();\n        if (currentAuth.getAuthorities() != null) {\n            authorities.addAll(currentAuth.getAuthorities());\n        }\n        Iterator<? extends GrantedAuthority> authIt = currentAuth.getAuthorities().iterator();\n        while (authIt.hasNext()) {\n            GrantedAuthority ga = authIt.next();\n            String roleName = ga.getAuthority();\n            try {\n                Role role = roleDAO.getRole(roleName.substring(5), Arrays.asList(\"all\"));\n                for (Entitlement e : role.getEntitlements()) {\n                    authorities.add(new SimpleGrantedAuthority(e.getName()));\n                }\n            } catch (Exception ex) {",
        "pred_variables": [
            "getName"
        ],
        "label_variables": [
            "roleName"
        ]
    },
    {
        "code": "@Async(\"taskExecutor\")\n@EventListener\npublic void processCommentCreatedEvent(CommentEvent commentEvent) throws InterruptedException {",
        "pred_variables": [
            "commentEvent"
        ],
        "label_variables": [
            "commentEvent"
        ]
    },
    {
        "code": "private void deleteEmployeeBatchRequest() throws AxisFault, XPathExpressionException {\n    OMElement payload = fac.createOMElement(\"deleteEmployee_batch_req\", omNs);\n    for (int i = 10; i < 36; i++) {\n        OMElement batchRequest = fac.createOMElement(\"addEmployee\", omNs);\n        OMElement empNo = fac.createOMElement(\"employeeNumber\", omNs);\n        empNo.setText(i + \"\");\n        batchRequest.addChild(empNo);\n        payload.addChild(batchRequest);\n    }\n    if (log.isDebugEnabled()) {",
        "pred_variables": [
            "i",
            "fac",
            "omNs"
        ],
        "label_variables": [
            "payload"
        ]
    },
    {
        "code": "@Test(timeout = 60000)\npublic void testCreditNotGrantedUntilBacklogClears() throws Exception {\n    final int MSG_COUNT = 1000;\n    AmqpClient client = createAmqpClient();\n    AmqpConnection connection = trackConnection(client.connect());\n    AmqpSession session = connection.createSession();\n    AmqpReceiver receiver = session.createReceiver(\"queue://\" + getTestName());\n    AmqpSender sender = session.createSender(\"queue://\" + getTestName(), true);\n    for (int i = 1; i <= MSG_COUNT; ++i) {\n        AmqpMessage message = new AmqpMessage();\n        message.setText(\"Test-Message: \" + i);\n        sender.send(message);\n        if (i % 1000 == 0) {",
        "pred_variables": [
            "i"
        ],
        "label_variables": [
            "i"
        ]
    },
    {
        "code": "@Override\npublic synchronized void panic(Throwable cause) {\n    if (!healthy) {\n        return;\n    }\n    Objects.requireNonNull(cause, \"Must provide a non null cause for the database panic\");\n    this.causeOfPanic = cause;\n    this.healthy = false;",
        "pred_variables": [
            "cause"
        ],
        "label_variables": [
            "cause"
        ]
    },
    {
        "code": "public ServerConfigurationService getServerConfigurationService() {\n    if (this.serverConfigurationService == null) {\n        String msg = \"Before activating javax caching  bundle, an instance of \" + \"ServerConfigurationService should be in existence\";",
        "pred_variables": [
            "msg"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "@Override\npublic List<Flow> save(final FlowReferenceType flowReferenceType, final String referenceId, final List<Flow> flows) {\n    try {",
        "pred_variables": [
            "Flow",
            "referenceId"
        ],
        "label_variables": [
            "flowReferenceType"
        ]
    },
    {
        "code": "public TenantMgtConfiguration buildTenantMgtConfiguration(OMElement tenantMgtConfigElement, String tenantManagerClass) throws UserStoreException {\n    Map<String, String> tenantMgtProperties = null;\n    TenantMgtConfiguration tenantMgtConfiguration = new TenantMgtConfiguration();\n    Iterator<OMElement> iterator = tenantMgtConfigElement.getChildrenWithName(new QName(UserCoreConstants.TenantMgtConfig.LOCAL_NAME_TENANT_MANAGER));\n    for (; iterator.hasNext(); ) {\n        OMElement tenantManager = iterator.next();\n        if (tenantManagerClass != null && tenantManagerClass.equals(tenantManager.getAttributeValue(new QName(UserCoreConstants.TenantMgtConfig.ATTRIBUTE_NAME_CLASS)))) {\n            tenantMgtProperties = readChildPropertyElements(tenantManager);\n            tenantMgtConfiguration.setTenantManagerClass(tenantManagerClass);\n            tenantMgtConfiguration.setTenantStoreProperties(tenantMgtProperties);\n            return tenantMgtConfiguration;\n        }\n    }\n    String errorMessage = \"Error in locating TenantManager compatible with PrimaryUserStore.\" + \" Required a TenantManager using \" + tenantManagerClass + \" in tenant-mgt.xml.\";\n    if (log.isDebugEnabled()) {",
        "pred_variables": [
            "tenantMgtProperties",
            "tenantMgtConfigElement",
            "Iterator",
            "tenantManagerClass",
            "TenantMgtConfig"
        ],
        "label_variables": [
            "errorMessage"
        ]
    },
    {
        "code": "private void registerMariadbEnvironment(MariaDBContainer mariadb, ConfigurableEnvironment environment, MariaDBProperties properties) {\n    Integer mappedPort = mariadb.getMappedPort(properties.getPort());\n    String host = mariadb.getHost();\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.mariadb.port\", mappedPort);\n    map.put(\"embedded.mariadb.host\", host);\n    map.put(\"embedded.mariadb.schema\", properties.getDatabase());\n    map.put(\"embedded.mariadb.user\", properties.getUser());\n    map.put(\"embedded.mariadb.password\", properties.getPassword());\n    String jdbcURL = \"jdbc:mysql://{}:{}/{}\";",
        "pred_variables": [
            "properties"
        ],
        "label_variables": [
            "mappedPort",
            "host",
            "map"
        ]
    },
    {
        "code": "@Override\npublic void init(Object... objs) {",
        "pred_variables": [
            "objs"
        ],
        "label_variables": [
            "objs"
        ]
    },
    {
        "code": "        message.setLongProperty(\"sendTime\", sendTime);\n        producer.send(message);\n        LOG.debug(\"Receiving message \" + i);\n        Message receivedMessage = consumer.receive(5000);\n        assertNotNull(\"On message \" + i, receivedMessage);\n        assertTrue(\"On message \" + i, receivedMessage instanceof StreamMessage);\n        StreamMessage receivedStreamMessage = (StreamMessage) receivedMessage;\n        int numElements = 0;\n        try {\n            while (true) {\n                receivedStreamMessage.readBoolean();\n                numElements++;\n            }\n        } catch (Exception ex) {\n        }",
        "pred_variables": [
            "i",
            "numElements"
        ],
        "label_variables": [
            "i",
            "numElements"
        ]
    },
    {
        "code": "    final INetStreamEventHandler netStreamEventHandler = new INetStreamEventHandler() {\n\n        @Override\n        public void onStreamEvent(Notify notify) {\n            log.info(\"ClientStream.dispachEvent() {}\", notify);\n        }\n    };\n    client.setStreamEventHandler(netStreamEventHandler);\n    IPendingServiceCallback connectCallback = new IPendingServiceCallback() {\n\n        @Override\n        public void resultReceived(IPendingServiceCall call) {\n            log.info(\"connectCallback\");\n            ObjectMap<?, ?> map = (ObjectMap<?, ?>) call.getResult();\n            String code = (String) map.get(\"code\");",
        "pred_variables": [],
        "label_variables": [
            "code"
        ]
    },
    {
        "code": "@Override\npublic void setFeatureState(FeatureState featureState) {\n    if (customLogMessage != null) {",
        "pred_variables": [
            "featureState"
        ],
        "label_variables": [
            "featureState"
        ]
    },
    {
        "code": "@Test(timeout = 120 * 1000)\npublic void testMissingLogsCausesBrokerToFail() throws Exception {\n    fillUpSomeLogFiles();\n    int jobCount = schedulerStore.getJobScheduler(\"JMS\").getAllJobs().size();",
        "pred_variables": [
            "jobCount"
        ],
        "label_variables": [
            "jobCount"
        ]
    },
    {
        "code": "@Override\npublic Appendable targetASCII(String name, long id) {",
        "pred_variables": [
            "id",
            "name"
        ],
        "label_variables": [
            "name"
        ]
    },
    {
        "code": "private void reportPercent(int percent) {\n    if (percent % STRIDE == 0) {",
        "pred_variables": [
            "percent"
        ],
        "label_variables": [
            "percent"
        ]
    },
    {
        "code": "/**\n * \u63a5\u6536\u5230\u533a\u5757\u6d88\u606f\uff0c\u8fdb\u884c\u533a\u5757\u5408\u6cd5\u6027\u9a8c\u8bc1\uff0c\u5982\u679c\u9a8c\u8bc1\u901a\u8fc7\uff0c\u5219\u6536\u5f55\uff0c\u7136\u540e\u8f6c\u53d1\u533a\u5757\n */\n@Override\npublic MessageProcessResult process(Message message, Peer peer) {\n    if (log.isDebugEnabled()) {",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "@Override\npublic void handleSimple(ServerRequest<GeneratedMessageV3> serverRequest) {\n    final GeneratedMessageV3 data = serverRequest.getData();\n    if (data instanceof PSpanChunk) {\n        handleSpanChunk((PSpanChunk) data);\n    } else {",
        "pred_variables": [
            "data"
        ],
        "label_variables": [
            "serverRequest"
        ]
    },
    {
        "code": "@Override\npublic CompletableFuture<BenchmarkConsumer> createConsumer(String topic, String subscriptionName, ConsumerCallback consumerCallback) {\n    return CompletableFuture.supplyAsync(() -> {\n        try {\n            DistributedLogManager dlm = namespace.openLog(topic);",
        "pred_variables": [
            "DistributedLogManager"
        ],
        "label_variables": [
            "topic"
        ]
    },
    {
        "code": "private void registerElasticSearchEnvironment(ElasticsearchContainer elasticSearch, ConfigurableEnvironment environment, ElasticSearchProperties properties) {\n    Integer httpPort = elasticSearch.getMappedPort(properties.getHttpPort());\n    Integer transportPort = elasticSearch.getMappedPort(properties.getTransportPort());\n    String host = elasticSearch.getHost();\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.elasticsearch.clusterName\", properties.getClusterName());\n    map.put(\"embedded.elasticsearch.host\", host);\n    map.put(\"embedded.elasticsearch.httpPort\", httpPort);\n    map.put(\"embedded.elasticsearch.transportPort\", transportPort);",
        "pred_variables": [
            "host",
            "properties",
            "String",
            "elasticsearch",
            "httpPort"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"elasticsearch\")\nToxiproxyContainer.ContainerProxy elasticsearchContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(BEAN_NAME_EMBEDDED_ELASTIC_SEARCH) ElasticsearchContainer elasticSearch, ElasticSearchProperties properties, ConfigurableEnvironment environment) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(elasticSearch, properties.getHttpPort());\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.elasticsearch.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.elasticsearch.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.elasticsearch.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedElasticSearchToxiproxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "@Override\npublic void warn(String msg, Throwable thrown) {",
        "pred_variables": [
            "msg"
        ],
        "label_variables": [
            "msg",
            "thrown"
        ]
    },
    {
        "code": "@Override\npublic void doStop() {\n    try {\n        openEjbSystem.removeApplication(appInfo, classLoader);\n    } catch (NoSuchApplicationException e) {\n        log.error(\"Module does not exist.\", e);\n    } catch (UndeployException e) {\n        List<Throwable> causes = e.getCauses();\n        log.error(e.getMessage() + \": Encountered \" + causes.size() + \" failures.\");\n        for (Throwable throwable : causes) {",
        "pred_variables": [
            "throwable"
        ],
        "label_variables": [
            "throwable"
        ]
    },
    {
        "code": "public boolean isValidSessionId(String userName, String sessionId) {\n    if (sessionId == null) {\n        log.error(\"In two step authentication workflow session_id is mandatory\");\n        return false;\n    }\n    SessionId ldapSessionId = sessionIdService.getSessionId(sessionId);\n    if (ldapSessionId == null) {",
        "pred_variables": [
            "step"
        ],
        "label_variables": [
            "sessionId"
        ]
    },
    {
        "code": "            try {\n                peer.sendMessage(message);\n                successCount++;\n            } catch (NotYetConnectedException | IOException e) {\n                log.warn(\"\u5e7f\u64ad\u6d88\u606f\u51fa\u9519\uff0c\u53ef\u80fd\u539f\u56e0\u662f\u8be5\u8282\u70b9\u8fde\u63a5\u5df2\u5173\u95ed, {}\", e.getMessage());\n            }\n            if (successCount == count) {\n                return successCount;\n            }\n        }\n        return successCount;\n    } else {\n        log.warn(\"\u5e7f\u64ad\u6d88\u606f\u5931\u8d25\uff0c\u6ca1\u6709\u53ef\u5e7f\u64ad\u7684\u8282\u70b9\");\n    }\n    if (log.isDebugEnabled()) {",
        "pred_variables": [
            "count"
        ],
        "label_variables": [
            "successCount",
            "message"
        ]
    },
    {
        "code": "        writer.writeNamespace(\"wsa\", WS_ADDRESSING_NS);\n        writer.writeNamespace(\"auth\", WS_FEDERATION_NS);\n        writer.writeNamespace(\"xsi\", SCHEMA_INSTANCE_NS);\n        if (\"http://docs.oasis-open.org/wsfed/federation/200706\".equals(serviceConfig.getProtocol())) {\n            writeFederationMetadata(writer, serviceConfig, serviceURL);\n        } else if (\"urn:oasis:names:tc:SAML:2.0:profiles:SSO:browser\".equals(serviceConfig.getProtocol())) {\n            writeSAMLMetadata(writer, serviceConfig, serviceURL, crypto);\n        }\n        // EntityDescriptor\n        writer.writeEndElement();\n        writer.writeEndDocument();\n        writer.close();\n        if (LOG.isDebugEnabled()) {\n            String out = DOM2Writer.nodeToString(writer.getDocument());\n            LOG.debug(\"***************** unsigned ****************\");",
        "pred_variables": [
            "browser",
            "names",
            "DOM2Writer",
            "out"
        ],
        "label_variables": [
            "out"
        ]
    },
    {
        "code": "/**\n * Inform when connection with server is lost.\n *\n * @param throwable Connection lost cause\n */\n@Override\npublic void connectionLost(Throwable throwable) {",
        "pred_variables": [
            "throwable"
        ],
        "label_variables": [
            "throwable"
        ]
    },
    {
        "code": "@Test\npublic void testMakeTransaction() throws Exception {\n    //\t\tProduct product = createProduct();\n    //\u6211\u7684\u8d26\u6237\n    Account account = accountKit.getDefaultAccount();\n    account.decryptionTr(\"inchain123\");\n    long nonce = RandomUtil.randomLong();\n    long password = RandomUtil.randomLong();\n    Sha256Hash productTx = Sha256Hash.wrap(\"6cb7f57548c98e9c29a698b2cb219c53850b429c448da6999868a0cfc89e2558\");\n    GeneralAntifakeTransaction tx = new GeneralAntifakeTransaction(network, productTx, nonce, password);\n    tx.makeSign(account);\n    //\u4e0d\u80fd\u5e7f\u64ad\n    //\t\ttx.verfify();\n    //\t\ttx.verfifyScript();",
        "pred_variables": [
            "tx",
            "account",
            "productTx",
            "inchain123"
        ],
        "label_variables": [
            "tx"
        ]
    },
    {
        "code": "private void registerDynamodbEnvironment(GenericContainer<?> container, ConfigurableEnvironment environment, DynamoDBProperties properties) {\n    Integer mappedPort = container.getMappedPort(properties.port);\n    String host = container.getHost();\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.dynamodb.port\", mappedPort);\n    map.put(\"embedded.dynamodb.host\", host);\n    map.put(\"embedded.dynamodb.accessKey\", properties.getAccessKey());\n    map.put(\"embedded.dynamodb.secretKey\", properties.getSecretKey());",
        "pred_variables": [
            "host",
            "properties",
            "mappedPort",
            "dynamodb",
            "port",
            "container"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "private boolean isActuallyWritable(Path p) {\n    Path tmpFile = p.resolve(TEMP_FILE_FORMAT);\n    try (var chan = Files.newByteChannel(tmpFile, StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE, StandardOpenOption.DELETE_ON_CLOSE)) {\n        return true;\n    } catch (IOException e) {\n        return false;\n    } finally {\n        try {\n            Files.deleteIfExists(tmpFile);\n        } catch (IOException e) {",
        "pred_variables": [
            "p",
            "TEMP_FILE_FORMAT",
            "tmpFile"
        ],
        "label_variables": [
            "tmpFile"
        ]
    },
    {
        "code": "public void logConnectionProviderStatistic(PersistenceEntryManager ldapEntryManager, String connectionProviderName, String bindConnectionProviderName) {\n    PersistenceOperationService persistenceOperationService = ldapEntryManager.getOperationService();\n    if (!(persistenceOperationService instanceof LdapOperationService)) {\n        return;\n    }\n    LdapConnectionProvider ldapConnectionProvider = ((LdapOperationService) persistenceOperationService).getConnectionProvider();\n    LdapConnectionProvider bindLdapConnectionProvider = ((LdapOperationService) persistenceOperationService).getBindConnectionProvider();\n    if (ldapConnectionProvider == null) {",
        "pred_variables": [
            "LdapOperationService"
        ],
        "label_variables": [
            "connectionProviderName"
        ]
    },
    {
        "code": "private ClassPathBeanDefinitionScanner scan() {\n    BeanDefinitionRegistry beanDefinitionRegistry = new SimpleBeanDefinitionRegistry();\n    ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(beanDefinitionRegistry);\n    scanner.setIncludeAnnotationConfig(false);\n    scanner.addIncludeFilter(new AnnotationTypeFilter(BusAware.class));\n    BeanNameGenerator beanNameGenerator = new FullyQualifiedAnnotationBeanNameGenerator();\n    scanner.setBeanNameGenerator(beanNameGenerator);\n    int numberOfBeans = scanner.scan(packageName);",
        "pred_variables": [
            "numberOfBeans",
            "beanNameGenerator",
            "addIncludeFilter"
        ],
        "label_variables": [
            "numberOfBeans"
        ]
    },
    {
        "code": "private boolean hasRuleMatchFor(InputComponent component, FilterableIssue issue) {\n    for (WildcardPattern pattern : rulePatternByComponent.getOrDefault(component, Collections.emptyList())) {\n        if (pattern.match(issue.ruleKey().toString())) {",
        "pred_variables": [
            "issue",
            "pattern"
        ],
        "label_variables": [
            "issue",
            "pattern"
        ]
    },
    {
        "code": "public String mapSignInRequest(RequestContext requestContext, String trustedIdpRealm) {",
        "pred_variables": [
            "trustedIdpRealm",
            "requestContext"
        ],
        "label_variables": [
            "trustedIdpRealm"
        ]
    },
    {
        "code": "public boolean isAllowedBySpontaneousScope(String spontaneousScope, String scopeRequested) {\n    try {\n        boolean result = spontaneousScope.equals(scopeRequested);\n        if (!result) {\n            result = Pattern.matches(spontaneousScope, scopeRequested);\n        }\n        if (result) {",
        "pred_variables": [
            "result",
            "spontaneousScope",
            "scopeRequested"
        ],
        "label_variables": [
            "scopeRequested",
            "spontaneousScope"
        ]
    },
    {
        "code": "private static void handleException(String msg, Exception e) {",
        "pred_variables": [
            "msg",
            "e"
        ],
        "label_variables": [
            "msg",
            "e"
        ]
    },
    {
        "code": "private void handleSpan(PSpan span) {\n    if (isDebug) {",
        "pred_variables": [
            "span"
        ],
        "label_variables": [
            "span"
        ]
    },
    {
        "code": "private boolean executeExternalNotifyEndUser(CustomScriptConfiguration customScriptConfiguration, ExternalCibaEndUserNotificationContext context) {\n    try {",
        "pred_variables": [
            "customScriptConfiguration",
            "context"
        ],
        "label_variables": [
            "context"
        ]
    },
    {
        "code": "private void addCustomConfigurationProviderProperties(ManagerParameter parameter) {\n    final String providersStrList = System.getProperty(ConfigurationProvider.CONFIG_PROVIDERS_PROPERTY);\n    if (providersStrList != null) {\n        final String[] providersClassNames = providersStrList.split(\",\");\n        for (String providerClassName : providersClassNames) {\n            if (providerClassName == null || \"\".equals(providerClassName))\n                continue;\n            try {\n                final Class<?> providerClass = Class.forName(providerClassName.trim(), true, classLoadingUtil.getClassloader());\n                final ConfigurationProvider configurationProvider = ConfigurationProvider.class.cast(providerClass.getDeclaredConstructor().newInstance());\n                parameter.mergeProperties(configurationProvider.getProperties());\n            } catch (Exception e) {",
        "pred_variables": [
            "configurationProvider",
            "CONFIG_PROVIDERS_PROPERTY",
            "forName",
            "classLoadingUtil"
        ],
        "label_variables": [
            "providerClassName"
        ]
    },
    {
        "code": "/**\n * {@inheritDoc}\n */\n@SuppressWarnings(\"rawtypes\")\npublic void onClientListenerEvent(IRTMPEvent event) {",
        "pred_variables": [
            "event"
        ],
        "label_variables": [
            "event"
        ]
    },
    {
        "code": "@Override\npublic Tokenizer create() {\n    Settings settings = indexSettings.getSettings().getAsSettings(\"index.analysis.tokenizer.\" + name());\n    Map<String, String> args = settings.keySet().stream().collect(Collectors.toMap(k -> k, settings::get));\n    if (args.isEmpty()) {\n        args.putAll(AnsjElasticConfigurator.getDefaults());\n        args.put(\"type\", name());\n    }",
        "pred_variables": [
            "getSettings",
            "Map",
            "settings",
            "analysis",
            "index",
            "k",
            "name",
            "args",
            "type"
        ],
        "label_variables": [
            "args"
        ]
    },
    {
        "code": "@GET\n@Produces({ \"application/json\" })\npublic Response startAuthentication(@QueryParam(\"username\") String userName, @QueryParam(\"keyhandle\") String keyHandle, @QueryParam(\"application\") String appId, @QueryParam(\"session_id\") String sessionId) {\n    // Parameter username is deprecated. We uses it only to determine is it's one or two step workflow\n    try {\n        if (appConfiguration.getDisableU2fEndpoint()) {\n            return Response.status(Status.FORBIDDEN).build();\n        }",
        "pred_variables": [
            "username",
            "sessionId"
        ],
        "label_variables": [
            "appId",
            "sessionId",
            "userName",
            "keyHandle"
        ]
    },
    {
        "code": "@Override\npublic Future<JsonObject> getQueueRequest(String queue) {\n    Promise<JsonObject> promise = Promise.promise();\n    if (StringUtils.isEmpty(queue)) {\n        promise.fail(\"Queue is not allowed to be empty\");\n        return promise.future();\n    }\n    redisAPI.hget(QUEUE_REQUESTS, queue, reply -> {\n        if (reply.failed()) {\n            String message = \"get queue request '\" + queue + \"' from hash '\" + QUEUE_REQUESTS + \"' resulted in cause \" + logCause(reply);",
        "pred_variables": [
            "reply",
            "queue"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "@GET\n@Produces({ \"application/json\" })\npublic Response getConfiguration() {\n    try {\n        final GluuConfiguration conf = new GluuConfiguration();\n        conf.setIdGenerationEndpoint(appConfiguration.getIdGenerationEndpoint());\n        conf.setIntrospectionEndpoint(appConfiguration.getIntrospectionEndpoint());\n        conf.setAuthLevelMapping(createAuthLevelMapping());\n        conf.setScopeToClaimsMapping(createScopeToClaimsMapping());\n        // convert manually to avoid possible conflicts between resteasy\n        // providers, e.g. jettison, jackson\n        final String entity = ServerUtil.asPrettyJson(conf);",
        "pred_variables": [
            "conf"
        ],
        "label_variables": [
            "entity"
        ]
    },
    {
        "code": "private List<RuleFeatures> collectRuleFeatures(List<Rule> rules) {\n    List<RuleFeatures> featuresList = new ArrayList<>();\n    for (Rule rule : rules) {\n        boolean isStorageExpand = rule.isStorageExpand();\n        boolean isExpandOnBackend = rule.isExpandOnBackend();\n        boolean isDeltaOnBackend = rule.isDeltaOnBackend();\n        try {\n            Pattern pattern = Pattern.compile(rule.getUrlPattern());\n            featuresList.add(new RuleFeatures(pattern, ImmutableMap.of(RuleFeatures.Feature.STORAGE_EXPAND, isStorageExpand, RuleFeatures.Feature.EXPAND_ON_BACKEND, isExpandOnBackend, RuleFeatures.Feature.DELTA_ON_BACKEND, isDeltaOnBackend)));",
        "pred_variables": [
            "rules"
        ],
        "label_variables": [
            "isStorageExpand",
            "isExpandOnBackend",
            "isDeltaOnBackend"
        ]
    },
    {
        "code": "                    uriPatternSessionKey = pv.asStringValue();\n                }\n            }\n        } catch (ParameterException e) {\n            throw new PipeRunException(this, \"exception extracting parameters\", e);\n        }\n    }\n    //hash over data genereren, uit cache lezen en teruggeven, in cache updaten, verwijderen uit cache, cache naar disk wegschrijven, cache legen\n    String cacheKey = null;\n    if (uriPatternSessionKey != null && !uriPatternSessionKey.isEmpty())\n        cacheKey = getRestPath() + \"_\" + uriPatternSessionKey.toLowerCase();\n    else\n        cacheKey = getRestPath() + \"_\" + getUriPattern();\n    if (cache != null && cache.containsKey(cacheKey)) {\n        Object returnCode = false;",
        "pred_variables": [
            "Object",
            "uriPatternSessionKey",
            "cacheKey"
        ],
        "label_variables": [
            "cacheKey"
        ]
    },
    {
        "code": "        producer.send(session.createTextMessage(\"Message 1\"));\n        // committing the session prior to the close\n        session.commit();\n        // starting a new transaction\n        producer.send(session.createTextMessage(\"Message 2\"));\n        // in a new transaction, with prefetch>0, the message\n        // 1 will be pending till second commit\n        LOG.info(\"Closing consumer 1...\");\n        consumer.close();\n        // create a consumer\n        consumer = session.createConsumer(test_data_destination);\n        LOG.info(\"Consumer 2 connected\");\n        // retrieve message previously committed to tmp queue\n        Message message = consumer.receive(10000);\n        if (message != null) {",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "@Override\npublic void onStart(NetworkBridge bridge) {\n    if (!brokerService.isUseJmx()) {\n        return;\n    }\n    NetworkBridgeView view = new NetworkBridgeView(bridge);\n    view.setCreateByDuplex(createdByDuplex);\n    try {\n        ObjectName objectName = createNetworkBridgeObjectName(bridge);\n        AnnotatedMBean.registerMBean(brokerService.getManagementContext(), view, objectName);\n        bridge.setMbeanObjectName(objectName);\n        MBeanBridgeDestination mBeanBridgeDestination = new MBeanBridgeDestination(brokerService, networkBridgeConfiguration, bridge, view);\n        destinationObjectNameMap.put(bridge, mBeanBridgeDestination);\n        mBeanBridgeDestination.start();",
        "pred_variables": [
            "bridge"
        ],
        "label_variables": [
            "objectName",
            "bridge"
        ]
    },
    {
        "code": "@Override\npublic void send(Notification notification) {\n    byte[] json = toJsonAsBytes(notification);\n    if (json != null) {\n        String response = httpPostRequest.send(json);\n        if (Strings.isNotBlank(response)) {",
        "pred_variables": [
            "json",
            "notification"
        ],
        "label_variables": [
            "response"
        ]
    },
    {
        "code": "@Bean(name = BEAN_NAME_EMBEDDED_REDIS, destroyMethod = \"stop\")\npublic GenericContainer<?> redis(ConfigurableEnvironment environment, @Qualifier(REDIS_WAIT_STRATEGY_BEAN_NAME) WaitStrategy redisStartupCheckStrategy, Optional<Network> network) throws Exception {\n    // CLUSTER SLOTS command returns IP:port for each node, so ports outside and inside\n    // container must be the same\n    GenericContainer<?> redis = new FixedHostPortGenericContainer(ContainerUtils.getDockerImageName(properties).asCanonicalNameString()).withFixedExposedPort(properties.getPort(), properties.getPort()).withExposedPorts(properties.getPort()).withEnv(\"REDIS_USER\", properties.getUser()).withEnv(\"REDIS_PASSWORD\", properties.getPassword()).withCopyFileToContainer(MountableFile.forHostPath(prepareRedisConf()), \"/data/redis.conf\").withCopyFileToContainer(MountableFile.forHostPath(prepareNodesConf()), \"/data/nodes.conf\").withCommand(\"redis-server\", \"/data/redis.conf\").waitingFor(redisStartupCheckStrategy);\n    network.ifPresent(redis::withNetwork);\n    redis = configureCommonsAndStart(redis, properties, log);\n    Map<String, Object> redisEnv = registerRedisEnvironment(environment, redis, properties, properties.getPort());",
        "pred_variables": [
            "command"
        ],
        "label_variables": [
            "redisEnv"
        ]
    },
    {
        "code": "/**\n * Returns true if the url represents a local server (that is port is explicitly set to 0)\n */\npublic static boolean isLocal(String url) {\n    boolean isLocal = false;\n    try {\n        URL urlValue = new URL(url);\n        isLocal = urlValue.getPort() == 0;\n        if (isLocal) {",
        "pred_variables": [
            "url"
        ],
        "label_variables": [
            "url"
        ]
    },
    {
        "code": " *\n * @param port Port number\n * @return True if port mapping is successful.\n */\npublic static boolean mapTcpPort(int port) {\n    try {\n        // Discover gateway\n        GatewayDiscover discover = new GatewayDiscover();\n        discover.discover();\n        GatewayDevice device = discover.getValidGateway();\n        if (device != null) {\n            // Gateway found\n            PortMappingEntry portMapping = new PortMappingEntry();\n            if (device.getSpecificPortMappingEntry(port, \"TCP\", portMapping)) {\n                // Mapping already registered",
        "pred_variables": [
            "already",
            "registered",
            "gateway",
            "getValidGateway",
            "device",
            "port"
        ],
        "label_variables": [
            "port"
        ]
    },
    {
        "code": "@Override\npublic void dispatchEvent(IEvent event) {",
        "pred_variables": [
            "event"
        ],
        "label_variables": [
            "event"
        ]
    },
    {
        "code": "@Override\npublic void visitFragmentOpen(String name, long id, int cursor) {",
        "pred_variables": [
            "id",
            "name"
        ],
        "label_variables": [
            "name"
        ]
    },
    {
        "code": "private void logException(HttpServletRequest request, AuthenticationException exception, String username) {\n    String ipAddress = request.getRemoteAddr();\n    if (exception instanceof IpAddressAuthenticationRateException) {\n        if (messageAlreadyLogged != null && messageAlreadyLogged.getIfPresent(ipAddress) != Boolean.TRUE) {\n            messageAlreadyLogged.put(ipAddress, Boolean.TRUE);\n            log.warn(\"Possible brute force attack, authentication attempt rate limit exceeded for IP address \" + ipAddress);\n        }\n    } else if (exception instanceof UsernameAuthenticationRateException) {\n        if (rateLimitUsernameLogged != null && rateLimitUsernameLogged.getIfPresent(username) != Boolean.TRUE) {\n            rateLimitUsernameLogged.put(username, Boolean.TRUE);\n            log.warn(\"Possible brute force attack, authentication attempt rate limit exceeded against username \" + username);\n        }\n    } else if (exception instanceof BadCredentialsException || exception instanceof DisabledException || exception instanceof LockedException) {\n        log.warn(\"Failed login attempt on user '\" + username + \"' from IP \" + ipAddress);\n    } else {",
        "pred_variables": [
            "rateLimitUsernameLogged",
            "IP",
            "username",
            "exception",
            "TRUE"
        ],
        "label_variables": [
            "exception"
        ]
    },
    {
        "code": "public WebDriver createRemoteWebDriver(String remoteUrl, Capabilities capabilities) {\n    WebDriver webdriver = null;\n    int waitTimeoutSec = config.getTimeout();\n    long timeoutMs = System.currentTimeMillis() + TimeUnit.SECONDS.toMillis(waitTimeoutSec);\n    String browserName = capabilities.getBrowserName();",
        "pred_variables": [
            "timeoutMs",
            "waitTimeoutSec",
            "capabilities",
            "TimeUnit"
        ],
        "label_variables": [
            "capabilities",
            "browserName",
            "remoteUrl"
        ]
    },
    {
        "code": "/**\n * {@inheritDoc}\n */\n@Override\npublic boolean addData(IoBuffer data, int timestamp, boolean amf) {",
        "pred_variables": [
            "data",
            "timestamp",
            "amf"
        ],
        "label_variables": [
            "amf",
            "timestamp"
        ]
    },
    {
        "code": "            sysp.setValue(properties.get(i));\n            javaTask.addSysproperty(sysp);\n        }\n        if (verbose) {\n            javaTask.createArg().setValue(\"--verbose\");\n        }\n        javaTask.createArg().setValue(moduleName);\n        if (moduleArguments != null) {\n            for (String m : moduleArguments) {\n                javaTask.createArg().setValue(m);\n            }\n        }\n        javaTask.execute();\n    } catch (ExitStatusException e) {\n        String tmp = \"\";",
        "pred_variables": [
            "createArg",
            "tmp",
            "javaTask"
        ],
        "label_variables": [
            "tmp"
        ]
    },
    {
        "code": "@Override\npublic void onException(Message message, Exception exception) {",
        "pred_variables": [
            "message",
            "exception"
        ],
        "label_variables": [
            "exception"
        ]
    },
    {
        "code": "private static void handleException(String msg) {",
        "pred_variables": [
            "msg"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "/*\n     * (non-Javadoc)\n     * @see org.red5.server.adapter.MultiThreadedApplicationAdapter#appConnect(org.red5.server.api.IConnection, java.lang.Object[])\n     */\n@Override\npublic boolean appConnect(IConnection conn, Object[] params) {",
        "pred_variables": [
            "params"
        ],
        "label_variables": [
            "params"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"cassandra\")\nToxiproxyContainer.ContainerProxy cassandraContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(BEAN_NAME_EMBEDDED_CASSANDRA) CassandraContainer cassandra, CassandraProperties properties, ConfigurableEnvironment environment) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(cassandra, properties.getPort());\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.cassandra.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.cassandra.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.cassandra.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedCassandraToxiproxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"clickhouse\")\nToxiproxyContainer.ContainerProxy clickhouseContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(BEAN_NAME_EMBEDDED_CLICK_HOUSE) ClickHouseContainer clickHouseContainer, ClickHouseProperties properties, ConfigurableEnvironment environment) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(clickHouseContainer, properties.getPort());\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.clickhouse.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.clickhouse.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.clickhouse.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedClickHouseToxiproxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [
            "propertySource"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "protected void doCollection(TransportConnection tc) {",
        "pred_variables": [
            "tc"
        ],
        "label_variables": [
            "tc"
        ]
    },
    {
        "code": "@Override\npublic boolean removeJobScheduler(String name) throws Exception {\n    boolean result = false;\n    this.lock.lock();\n    try {\n        InMemoryJobScheduler scheduler = this.schedulers.remove(name);\n        result = scheduler != null;\n        if (result) {",
        "pred_variables": [
            "name"
        ],
        "label_variables": [
            "name"
        ]
    },
    {
        "code": "@Override\npublic void onException(IOException error) {\n    synchronized (this) {\n        setHasExpired(true);\n        // only log if not stopped\n        if (!stopped.get()) {",
        "pred_variables": [
            "error"
        ],
        "label_variables": [
            "error"
        ]
    },
    {
        "code": "private String getCustomSTSParameterValue() {\n    String authRealmParameter = null;\n    if (getCustomSTSParameter() != null) {\n        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes()).getRequest();\n        authRealmParameter = request.getParameter(getCustomSTSParameter());\n        if (authRealmParameter == null) {\n            HttpServletResponse response = ((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes()).getResponse();\n            SavedRequest savedRequest = requestCache.getRequest(request, response);\n            if (savedRequest != null) {\n                String[] parameterValues = savedRequest.getParameterValues(this.getCustomSTSParameter());\n                if (parameterValues != null && parameterValues.length > 0) {\n                    authRealmParameter = parameterValues[0];\n                }\n            }\n        }",
        "pred_variables": [
            "getParameterValues",
            "parameterValues"
        ],
        "label_variables": [
            "authRealmParameter"
        ]
    },
    {
        "code": "private AnalyzerConfiguration synchronizeAnalyzerConfig(ServerApi serverApi, String projectKey, ProgressMonitor progressMonitor) {",
        "pred_variables": [
            "String",
            "projectKey",
            "progressMonitor"
        ],
        "label_variables": [
            "projectKey"
        ]
    },
    {
        "code": "@Test(timeout = 120000)\npublic void testGcDoneAtStop() throws Exception {\n    brokerService = createBroker(true);\n    brokerService.start();\n    produceWithScheduledDelayAndConsume();\n    LOG.info(\"job store: \" + jobSchedulerStore);\n    int numSchedulerFiles = jobSchedulerStore.getJournal().getFileMap().size();\n    LOG.info(\"kahadb store: \" + kahaDBPersistenceAdapter);\n    int numKahadbFiles = kahaDBPersistenceAdapter.getStore().getJournal().getFileMap().size();",
        "pred_variables": [
            "numKahadbFiles"
        ],
        "label_variables": [
            "numKahadbFiles"
        ]
    },
    {
        "code": "public void testAnyElements() throws Exception {\n    File schema1 = new File(BASEDIR, \"src/test/resources/schema/schema5.xsd\");\n    log.debug(\"SCHEMA 5\");\n    Map map = parse(schema1);\n    assertEquals(8, map.size());\n    Map elements = schemaInfoBuilder.getElementToTypeMap();\n    log.debug(\"ELEMENT MAP\");",
        "pred_variables": [
            "xsd",
            "schema1"
        ],
        "label_variables": [
            "elements"
        ]
    },
    {
        "code": "@Override\npublic void onWebSocketClose(int statusCode, String reason) {",
        "pred_variables": [
            "reason",
            "statusCode"
        ],
        "label_variables": [
            "reason",
            "statusCode"
        ]
    },
    {
        "code": "@Override\npublic void drop() {\n    indexProxyStrategy.removeStatisticsForIndex();\n    String message = \"FailedIndexProxy#drop index on \" + indexProxyStrategy.getIndexUserDescription() + \" dropped due to:\\n\" + getPopulationFailure().asString();",
        "pred_variables": [
            "drop",
            "message"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "public void run() {\n    List<Peer> peers = peerKit.findAvailablePeers();\n    Message sendMessage = converMessage(message, result);\n    //\u901a\u8fc7\u4e00\u534a\u7684\u5bf9\u7b49\u4f53\u5e7f\u64ad\u51fa\u53bb\uff0c\u5982\u679c\u6536\u5230\u4e00\u534a\u4ee5\u4e0a\u7684inv\u6d88\u606f\uff0c\u5219\u4ee3\u8868\u6210\u529f\n    int numConnected = peers.size();\n    int numToBroadcastTo = (int) Math.max(1, Math.round(Math.ceil(peers.size() / 2.0)));\n    int numWaitingFor = (int) Math.max(1, Math.ceil((numConnected - numToBroadcastTo) / 2.0));\n    Collections.shuffle(peers, random);\n    peers = peers.subList(0, numToBroadcastTo);",
        "pred_variables": [
            "numToBroadcastTo",
            "numWaitingFor",
            "peers",
            "findAvailablePeers"
        ],
        "label_variables": [
            "numConnected",
            "sendMessage"
        ]
    },
    {
        "code": "@Override\npublic void corruptedCheckpointFile(long version, Throwable t) {",
        "pred_variables": [
            "t",
            "version"
        ],
        "label_variables": [
            "t",
            "version"
        ]
    },
    {
        "code": "@Override\nprotected void createModel(Object object) {\n    RateLimit rateLimit = (RateLimit) object;\n    RateLimit updatedRateLimit = rateLimitRepository.incrementAndGet(rateLimit.getKey(), rateLimit.getCounter(), () -> initialize(rateLimit)).blockingGet();\n    RATE_LIMITS.put(updatedRateLimit.getKey(), updatedRateLimit);",
        "pred_variables": [
            "updatedRateLimit",
            "incrementAndGet",
            "getCounter",
            "initialize",
            "getKey",
            "rateLimit",
            "rateLimitRepository"
        ],
        "label_variables": [
            "updatedRateLimit"
        ]
    },
    {
        "code": "    List<Driver> drivers = new ArrayList<Driver>();\n    try {\n        BufferedReader in = new BufferedReader(new InputStreamReader(providerURL.openStream()));\n        String line;\n        while ((line = in.readLine()) != null) {\n            line = line.trim();\n            try {\n                Class<?> driverClass = bundle.loadClass(line);\n                drivers.add((Driver) driverClass.newInstance());\n            } catch (Exception e) {\n                LOG.warn(\"Failed to load driver {}\", line, e);\n            }\n        }\n    } catch (IOException e) {\n        // ignore - shouldn't happen",
        "pred_variables": [
            "in",
            "Driver",
            "line"
        ],
        "label_variables": [
            "providerURL"
        ]
    },
    {
        "code": "@POST\n@Produces({ \"application/json\" })\npublic Response finishAuthentication(@FormParam(\"username\") String userName, @FormParam(\"tokenResponse\") String authenticateResponseString) {\n    String sessionId = null;\n    try {\n        if (appConfiguration.getDisableU2fEndpoint()) {\n            return Response.status(Status.FORBIDDEN).build();\n        }",
        "pred_variables": [
            "username"
        ],
        "label_variables": [
            "userName",
            "authenticateResponseString"
        ]
    },
    {
        "code": "@Override\npublic void commitsAfterLastCheckPoint(LogPosition logPosition, long firstTxIdAfterLastCheckPoint) {",
        "pred_variables": [
            "firstTxIdAfterLastCheckPoint",
            "logPosition"
        ],
        "label_variables": [
            "logPosition",
            "firstTxIdAfterLastCheckPoint"
        ]
    },
    {
        "code": "@Test\nvoid test() {\n    String sutUrl = \"https://bonigarcia.dev/selenium-webdriver-java/\";\n    driver.get(sutUrl);\n    String title = driver.getTitle();",
        "pred_variables": [
            "https"
        ],
        "label_variables": [
            "sutUrl",
            "title"
        ]
    },
    {
        "code": "private void readPath(Path path, Consumer<String> consumer) throws IOException {\n    Objects.requireNonNull(path);\n    Objects.requireNonNull(consumer);\n    if (!osSupport) {\n        return;\n    }",
        "pred_variables": [
            "path",
            "requireNonNull"
        ],
        "label_variables": [
            "path"
        ]
    },
    {
        "code": "public DataHandler getReportBytes(ReportConfigurationBean configuration) throws Exception {\n    try {\n        return reportingAdminServiceStub.getReportBytes(configuration);\n    } catch (Exception e) {\n        String msg = \"Unable get Report in bytes\";",
        "pred_variables": [
            "msg"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "@Override\npublic void contextInitialized(ServletContextEvent sce) {\n    ServletContext ctx = sce.getServletContext();\n    DefaultWsServerContainer sc = (DefaultWsServerContainer) WebSocketPlugin.getWsServerContainerInstance(ctx);",
        "pred_variables": [
            "WebSocketPlugin",
            "ctx"
        ],
        "label_variables": [
            "sc"
        ]
    },
    {
        "code": "public void validateConfigurationResource(Buffer configurationResource, String resourceSchema, Handler<AsyncResult<ValidationResult>> resultHandler) {\n    vertx.executeBlocking(future -> {\n        if (!JsonUtil.isValidJson(configurationResource)) {\n            String message = \"Unable to parse json\";",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "@Test\npublic void testFLVReaderFile() {\n    log.info(\"\\n testFLVReaderFile\");\n    String[] paths = new String[] { \"target/test-classes/fixtures/h264_aac.flv\", \"target/test-classes/fixtures/h264_mp3.flv\", \"target/test-classes/fixtures/h264_speex.flv\", \"target/test-classes/fixtures/stray.flv\", \"target/test-classes/fixtures/NAPNAP.flv\", \"target/test-classes/fixtures/dummy.flv\" };\n    try {\n        for (String path : paths) {\n            File file = Paths.get(path).toFile();\n            if (file.exists() && file.canRead()) {\n                log.info(\"Reading: {}\", file.getName());\n                FLVReader reader = new FLVReader(file, true);\n                //KeyFrameMeta meta = reader.analyzeKeyFrames();\n                //log.debug(\"Meta: {}\", meta);\n                ITag tag = null;\n                for (int t = 0; t < 6; t++) {\n                    tag = reader.readTag();",
        "pred_variables": [
            "t"
        ],
        "label_variables": [
            "tag"
        ]
    },
    {
        "code": "public Future<Void> storeQueueRequest(String queue, JsonObject queueRequest) {\n    Promise<Void> promise = Promise.promise();\n    if (StringUtils.isEmpty(queue)) {\n        promise.fail(\"Queue is not allowed to be empty\");\n        return promise.future();\n    }\n    if (queueRequest == null) {\n        promise.fail(\"Request is not allowed to be empty\");\n        return promise.future();\n    }\n    try {\n        String queueRequestStr = queueRequest.encode();\n        redisAPI.hset(Arrays.asList(QUEUE_REQUESTS, queue, queueRequestStr), reply -> {\n            if (reply.failed()) {\n                String message = \"Failed to store request for queue '\" + queue + \"'. Cause: \" + logCause(reply);",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "public static String getSynapseConfigAbsPath(ServerContextInformation contextInformation) {\n    String carbonHome = MicroIntegratorBaseUtils.getCarbonHome();\n    ServerConfigurationInformation configInfo = getSynapseServerConfigInfo(contextInformation);\n    if (configInfo == null) {\n        String msg = \"Unable to obtain ESB server configuration information\";",
        "pred_variables": [
            "msg"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "@Test\npublic void test() throws Exception {\n    stompConnect();\n    String connectFrame = \"STOMP\\n\" + \"login:system\\n\" + \"passcode:manager\\n\" + \"accept-version:1.1\\n\" + \"heart-beat:1000,0\\n\" + \"host:localhost\\n\" + \"\\n\" + Stomp.NULL;\n    stompConnection.sendFrame(connectFrame);\n    String response = stompConnection.receiveFrame().trim();",
        "pred_variables": [
            "response"
        ],
        "label_variables": [
            "response"
        ]
    },
    {
        "code": " */\n// *** THE MAGIC IS HERE ***\n@Idempotent\n@Logging(logEvent = true)\npublic APIGatewayProxyResponseEvent handleRequest(final APIGatewayProxyRequestEvent input, final Context context) {\n    Map<String, String> headers = new HashMap<>();\n    headers.put(\"Content-Type\", \"application/json\");\n    headers.put(\"Access-Control-Allow-Origin\", \"*\");\n    headers.put(\"Access-Control-Allow-Methods\", \"GET, OPTIONS\");\n    headers.put(\"Access-Control-Allow-Headers\", \"*\");\n    APIGatewayProxyResponseEvent response = new APIGatewayProxyResponseEvent().withHeaders(headers);\n    try {\n        String address = JsonConfig.get().getObjectMapper().readTree(input.getBody()).get(\"address\").asText();\n        final String pageContents = this.getPageContents(address);\n        String output = String.format(\"{ \\\"message\\\": \\\"hello world\\\", \\\"location\\\": \\\"%s\\\" }\", pageContents);",
        "pred_variables": [
            "output"
        ],
        "label_variables": [
            "pageContents"
        ]
    },
    {
        "code": "                    sysp.setValue(properties.get(i));\n                    javaTask.addSysproperty(sysp);\n                }\n                if (verbose) {\n                    javaTask.createArg().setValue(\"--verbose\");\n                }\n                javaTask.createArg().setValue(moduleName);\n                if (moduleArguments != null) {\n                    for (String m : moduleArguments) {\n                        javaTask.createArg().setValue(m);\n                    }\n                }\n                javaTask.execute();\n            } catch (ExitStatusException e) {\n                String tmp = \"\";",
        "pred_variables": [
            "createArg",
            "tmp",
            "javaTask"
        ],
        "label_variables": [
            "tmp"
        ]
    },
    {
        "code": "/**\n * Returns a {@link QueueingStrategy} based on the provided hookConfiguration. When <code>null</code> is provided\n * or the hookConfiguration contains invalid configuration relating the 'queueingStrategy', a {@link DefaultQueueingStrategy}\n * instance will be returned.\n *\n * @param hookConfiguration the hook configuration containing the 'queueingStrategy' configuration values\n * @return A {@link QueueingStrategy} based on the provided hookConfiguration\n */\npublic static QueueingStrategy buildQueueStrategy(JsonObject hookConfiguration) {\n    QueueingStrategy queueingStrategy = new DefaultQueueingStrategy();\n    if (hookConfiguration == null || !hookConfiguration.containsKey(QUEUEING_STRATEGY_PROPERTY)) {\n        return queueingStrategy;\n    }\n    Object queueingStrategyConfigObj = hookConfiguration.getValue(QUEUEING_STRATEGY_PROPERTY);\n    if (!(queueingStrategyConfigObj instanceof JsonObject)) {",
        "pred_variables": [
            "queueingStrategy",
            "hookConfiguration"
        ],
        "label_variables": [
            "queueingStrategyConfigObj"
        ]
    },
    {
        "code": "/**\n * Logs the error message and throws New AxisFault.\n *\n * @param errorMsg String message which contains error information\n * @throws AxisFault throws with error information\n */\nprotected void handleException(String errorMsg) throws AxisFault {",
        "pred_variables": [
            "errorMsg"
        ],
        "label_variables": [
            "errorMsg"
        ]
    },
    {
        "code": "@Override\npublic Optional<TaintVulnerabilityRaisedEvent> parse(String jsonData) {\n    var payload = gson.fromJson(jsonData, TaintVulnerabilityRaisedEventPayload.class);\n    if (payload.isInvalid()) {",
        "pred_variables": [
            "jsonData",
            "payload"
        ],
        "label_variables": [
            "jsonData"
        ]
    },
    {
        "code": "@Test\npublic void testManyTempDestinations() throws Exception {\n    Connection connection = createConnectionFactory().createConnection();\n    connection.start();\n    Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n    for (int i = 0; i < DEST_COUNT; i++) {\n        destination[i] = session.createTemporaryQueue();",
        "pred_variables": [
            "i"
        ],
        "label_variables": [
            "i"
        ]
    },
    {
        "code": "    int nextChar = code.peek();\n    while (nextChar != -1) {\n        boolean characterConsumed = false;\n        for (Channel<O> channel : channels) {\n            if (channel.consume(code, output)) {\n                characterConsumed = true;\n                break;\n            }\n        }\n        if (!characterConsumed) {\n            if (failIfNoChannelToConsumeOneCharacter) {\n                String message = \"None of the channel has been able to handle character '\" + (char) code.peek() + \"' (decimal value \" + code.peek() + \") at line \" + code.getLinePosition() + \", column \" + code.getColumnPosition();\n                if (failIfNoChannelToConsumeOneCharacter) {\n                    throw new IllegalStateException(message);\n                }",
        "pred_variables": [
            "line",
            "message"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "/**\n * @see org.jivesoftware.openfire.vcard.DefaultVCardProvider#loadVCard(java.lang.String)\n */\n@Override\npublic Element loadVCard(String username) {",
        "pred_variables": [
            "username"
        ],
        "label_variables": [
            "username"
        ]
    },
    {
        "code": "public boolean isValidSigninAddress(RequestContext context, String endpointAddress, String realm) throws Exception {\n    if (endpointAddress == null) {\n        return true;\n    }\n    Idp idpConfig = (Idp) WebUtils.getAttributeFromFlowScope(context, \"idpConfig\");\n    Application serviceConfig = idpConfig.findApplication(realm);\n    if (serviceConfig == null) {",
        "pred_variables": [
            "getAttributeFromFlowScope",
            "realm"
        ],
        "label_variables": [
            "realm"
        ]
    },
    {
        "code": "@Override\npublic Response toResponse(Exception exception) {",
        "pred_variables": [
            "exception"
        ],
        "label_variables": [
            "exception"
        ]
    },
    {
        "code": "@Override\npublic void failToExtractInitialFileHeader(Exception e) {",
        "pred_variables": [
            "e"
        ],
        "label_variables": [
            "e"
        ]
    },
    {
        "code": " * This implementation uses DNS SRV records to find a list of remote hosts for the XMPP domain (as implemented by\n * {@link DNSUtil#resolveXMPPDomain(String, int)}. It then iteratively tries to create a socket connection to each\n * of them, until one socket connection succeeds.\n *\n * Either the connected Socket instance is returned, or null if no connection could be established.\n *\n * Note that this method blocks while performing network IO. The timeout as defined by\n * {@link RemoteServerManager#getSocketTimeout()} is observed.\n *\n * @param xmppDomain The XMPP domain to connect to.\n * @param port The port to connect to when DNS resolution fails.\n * @return a Socket instance that is connected, or null.\n * @see DNSUtil#resolveXMPPDomain(String, int)\n */\npublic static Map.Entry<Socket, Boolean> createSocketToXmppDomain(String xmppDomain, int port) {",
        "pred_variables": [
            "port"
        ],
        "label_variables": [
            "xmppDomain"
        ]
    },
    {
        "code": "@Override\npublic ReadOnlyDatabases.Lookup lookupReadOnlyDatabases() {\n    var previous = previousLookup;\n    var next = previous;\n    try {\n        next = systemDatabase().map(this::lookupReadOnlyDatabases).map(dbs -> new SystemGraphLookup(dbs, false)).orElse(previous);\n    } catch (Exception e) {",
        "pred_variables": [
            "var"
        ],
        "label_variables": [
            "previous"
        ]
    },
    {
        "code": "private void registerPubsubEnvironment(GenericContainer<?> container, ConfigurableEnvironment environment, PubsubProperties properties) {\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.google.pubsub.port\", container.getMappedPort(properties.getPort()));\n    map.put(\"embedded.google.pubsub.host\", container.getHost());\n    map.put(\"embedded.google.pubsub.project-id\", properties.getProjectId());",
        "pred_variables": [
            "properties",
            "container"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "@Override\npublic void removeListener(String listenerId) {",
        "pred_variables": [
            "listenerId"
        ],
        "label_variables": [
            "listenerId"
        ]
    },
    {
        "code": "@CheckForNull\npublic Language language(InputFile inputFile) {\n    Language detectedLanguage = null;\n    for (Entry<Language, String[]> languagePatterns : extensionsByLanguage.entrySet()) {\n        if (isCandidateForLanguage(inputFile, languagePatterns.getValue())) {\n            if (detectedLanguage == null) {\n                detectedLanguage = languagePatterns.getKey();\n            } else {\n                // Language was already forced by another pattern\n                throw MessageException.of(MessageFormat.format(\"Language of file ''{0}'' can not be decided as the file extension matches both {1} and {2}\", inputFile.uri(), getDetails(detectedLanguage), getDetails(languagePatterns.getKey())));\n            }\n        }\n    }\n    if (detectedLanguage != null) {",
        "pred_variables": [
            "inputFile",
            "detectedLanguage",
            "getDetails",
            "getKey",
            "Language",
            "extensionsByLanguage",
            "languagePatterns"
        ],
        "label_variables": [
            "detectedLanguage"
        ]
    },
    {
        "code": "@Override\npublic void visitUTF8(String name, long id, CharSequence target) {\n    boolean found = StageTester.hasBadChar(target);\n    if (found) {",
        "pred_variables": [
            "id",
            "name",
            "target"
        ],
        "label_variables": [
            "name",
            "id"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"google.pubsub\")\nToxiproxyContainer.ContainerProxy googlePubSubContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(BEAN_NAME_EMBEDDED_GOOGLE_PUBSUB) GenericContainer<?> pubsub, PubsubProperties properties, ConfigurableEnvironment environment) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(pubsub, properties.getPort());\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.google.pubsub.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.google.pubsub.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.google.pubsub.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedGooglePubSubToxiproxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [
            "propertySource"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "private void checkArm(WebDriverManager wdm) {\n    wdm.avoidBrowserDetection().mac().arch64().setup();\n    String driverPath = wdm.getDownloadedDriverPath();",
        "pred_variables": [
            "setup",
            "wdm"
        ],
        "label_variables": [
            "driverPath"
        ]
    },
    {
        "code": "// doc comment inherited from LogWriter\npublic void logReceivedCommand(Logger log, Object command) {",
        "pred_variables": [
            "command"
        ],
        "label_variables": [
            "command"
        ]
    },
    {
        "code": "private void registerEnvironment(GenericContainer<?> container, ConfigurableEnvironment environment, MinioProperties properties) {\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.minio.host\", container.getHost());\n    map.put(\"embedded.minio.port\", container.getMappedPort(properties.port));\n    map.put(\"embedded.minio.consolePort\", container.getMappedPort(properties.consolePort));\n    map.put(\"embedded.minio.accessKey\", properties.accessKey);\n    map.put(\"embedded.minio.secretKey\", properties.secretKey);\n    map.put(\"embedded.minio.region\", properties.region);",
        "pred_variables": [
            "region",
            "minio",
            "properties",
            "container"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "private StandaloneDatabaseContext createDatabase(NamedDatabaseId namedDatabaseId) {",
        "pred_variables": [
            "namedDatabaseId"
        ],
        "label_variables": [
            "namedDatabaseId"
        ]
    },
    {
        "code": "public synchronized boolean start() {\n    // We only need to start if there are patterns and we don't already have a proxy\n    if (targetName == null) {\n        return true;\n    }\n    // assure the gbean is running\n    AbstractName abstractName = getGBeanInstance().getAbstractName();\n    if (!isRunning(getKernel(), targetName)) {",
        "pred_variables": [
            "getGBeanInstance",
            "targetName",
            "getAbstractName",
            "gbean",
            "isRunning"
        ],
        "label_variables": [
            "abstractName"
        ]
    },
    {
        "code": "    // Get CSV from Yahoo\n    log.info(\"Sending request: \" + url);\n    URL request = new URL(url);\n    RedirectableRequest redirectableRequest = new RedirectableRequest(request, 5);\n    redirectableRequest.setConnectTimeout(YahooFinance.CONNECTION_TIMEOUT);\n    redirectableRequest.setReadTimeout(YahooFinance.CONNECTION_TIMEOUT);\n    Map<String, String> requestProperties = new HashMap<String, String>();\n    requestProperties.put(\"Cookie\", CrumbManager.getCookie());\n    URLConnection connection = redirectableRequest.openConnection(requestProperties);\n    InputStreamReader is = new InputStreamReader(connection.getInputStream());\n    BufferedReader br = new BufferedReader(is);\n    // skip the first line\n    br.readLine();\n    // Parse CSV\n    for (String line = br.readLine(); line != null; line = br.readLine()) {",
        "pred_variables": [
            "line"
        ],
        "label_variables": [
            "line"
        ]
    },
    {
        "code": "public Optional<ServerApi> getServerApi(String connectionId) {\n    var params = connectionRepository.getEndpointParams(connectionId);\n    if (params.isEmpty()) {",
        "pred_variables": [
            "connectionRepository",
            "String",
            "connectionId",
            "var"
        ],
        "label_variables": [
            "connectionId"
        ]
    },
    {
        "code": "private void enableCasForSubPaths(List<String> subPaths, VaultContainer vault) {\n    for (String subPath : subPaths) {\n        if (!subPath.isEmpty()) {",
        "pred_variables": [
            "subPath"
        ],
        "label_variables": [
            "subPath"
        ]
    },
    {
        "code": "public Subscription createSubscription(String topicName, String subscriptionName, DeadLetter deadLetter) {\n    ProjectTopicName topic = ProjectTopicName.of(projectId, topicName);\n    ProjectSubscriptionName subscription = ProjectSubscriptionName.of(projectId, subscriptionName);\n    try {",
        "pred_variables": [
            "topic",
            "projectId",
            "topicName"
        ],
        "label_variables": [
            "subscription"
        ]
    },
    {
        "code": "/**\n * Return hostname for URL.\n *\n * @param url\n *            URL\n * @return Hostname from that URL\n */\n@Override\nprotected String getHostname(String url) {",
        "pred_variables": [
            "url",
            "hostname"
        ],
        "label_variables": [
            "url"
        ]
    },
    {
        "code": "public void onError(Throwable throwable) {",
        "pred_variables": [
            "throwable"
        ],
        "label_variables": [
            "throwable"
        ]
    },
    {
        "code": "static void assertNotMigrated(Path path, FileSystemAbstraction fileSystem, InternalLog log) {\n    Path migratedFile = getMigratedFile(path);\n    if (fileSystem.fileExists(migratedFile)) {\n        String message = \"The repository file '\" + path.toAbsolutePath() + \"' has been marked as migrated. \" + \"If you are sure that you want use this repository you need to manually rename the file '\" + migratedFile.toAbsolutePath() + \"' to '\" + path.getFileName() + \"'\";",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "@Override\npublic List<String> groupsFromRoles(List<String> roles) {\n    if (template == null || roles == null) {\n        return roles;\n    } else {\n        List<String> renamedRoles = new ArrayList<>();\n        for (String role : roles) {\n            String renamedRole = template.replace(ROLE_MAPPING_PLACEHOLDER, role);\n            renamedRoles.add(renamedRole);",
        "pred_variables": [],
        "label_variables": [
            "role",
            "renamedRole"
        ]
    },
    {
        "code": "public void createTopics(Collection<String> topics, Collection<TopicConfiguration> topicsConfiguration) {\n    Map<String, TopicConfiguration> defaultTopicToTopicConfigurationMap = topics.stream().collect(toMap(topic -> topic, topic -> new TopicConfiguration(topic, DEFAULT_PARTITION_COUNT)));\n    Map<String, TopicConfiguration> topicToTopicConfigurationMap = topicsConfiguration.stream().collect(toMap(TopicConfiguration::getTopic, topicConfiguration -> topicConfiguration));\n    defaultTopicToTopicConfigurationMap.putAll(topicToTopicConfigurationMap);\n    Collection<TopicConfiguration> topicsConfigurationToCreate = defaultTopicToTopicConfigurationMap.values();\n    if (!topicsConfigurationToCreate.isEmpty()) {",
        "pred_variables": [
            "TopicConfiguration"
        ],
        "label_variables": [
            "topicsConfigurationToCreate"
        ]
    },
    {
        "code": " *            Output buffer\n * @param in\n *            Input buffer\n * @param numBytesMax\n *            Number of bytes max\n * @return int Number of bytes written\n */\npublic final static int put(IoBuffer out, IoBuffer in, int numBytesMax) {\n    if (log.isTraceEnabled()) {\n        log.trace(\"Put\\nin buffer: {}\\nout buffer: {}\\nmax bytes: {}\", new Object[] { out, in, numBytesMax });\n    }\n    int numBytesRead = 0;\n    if (in != null) {\n        int limit = Math.min(in.limit(), numBytesMax);\n        byte[] inBuf = new byte[limit];",
        "pred_variables": [
            "numBytesRead",
            "inBuf"
        ],
        "label_variables": [
            "limit"
        ]
    },
    {
        "code": "private void traceOrDebug(boolean traceOn, String msg) {\n    if (traceOn) {\n        trace.info(msg);\n    }\n    if (log.isDebugEnabled()) {",
        "pred_variables": [
            "msg"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "private void save(Settings settings, Path settingsPath) {\n    assert settings != null : \"method should only be invoked by #scheduleSave, which checks for null\";",
        "pred_variables": [
            "settingsPath",
            "settings"
        ],
        "label_variables": [
            "settingsPath"
        ]
    },
    {
        "code": "private void registerVaultEnvironment(VaultContainer vault, ConfigurableEnvironment environment, VaultProperties properties) {\n    Integer mappedPort = vault.getMappedPort(properties.getPort());\n    String host = vault.getHost();\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.vault.host\", host);\n    map.put(\"embedded.vault.port\", mappedPort);\n    map.put(\"embedded.vault.token\", properties.getToken());",
        "pred_variables": [
            "vault",
            "port",
            "LinkedHashMap",
            "properties"
        ],
        "label_variables": [
            "mappedPort",
            "host",
            "map"
        ]
    },
    {
        "code": "private void sendWithReplyToTemp(ConnectionFactory cf, String serviceQueue) throws JMSException, InterruptedException {\n    Connection con = cf.createConnection();\n    con.start();\n    Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);\n    TemporaryQueue tempQueue = session.createTemporaryQueue();\n    TextMessage msg = session.createTextMessage(\"Request\");\n    msg.setJMSReplyTo(tempQueue);\n    MessageProducer producer = session.createProducer(session.createQueue(serviceQueue));\n    producer.send(msg);\n    // This sleep also seems to matter\n    Thread.sleep(3000);\n    MessageConsumer consumer = session.createConsumer(tempQueue);\n    Message replyMsg = consumer.receive();",
        "pred_variables": [
            "replyMsg"
        ],
        "label_variables": [
            "replyMsg"
        ]
    },
    {
        "code": "private void registerPostgresqlEnvironment(PostgreSQLContainer postgresql, ConfigurableEnvironment environment, PostgreSQLProperties properties) {\n    Integer mappedPort = postgresql.getMappedPort(PostgreSQLContainer.POSTGRESQL_PORT);\n    String host = postgresql.getHost();\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.postgresql.port\", mappedPort);\n    map.put(\"embedded.postgresql.host\", host);\n    map.put(\"embedded.postgresql.schema\", properties.getDatabase());\n    map.put(\"embedded.postgresql.user\", properties.getUser());\n    map.put(\"embedded.postgresql.password\", properties.getPassword());\n    String jdbcURL = \"jdbc:postgresql://{}:{}/{}\";",
        "pred_variables": [
            "properties"
        ],
        "label_variables": [
            "mappedPort",
            "host",
            "map"
        ]
    },
    {
        "code": "@BeforeSuite\npublic void setupEnv() throws IOException {\n    Process process;\n    String line;\n    String[] setup = { \"sh\", \"..\" + File.separator + \"src\" + File.separator + \"test\" + File.separator + \"java\" + File.separator + \"EnvSetup.sh\" };\n    process = Runtime.getRuntime().exec(setup);\n    try (BufferedReader bufferedreader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {\n        while ((line = bufferedreader.readLine()) != null) {",
        "pred_variables": [
            "setup",
            "line",
            "separator"
        ],
        "label_variables": [
            "line"
        ]
    },
    {
        "code": "private boolean validateSigninEndpointAddress(Application serviceConfig, String endpointAddress) {\n    if (serviceConfig.getPassiveRequestorEndpoint() == null && serviceConfig.getCompiledPassiveRequestorEndpointConstraint() == null) {\n        LOG.error(\"Either the 'passiveRequestorEndpoint' or the 'passiveRequestorEndpointConstraint' \" + \"configuration values must be specified for the application\");\n    } else if (serviceConfig.getPassiveRequestorEndpoint() != null && serviceConfig.getPassiveRequestorEndpoint().equals(endpointAddress)) {",
        "pred_variables": [
            "endpointAddress",
            "serviceConfig"
        ],
        "label_variables": [
            "endpointAddress"
        ]
    },
    {
        "code": "    long startTime = Long.parseLong(System.getProperty(START_TIME));\n    double startupTime = (System.currentTimeMillis() - startTime) / 1000.0;\n    try {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Server           :  \" + dataHolder.getCarbonServerConfigurationService().getFirstProperty(\"Name\") + \"-\" + dataHolder.getCarbonServerConfigurationService().getFirstProperty(\"Version\"));\n        }\n    } catch (Exception e) {\n        log.debug(\"Error while retrieving server configuration\", e);\n    }\n    try {\n        ServerStatus.setServerRunning();\n    } catch (AxisFault e) {\n        String msg = \"Cannot set server to running mode\";\n        log.error(msg, e);\n    }",
        "pred_variables": [
            "msg"
        ],
        "label_variables": [
            "startupTime"
        ]
    },
    {
        "code": "    JsonObject delegateObject = new JsonObject(configString);\n    // methods of the delegate\n    Set<HttpMethod> methods = new HashSet<>();\n    delegateObject.getJsonArray(METHODS).forEach(method -> methods.add(HttpMethod.valueOf((String) method)));\n    // pattern of the delegate\n    Pattern pattern;\n    try {\n        pattern = Pattern.compile(delegateObject.getString(PATTERN));\n    } catch (Exception e) {\n        throw new ValidationException(\"Could not parse pattern [\" + delegateObject.getString(PATTERN) + \"] of delegate \" + delegateName, e);\n    }\n    // requests of the delegate\n    List<DelegateRequest> requests = new ArrayList<>();\n    for (int i = 0; i < delegateObject.getJsonArray(REQUESTS).size(); i++) {\n        if (LOG.isTraceEnabled()) {",
        "pred_variables": [
            "delegate"
        ],
        "label_variables": [
            "delegateName",
            "i"
        ]
    },
    {
        "code": "/**\n * \u666e\u901a\u8d26\u6237\u7684\u7b7e\u540d\n */\n@Override\npublic boolean signInputs(Transaction tx, ECKey key) {\n    int numInputs = tx.getInputs().size();\n    for (int i = 0; i < numInputs; i++) {\n        TransactionInput txIn = (TransactionInput) tx.getInput(i);\n        if (txIn.getFroms() == null || txIn.getFroms().size() == 0) {",
        "pred_variables": [
            "i",
            "getInputs",
            "numInputs"
        ],
        "label_variables": [
            "i"
        ]
    },
    {
        "code": "@Override\npublic void onWSConnect(WebSocketConnection conn) {",
        "pred_variables": [
            "conn"
        ],
        "label_variables": [
            "conn"
        ]
    },
    {
        "code": "@Override\npublic void exec(int executionCounter) {\n    List<String> args = RedisUtils.toPayload(luaScriptState.getSha(), keys.size(), keys, arguments);\n    redisAPI.evalsha(args, event -> {\n        if (event.succeeded()) {\n            promise.complete(event.result().toLong());\n        } else {\n            String message = event.cause().getMessage();\n            if (message != null && message.startsWith(\"NOSCRIPT\")) {\n                log.warn(\"HalfOpenCircuitRedisCommand script couldn't be found, reload it\");",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "executionCounter"
        ]
    },
    {
        "code": "/**\n * output the result of stack trace capture to the log\n */\npublic static void result() {\n    synchronized (trackers) {\n        for (Entry<String, Tracker> t : trackers.entrySet()) {\n            LOG.info(\"Tracker: \" + t.getKey() + \", \" + t.getValue().size() + \" entry points...\");\n            for (Trace trace : t.getValue().values()) {",
        "pred_variables": [
            "trace"
        ],
        "label_variables": [
            "trace"
        ]
    },
    {
        "code": "@Override\npublic MessageProcessResult process(Message message, Peer peer) {\n    if (log.isDebugEnabled()) {",
        "pred_variables": [
            "message",
            "peer"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "private void executeExternalManipulateScope(CustomScriptConfiguration scriptConfiguration, SpontaneousScopeExternalContext context) {\n    try {",
        "pred_variables": [
            "scriptConfiguration"
        ],
        "label_variables": [
            "context"
        ]
    },
    {
        "code": "    destination = createDestination();\n    MessageProducer producer = session.createProducer(destination);\n    producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);\n    for (int i = 0; i < 60; i++) {\n        BytesMessage message = session.createBytesMessage();\n        message.writeBytes(new byte[1024 * 1024]);\n        producer.send(message);\n    }\n    Thread.sleep(1000);\n    String objectNameStr = broker.getBrokerObjectName().toString();\n    objectNameStr += \",service=Health\";\n    ObjectName brokerName = assertRegisteredObjectName(objectNameStr);\n    HealthViewMBean health = MBeanServerInvocationHandler.newProxyInstance(mbeanServer, brokerName, HealthViewMBean.class, true);\n    List<HealthStatus> list = health.healthList();\n    for (HealthStatus status : list) {",
        "pred_variables": [
            "status"
        ],
        "label_variables": [
            "status"
        ]
    },
    {
        "code": "private static ProjectBranches synchronizeProjectBranches(ServerApi serverApi, String projectKey) {",
        "pred_variables": [
            "projectKey",
            "serverApi"
        ],
        "label_variables": [
            "projectKey"
        ]
    },
    {
        "code": "public SecurityToken mapSignInResponse(RequestContext requestContext, String trustedIdpRealm) {",
        "pred_variables": [
            "trustedIdpRealm",
            "requestContext"
        ],
        "label_variables": [
            "trustedIdpRealm"
        ]
    },
    {
        "code": "                    LOG.debug(\"Latch count down called.\");\n                }\n            }\n        }.start();\n    }\n    // Wait for all the clients to finish\n    LOG.info(\"Waiting for latch...\");\n    done.await();\n    LOG.info(\"Latch complete.\");\n    LOG.info(\"FD count: \" + openFileDescriptorCount());\n    assertTrue(\"Too many open file descriptors: \" + openFileDescriptorCount(), Wait.waitFor(new Wait.Condition() {\n\n        @Override\n        public boolean isSatisified() throws Exception {\n            long openFDs = openFileDescriptorCount();",
        "pred_variables": [
            "openFDs"
        ],
        "label_variables": [
            "original",
            "openFDs"
        ]
    },
    {
        "code": "public ReportConfigurationBean getSavedReport(String reportName) throws Exception {\n    try {\n        return reportingAdminServiceStub.getSavedReport(reportName);\n    } catch (Exception e) {\n        String msg = \"Unable get saved report\";",
        "pred_variables": [
            "msg"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "@Override\npublic void connectionLost(SocketAddress sa) {\n    String msg = \"lost memcached connection [\" + sa + \"] reconnecting...\";",
        "pred_variables": [
            "msg",
            "connection"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "@Test(timeout = 60000)\npublic void testForConnectionLeak() throws Exception {\n    Integer expectedConnectionCount = 0;\n    for (int i = 0; i < ITERATIONS; i++) {\n        try {\n            if (i % 2 == 0) {",
        "pred_variables": [
            "i"
        ],
        "label_variables": [
            "i"
        ]
    },
    {
        "code": "private SessionId getLdapSessionId(String sessionId) {\n    if (StringHelper.isEmpty(sessionId)) {\n        return null;\n    }\n    SessionId ldapSessionId = sessionIdService.getSessionId(sessionId);\n    if (ldapSessionId == null) {",
        "pred_variables": [
            "getSessionId",
            "sessionId"
        ],
        "label_variables": [
            "sessionId"
        ]
    },
    {
        "code": "public void error(SAXParseException exception) {",
        "pred_variables": [
            "exception"
        ],
        "label_variables": [
            "exception"
        ]
    },
    {
        "code": "@Override\npublic void deleteEntitlement(String name) {\n    Query query = em.createQuery(\"select e from Entitlement e where e.name=:name\");\n    query.setParameter(\"name\", name);\n    Object entitlementObj = query.getSingleResult();\n    em.remove(entitlementObj);",
        "pred_variables": [
            "name",
            "e",
            "query"
        ],
        "label_variables": [
            "name"
        ]
    },
    {
        "code": "public Map<UmaScriptByScope, UmaAuthorizationContext> checkNeedsInfo(Claims claims, Map<Scope, Boolean> requestedScopes, List<UmaPermission> permissions, UmaPCT pct, HttpServletRequest httpRequest, Client client) {\n    Map<UmaScriptByScope, UmaAuthorizationContext> scriptMap = new HashMap<UmaScriptByScope, UmaAuthorizationContext>();\n    Map<String, String> ticketAttributes = new HashMap<String, String>();\n    List<ClaimDefinition> missedClaims = new ArrayList<ClaimDefinition>();\n    UmaAuthorizationContextBuilder contextBuilder = new UmaAuthorizationContextBuilder(appConfiguration, attributeService, resourceService, permissions, requestedScopes, claims, httpRequest, sessionService, userService, permissionService, client);\n    for (Scope scope : requestedScopes.keySet()) {\n        List<String> authorizationPolicies = scope.getUmaAuthorizationPolicies();\n        if (authorizationPolicies != null && !authorizationPolicies.isEmpty()) {\n            for (String scriptDN : authorizationPolicies) {",
        "pred_variables": [
            "List"
        ],
        "label_variables": [
            "scriptDN"
        ]
    },
    {
        "code": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\npublic static boolean registerNewMBean(Class clazz, Class interfaceClass) {\n    boolean status = false;\n    try {\n        String cName = clazz.getName();\n        if (cName.indexOf('.') != -1) {\n            cName = cName.substring(cName.lastIndexOf('.')).replaceFirst(\"[\\\\.]\", \"\");\n        }",
        "pred_variables": [
            "interfaceClass",
            "lastIndexOf",
            "cName",
            "getName",
            "replaceFirst",
            "clazz"
        ],
        "label_variables": [
            "cName"
        ]
    },
    {
        "code": "@ParameterizedTest\n@ValueSource(classes = { ChromeDriver.class, EdgeDriver.class })\nvoid testLatestAndBetaedgedriver(Class<? extends WebDriver> driverClass) {\n    WebDriverManager wdm = WebDriverManager.getInstance(driverClass).avoidResolutionCache().avoidBrowserDetection().win();\n    wdm.setup();\n    String edgedriverStable = wdm.getDownloadedDriverVersion();",
        "pred_variables": [
            "wdm",
            "driverClass",
            "avoidBrowserDetection"
        ],
        "label_variables": [
            "edgedriverStable"
        ]
    },
    {
        "code": "public Object get(String str) {\n    Object r = super.get(str);",
        "pred_variables": [
            "str",
            "r"
        ],
        "label_variables": [
            "str",
            "r"
        ]
    },
    {
        "code": "@Override\npublic void onStreamEvent(Notify notify) {",
        "pred_variables": [
            "notify"
        ],
        "label_variables": [
            "notify"
        ]
    },
    {
        "code": "@Override\npublic void failedToOpenIndex(IndexDescriptor descriptor, String action, Exception cause) {\n    if (log.isDebugEnabled()) {",
        "pred_variables": [
            "cause"
        ],
        "label_variables": [
            "cause"
        ]
    },
    {
        "code": "public void addConfiguration(Artifact configurationId) {",
        "pred_variables": [
            "configurationId"
        ],
        "label_variables": [
            "configurationId"
        ]
    },
    {
        "code": "    if (StringUtils.isEmpty(alias)) {\n        aliasId.requestFocus();\n        DailogUtil.showTipDailogCenter(\"\u522b\u540d\u4e0d\u80fd\u4e3a\u7a7a\", getThisStage());\n        return;\n    }\n    //\u4fee\u6539\u5bc6\u7801\u5e76\u5224\u65ad\u7ed3\u679c\n    AccountKit accountKit = InchainInstance.getInstance().getAccountKit();\n    Result result = accountKit.setAlias(alias);\n    if (result.isSuccess()) {\n        if (callback != null) {\n            callback.ok(null);\n        }\n        DailogUtil.showTipDailogCenter(result.getMessage(), getThisStage());\n        resetAndclose();\n    } else {",
        "pred_variables": [
            "\u522b\u540d\u4e0d\u80fd\u4e3a\u7a7a",
            "getInstance",
            "getThisStage"
        ],
        "label_variables": [
            "result"
        ]
    },
    {
        "code": "public static String resolve(String url, HttpServletRequest request) {\n    if (request == null) {\n        return url;\n    }\n    if (isLocal(url)) {\n        try {\n            URL urlValue = new URL(url);\n            URL updatedUrl = new URL(urlValue.getProtocol(), urlValue.getHost(), request.getLocalPort(), urlValue.getFile());\n            LOG.debug(\"URL updated to {}\", updatedUrl.toString());\n            return updatedUrl.toString();\n        } catch (MalformedURLException e) {",
        "pred_variables": [
            "url"
        ],
        "label_variables": [
            "url"
        ]
    },
    {
        "code": "@Override\npublic void visitTemplateClose(String name, long id) {\n    tab--;",
        "pred_variables": [
            "id",
            "name"
        ],
        "label_variables": [
            "name"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"db2\")\nToxiproxyContainer.ContainerProxy db2ContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(BEAN_NAME_EMBEDDED_DB2) Db2Container db2, ConfigurableEnvironment environment) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(db2, Db2Container.DB2_PORT);\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.db2.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.db2.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.db2.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedDb2ToxiproxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [
            "ToxiproxyContainer"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "@Override\npublic void error(String s, Throwable throwable) {",
        "pred_variables": [
            "s",
            "throwable"
        ],
        "label_variables": [
            "s",
            "throwable"
        ]
    },
    {
        "code": "public boolean isValidSignoutAddress(RequestContext context, String endpointAddress, String realm) throws Exception {\n    if (endpointAddress == null) {\n        return true;\n    }\n    Idp idpConfig = (Idp) WebUtils.getAttributeFromFlowScope(context, \"idpConfig\");\n    if (idpConfig.isDisableLogoutAddressValidation()) {\n        return true;\n    }\n    Application serviceConfig = idpConfig.findApplication(realm);\n    if (serviceConfig == null) {",
        "pred_variables": [
            "getAttributeFromFlowScope",
            "realm",
            "Idp",
            "endpointAddress",
            "serviceConfig"
        ],
        "label_variables": [
            "realm"
        ]
    },
    {
        "code": "void exercise(WebDriver driver, String sutUrl, String expectedTitleContains) throws Exception {\n    driver.get(sutUrl);\n    Wait<WebDriver> wait = new WebDriverWait(driver, Duration.ofSeconds(30));\n    wait.until(d -> d.getTitle().contains(expectedTitleContains));\n    URL dockerSessionUrl = wdm.getDockerNoVncUrl(driver);",
        "pred_variables": [
            "wdm",
            "expectedTitleContains"
        ],
        "label_variables": [
            "dockerSessionUrl"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"aerospike\")\nToxiproxyContainer.ContainerProxy aerospikeContainerProxy(ToxiproxyContainer toxiproxyContainer, GenericContainer<?> aerospike, AerospikeProperties properties, ConfigurableEnvironment environment) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(aerospike, properties.port);\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.aerospike.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.aerospike.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.aerospike.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedAerospikeToxiProxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [
            "module"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "@Override\nprotected Void processItem(List<PublishedPointVO> subgroup, int itemId) throws Exception {\n    long startTs = 0L;\n    if (log.isInfoEnabled()) {\n        startTs = Common.timer.currentTimeMillis();",
        "pred_variables": [
            "currentTimeMillis",
            "startTs"
        ],
        "label_variables": [
            "itemId"
        ]
    },
    {
        "code": "@Bean\n@ConditionalOnToxiProxyEnabled(module = \"keycloak\")\nToxiproxyContainer.ContainerProxy keycloakContainerProxy(ToxiproxyContainer toxiproxyContainer, @Qualifier(BEAN_NAME_EMBEDDED_KEYCLOAK) KeycloakContainer keycloakContainer, KeycloakProperties properties, ConfigurableEnvironment environment) {\n    ToxiproxyContainer.ContainerProxy proxy = toxiproxyContainer.getProxy(keycloakContainer, keycloakContainer.getHttpPort());\n    Map<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.keycloak.toxiproxy.host\", proxy.getContainerIpAddress());\n    map.put(\"embedded.keycloak.toxiproxy.port\", proxy.getProxyPort());\n    map.put(\"embedded.keycloak.toxiproxy.proxyName\", proxy.getName());\n    MapPropertySource propertySource = new MapPropertySource(\"embeddedKeycloakToxiproxyInfo\", map);\n    environment.getPropertySources().addFirst(propertySource);",
        "pred_variables": [],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "        // raw buffer handling\n        IoBuffer in = (IoBuffer) message;\n        // filter based on current connection state\n        RTMP rtmp = conn.getState();\n        final byte connectionState = conn.getStateCode();\n        log.trace(\"connectionState: {}\", RTMP.states[connectionState]);\n        // get the handshake\n        OutboundHandshake handshake = (OutboundHandshake) conn.getAttribute(RTMPConnection.RTMP_HANDSHAKE);\n        switch(connectionState) {\n            case RTMP.STATE_CONNECT:\n                log.debug(\"Handshake - client phase 1 - size: {}\", in.remaining());\n                // 0x01\n                in.get();\n                // usually 0x03 (rtmp)\n                byte handshakeType = in.get();",
        "pred_variables": [
            "handshakeType"
        ],
        "label_variables": [
            "handshakeType"
        ]
    },
    {
        "code": "private void handleException(String msg, Exception e, MessageContext msgContext) {",
        "pred_variables": [
            "msg",
            "e"
        ],
        "label_variables": [
            "msg",
            "e"
        ]
    },
    {
        "code": "@Override\npublic void print(String message) {",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "    requestBuffer.setInt(0, header.length()).appendBuffer(header);\n    int statusCode = StatusCode.OK.getStatusCode();\n    String statusMessage = StatusCode.OK.getStatusMessage();\n    /*\n         * We create a response for the client,\n         * but we discard the request and therefore\n         * do not forward it.\n         */\n    ctx.response().setStatusCode(statusCode);\n    ctx.response().setStatusMessage(statusMessage);\n    ctx.response().headers().add(\"Content-Length\", \"0\");\n    ctx.request().handler(buffer -> {\n        loggingHandler.appendRequestPayload(buffer, requestHeaders);\n        requestBuffer.appendBuffer(buffer);\n        MultiMap responseHeaders = ctx.response().headers();",
        "pred_variables": [
            "MultiMap",
            "loggingHandler"
        ],
        "label_variables": [
            "requestHeaders",
            "statusMessage",
            "statusCode"
        ]
    },
    {
        "code": "/**\n * Logs details about the request error.\n *\n * @param response\n *            http response\n * @throws IOException\n *             on IO error\n * @throws ParseException\n *             on parse error\n */\npublic static void handleError(HttpResponse response) throws ParseException, IOException {\n    log.debug(\"{}\", response.getStatusLine().toString());\n    HttpEntity entity = response.getEntity();\n    if (entity != null) {",
        "pred_variables": [
            "response",
            "getEntity",
            "entity"
        ],
        "label_variables": [
            "entity"
        ]
    },
    {
        "code": "private void toggleNodeOrientation(@SuppressWarnings(\"unused\") ObservableValue<? extends Toggle> observable, @SuppressWarnings(\"unused\") Toggle oldValue, Toggle newValue) {\n    if (nodeOrientationLtr.equals(newValue)) {\n        settings.userInterfaceOrientation().set(NodeOrientation.LEFT_TO_RIGHT);\n    } else if (nodeOrientationRtl.equals(newValue)) {\n        settings.userInterfaceOrientation().set(NodeOrientation.RIGHT_TO_LEFT);\n    } else {",
        "pred_variables": [
            "unused"
        ],
        "label_variables": [
            "newValue"
        ]
    },
    {
        "code": "    if (eventPublisherConfig == null) {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Newly creating publisher configuration.\");\n        }\n        synchronized (HL7EventPublisher.class) {\n            eventPublisherConfig = new EventPublisherConfig();\n            DataPublisher loadBalancingDataPublisher;\n            try {\n                if (serverConfig.getSecureUrl() != null) {\n                    loadBalancingDataPublisher = new DataPublisher(DataEndpointConstants.THRIFT_DATA_AGENT_TYPE, serverConfig.getUrl(), serverConfig.getSecureUrl(), serverConfig.getUsername(), serverConfig.getPassword());\n                } else {\n                    loadBalancingDataPublisher = new DataPublisher(serverConfig.getUrl(), serverConfig.getUsername(), serverConfig.getPassword());\n                }\n            } catch (DataEndpointAgentConfigurationException | DataEndpointException | DataEndpointConfigurationException | DataEndpointAuthenticationException | TransportException e) {\n                String errorMsg = \"Error occurred while creating data publisher\";",
        "pred_variables": [
            "Error",
            "occurred",
            "loadBalancingDataPublisher"
        ],
        "label_variables": [
            "errorMsg"
        ]
    },
    {
        "code": "public boolean getVersionMatches(String version) {\n    version = version.trim();\n    boolean result = false;\n    if (version.endsWith(\"*\")) {\n        version = version.substring(0, version.length() - 1).trim();",
        "pred_variables": [
            "endsWith",
            "result",
            "version"
        ],
        "label_variables": [
            "version"
        ]
    },
    {
        "code": "@Override\npublic void resourceChanged(String resourceUri, Buffer resource) {\n    if (configResourceUri() != null && configResourceUri().equals(resourceUri)) {",
        "pred_variables": [
            "resource",
            "resourceUri",
            "configResourceUri"
        ],
        "label_variables": [
            "resourceUri"
        ]
    },
    {
        "code": "@Override\n@SuppressWarnings(\"restriction\")\nprotected Provider getProvider() {\n    if (this.provider == null) {\n        /*\n             * The smartCardNameIndex int is added at the end of the smartCard name in order to enable the successive\n             * loading of multiple pkcs11 libraries\n             */\n        String aPKCS11LibraryFileName = this.getPkcs11Path();\n        aPKCS11LibraryFileName = this.escapePath(aPKCS11LibraryFileName);\n        final StringBuilder pkcs11Config = new StringBuilder();\n        pkcs11Config.append(\"name = SmartCard\").append(UUID.randomUUID().toString()).append(\"\\n\");\n        pkcs11Config.append(\"library = \\\"\").append(aPKCS11LibraryFileName).append(\"\\\"\").append(\"\\n\");\n        pkcs11Config.append(\"slotListIndex = \").append(this.getSlotListIndex());\n        final String configString = pkcs11Config.toString();",
        "pred_variables": [
            "provider"
        ],
        "label_variables": [
            "configString"
        ]
    },
    {
        "code": "@Override\npublic void onException(Message message, Exception exception) {",
        "pred_variables": [
            "message",
            "exception"
        ],
        "label_variables": [
            "exception"
        ]
    },
    {
        "code": "public void saveReport(ReportConfigurationBean configuration) throws Exception {\n    try {\n        reportingAdminServiceStub.saveReport(configuration);\n    } catch (Exception e) {\n        String msg = \"Unable to save report\";",
        "pred_variables": [
            "msg"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "    }\n    // do a few quick requests\n    for (int count = 0; count < 10; count++) {\n        delete(\"res\" + count);\n        given().body(\"{ \\\"name\\\" : \\\"test\" + count + \"\\\" }\").put(\"res\" + count).then().assertThat().statusCode(200);\n        get(\"res\" + count).then().assertThat().statusCode(200);\n    }\n    // do another 1000 requests\n    for (int count = 0; count < 1000; count++) {\n        given().body(\"{ \\\"name\\\" : \\\"test\" + count + \"\\\" }\").put(\"newres\" + count).then().assertThat().statusCode(200);\n    }\n    // wait a sec\n    TestUtils.waitSomeTime(1);\n    // read the jmx infos\n    if (mbs.isRegistered(beanNameObject)) {",
        "pred_variables": [
            "count"
        ],
        "label_variables": [
            "beanNameObject"
        ]
    },
    {
        "code": "protected void handleException(String msg, Exception e) {",
        "pred_variables": [
            "msg",
            "e"
        ],
        "label_variables": [
            "msg",
            "e"
        ]
    },
    {
        "code": "@Override\npublic void corruptedLogFile(long version, Throwable t) {",
        "pred_variables": [
            "t",
            "version"
        ],
        "label_variables": [
            "t",
            "version"
        ]
    },
    {
        "code": "private void restrictTopics(String username, Collection<String> topics) {\n    if (!topics.isEmpty()) {",
        "pred_variables": [
            "username"
        ],
        "label_variables": [
            "topics"
        ]
    },
    {
        "code": "@Override\npublic void encode(IoSession session, Object message, ProtocolEncoderOutput out) throws ProtocolCodecException {\n    if (log.isDebugEnabled()) {",
        "pred_variables": [
            "out"
        ],
        "label_variables": [
            "message",
            "out"
        ]
    },
    {
        "code": "public SonarLintInputFile create(ClientInputFile inputFile) {\n    var defaultInputFile = new SonarLintInputFile(inputFile, f -> {\n        LOG.debug(\"Initializing metadata of file {}\", f.uri());\n        var charset = f.charset();\n        InputStream stream;\n        try {\n            stream = f.inputStream();\n        } catch (IOException e) {\n            throw new IllegalStateException(\"Failed to open a stream on file: \" + f.uri(), e);\n        }\n        return fileMetadata.readMetadata(stream, charset != null ? charset : Charset.defaultCharset(), f.uri(), null);\n    });\n    defaultInputFile.setType(inputFile.isTest() ? Type.TEST : Type.MAIN);\n    var fileLanguage = inputFile.language();\n    if (fileLanguage != null) {",
        "pred_variables": [
            "language",
            "var",
            "f",
            "inputFile",
            "InputStream",
            "isTest"
        ],
        "label_variables": [
            "fileLanguage"
        ]
    },
    {
        "code": "private boolean checkValidity(String key, String value, Date expirationDate) {\n    long now = new Date().getTime();\n    long expirationTime = expirationDate != null ? expirationDate.getTime() : 0;\n    boolean isValid = value != null && expirationTime != 0 && expirationTime > now;\n    if (!isValid) {",
        "pred_variables": [
            "key",
            "isValid",
            "expirationTime"
        ],
        "label_variables": [
            "value",
            "key",
            "expirationDate"
        ]
    },
    {
        "code": "private void skipMessage(String prefix, MessageReference msgRef) {",
        "pred_variables": [
            "prefix"
        ],
        "label_variables": [
            "prefix"
        ]
    },
    {
        "code": "@Override\npublic void connectionEstablished(SocketAddress sa, int reconnectCount) {\n    String msg = \"successfully established a memcache connection to [\" + sa + \"]\";\n    if (reconnectCount > 1)\n        msg += \" after [\" + reconnectCount + \"] retries\";",
        "pred_variables": [
            "msg"
        ],
        "label_variables": [
            "msg"
        ]
    },
    {
        "code": "protected void logError(Object service, Throwable e) {\n    Logger log = LoggerFactory.getLogger(service.getClass());",
        "pred_variables": [
            "e"
        ],
        "label_variables": [
            "e"
        ]
    },
    {
        "code": "@Test\npublic void testConnectionFailures() throws Exception {\n    final CountDownLatch failed = new CountDownLatch(1);\n    Connection connection = pooledConnFact.createConnection();",
        "pred_variables": [
            "connection"
        ],
        "label_variables": [
            "connection"
        ]
    },
    {
        "code": "@Override\npublic void onMessage(Message message) {",
        "pred_variables": [
            "message"
        ],
        "label_variables": [
            "message"
        ]
    },
    {
        "code": "        selectors.add(actionSelector(action.value()));\n    }\n    selectors.add(topicSelector(topic));\n    selectors.add(activeSelector(applicationContext));\n    MessageFilter filter = new MessageFilter(selectors);\n    filter.setDiscardChannel(nullChannel);\n    initializeBean(filter);\n    List<MessageHandler> handlers = new ArrayList<>();\n    handlers.add(filter);\n    handlers.add(serviceActivator);\n    MessageHandlerChain chain = new MessageHandlerChain();\n    chain.setHandlers(handlers);\n    chain.setComponentName(componentName);\n    initializeBean(chain);\n    if (channel.subscribe(chain)) {",
        "pred_variables": [
            "handlers",
            "chain",
            "channel"
        ],
        "label_variables": [
            "topic",
            "componentName"
        ]
    },
    {
        "code": "/**\n * {@inheritDoc}\n */\npublic boolean canHandle(File file) {\n    boolean valid = false;\n    if (file.exists()) {\n        String absPath = file.getAbsolutePath().toLowerCase();\n        int dotIndex = absPath.lastIndexOf('.');\n        if (dotIndex > -1) {\n            String fileExt = absPath.substring(dotIndex);",
        "pred_variables": [
            "dotIndex",
            "file"
        ],
        "label_variables": [
            "absPath",
            "fileExt"
        ]
    },
    {
        "code": "@Test\npublic void testYouTubePublish() throws InterruptedException {\n    log.info(\"\\ntestYouTubePublish\");\n    String youtubeHost = \"a.rtmp.youtube.com\";\n    int youtubePort = 1935;\n    String youtubeApp = \"live2\";\n    //System.getProperty(\"youtube.streamname\");\n    final String youtubePublishName = \"dybx-y3ph-uqzx-30vx\";",
        "pred_variables": [
            "youtubePublishName"
        ],
        "label_variables": [
            "youtubePublishName"
        ]
    },
    {
        "code": "public void ioException(IOException e) {\n    if (LOG.isDebugEnabled())",
        "pred_variables": [
            "e"
        ],
        "label_variables": [
            "e"
        ]
    },
    {
        "code": "private void registerEnvironment(GenericContainer<?> artifactory, ConfigurableEnvironment environment, ArtifactoryProperties properties) {\n    Integer mappedPort = artifactory.getMappedPort(properties.generalPort);\n    String host = artifactory.getHost();\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.artifactory.host\", host);\n    map.put(\"embedded.artifactory.port\", mappedPort);\n    map.put(\"embedded.artifactory.username\", properties.getUsername());\n    map.put(\"embedded.artifactory.password\", properties.getPassword());",
        "pred_variables": [
            "getHost",
            "mappedPort",
            "String",
            "properties"
        ],
        "label_variables": [
            "map"
        ]
    },
    {
        "code": "@Override\npublic void removeRoute(String urlPattern) {",
        "pred_variables": [
            "urlPattern"
        ],
        "label_variables": [
            "urlPattern"
        ]
    },
    {
        "code": "public Response gatherClaims(String clientId, String ticket, String claimRedirectUri, String state, Boolean reset, Boolean authenticationRedirect, HttpServletRequest httpRequest, HttpServletResponse httpResponse) {\n    try {",
        "pred_variables": [
            "clientId",
            "claimRedirectUri"
        ],
        "label_variables": [
            "clientId",
            "ticket",
            "authenticationRedirect",
            "claimRedirectUri",
            "state"
        ]
    },
    {
        "code": "@Override\npublic ByteBuffer targetBytes(String name, long id, int length) {",
        "pred_variables": [
            "id",
            "name"
        ],
        "label_variables": [
            "name"
        ]
    },
    {
        "code": "public void unloading(Artifact configurationId) {",
        "pred_variables": [
            "configurationId"
        ],
        "label_variables": [
            "configurationId"
        ]
    },
    {
        "code": "public void abortConnection(ObjectName consumerToAbort) {\n    Subscription sub = broker.getSubscriber(consumerToAbort);\n    if (sub != null) {\n        LOG.info(\"aborting consumer connection via jmx: {}\", sub.getConsumerInfo().getConsumerId().getConnectionId());\n        strategy.abortConsumer(sub, true);\n    } else {",
        "pred_variables": [
            "consumerToAbort"
        ],
        "label_variables": [
            "consumerToAbort"
        ]
    },
    {
        "code": "public void starting(Artifact configurationId) {",
        "pred_variables": [
            "configurationId"
        ],
        "label_variables": [
            "configurationId"
        ]
    },
    {
        "code": "@Test\nvoid testCachePathStartsWithTilde() {\n    String customPath = \"~webdrivers\";\n    wdm.config().setCachePath(customPath);\n    String cachePath = wdm.config().getCachePath();",
        "pred_variables": [
            "wdm",
            "customPath"
        ],
        "label_variables": [
            "customPath",
            "cachePath"
        ]
    },
    {
        "code": "public void onFailure(IOException e) {\n    if (!shuttingDown.get()) {",
        "pred_variables": [
            "e"
        ],
        "label_variables": [
            "e"
        ]
    },
    {
        "code": "@ParameterizedTest\n@MethodSource(\"data\")\nvoid testCli(String browser, String driver) {",
        "pred_variables": [
            "data",
            "browser"
        ],
        "label_variables": [
            "browser"
        ]
    },
    {
        "code": " * @throws ServletException\n */\n@SuppressWarnings(\"deprecation\")\n@Override\npublic void start() throws ServletException {\n    log.info(\"Loading RTMPS context\");\n    rtmpsEngine = new StandardEngine();\n    rtmpsEngine.setName(\"red5RTMPSEngine\");\n    rtmpsEngine.setDefaultHost(host.getName());\n    rtmpsEngine.setRealm(embedded.getEngine().getRealm());\n    Service service = new StandardService();\n    service.setName(\"red5RTMPSEngine\");\n    service.setContainer(rtmpsEngine);\n    // add the valves to the host\n    for (Valve valve : valves) {",
        "pred_variables": [
            "service"
        ],
        "label_variables": [
            "valve"
        ]
    },
    {
        "code": "public void loading(Artifact configurationId) {",
        "pred_variables": [
            "configurationId"
        ],
        "label_variables": [
            "configurationId"
        ]
    },
    {
        "code": "private void assertIEDriver() {\n    File driver = new File(wdm.getDownloadedDriverPath());",
        "pred_variables": [
            "driver"
        ],
        "label_variables": [
            "driver"
        ]
    },
    {
        "code": "private void registerMSSQLServerEnvironment(MSSQLServerContainer<?> mssqlServerContainer, ConfigurableEnvironment environment, MSSQLServerProperties properties) {\n    Integer mappedPort = mssqlServerContainer.getMappedPort(MSSQLServerContainer.MS_SQL_SERVER_PORT);\n    String host = mssqlServerContainer.getHost();\n    LinkedHashMap<String, Object> map = new LinkedHashMap<>();\n    map.put(\"embedded.mssqlserver.port\", mappedPort);\n    map.put(\"embedded.mssqlserver.host\", host);\n    // Database and user cannot be chosen when starting the MSSQL image\n    map.put(\"embedded.mssqlserver.database\", \"master\");\n    map.put(\"embedded.mssqlserver.user\", \"sa\");\n    map.put(\"embedded.mssqlserver.password\", properties.getPassword());\n    String jdbcURL = \"jdbc:sqlserver://{}:{};databaseName={};trustServerCertificate=true\";",
        "pred_variables": [
            "MS_SQL_SERVER_PORT",
            "mssqlserver"
        ],
        "label_variables": [
            "mappedPort",
            "host",
            "map"
        ]
    },
    {
        "code": "@Test(groups = \"wso2.esb\", description = \"Tests System Logs\")\npublic void testSystemLogs() throws Exception {\n    CarbonLogReader carbonLogReader = new CarbonLogReader();\n    carbonLogReader.start();\n    OMElement response = axis2Client.sendSimpleStockQuoteRequest(getProxyServiceURLHttp(\"logMediatorLevelTestProxy\"), null, \"WSO2\");\n    Assert.assertTrue(response.toString().contains(\"WSO2\"));",
        "pred_variables": [
            "carbonLogReader",
            "Assert"
        ],
        "label_variables": [
            "response"
        ]
    },
    {
        "code": "public void slf4j(Logger log, DataClass tainted, String tainted2) {\n    String safe = \"\";\n    //Unsafe\n    log.info(tainted.input);",
        "pred_variables": [
            "tainted"
        ],
        "label_variables": [
            "safe"
        ]
    },
    {
        "code": "@Override\npublic void info(String s, Throwable throwable) {",
        "pred_variables": [
            "s",
            "throwable"
        ],
        "label_variables": [
            "s",
            "throwable"
        ]
    },
    {
        "code": "public void input(byte[] buf, int len) {\n    if (LOG.isDebugEnabled())",
        "pred_variables": [
            "len"
        ],
        "label_variables": [
            "buf",
            "len"
        ]
    },
    {
        "code": "@Override\nprotected ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {",
        "pred_variables": [
            "ex"
        ],
        "label_variables": [
            "ex"
        ]
    },
    {
        "code": "    // Get CSV from Yahoo\n    log.info(\"Sending request: \" + url);\n    URL request = new URL(url);\n    RedirectableRequest redirectableRequest = new RedirectableRequest(request, 5);\n    redirectableRequest.setConnectTimeout(YahooFinance.CONNECTION_TIMEOUT);\n    redirectableRequest.setReadTimeout(YahooFinance.CONNECTION_TIMEOUT);\n    Map<String, String> requestProperties = new HashMap<String, String>();\n    requestProperties.put(\"Cookie\", CrumbManager.getCookie());\n    URLConnection connection = redirectableRequest.openConnection(requestProperties);\n    InputStreamReader is = new InputStreamReader(connection.getInputStream());\n    BufferedReader br = new BufferedReader(is);\n    // skip the first line\n    br.readLine();\n    // Parse CSV\n    for (String line = br.readLine(); line != null; line = br.readLine()) {",
        "pred_variables": [
            "line"
        ],
        "label_variables": [
            "line"
        ]
    },
    {
        "code": "@Test\npublic void testFLVReaderFileWithPreProcessInfo() {\n    log.info(\"\\n testFLVReaderFileWithPreProcessInfo\");\n    //Path path = Paths.get(\"target/test-classes/fixtures/flv1_nelly.flv\");\n    Path path = Paths.get(\"target/test-classes/fixtures/webrtctestrecord.flv\");\n    try {\n        File file = path.toFile();\n        log.info(\"Reading: {}\", file.getName());\n        FLVReader reader = new FLVReader(file, true);\n        //KeyFrameMeta meta = reader.analyzeKeyFrames();\n        //log.debug(\"Meta: {}\", meta);\n        ITag tag = null;\n        for (int t = 0; t < 6; t++) {\n            tag = reader.readTag();",
        "pred_variables": [
            "t"
        ],
        "label_variables": [
            "tag"
        ]
    },
    {
        "code": "private void assertIEDriver() {\n    File driver = new File(wdm.getDownloadedDriverPath());",
        "pred_variables": [
            "driver"
        ],
        "label_variables": [
            "driver"
        ]
    }
]